{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/docs/source/css/index.less","path":"css/index.less","modified":1,"renderable":1},{"_id":"themes/docs/source/images/favicon.png","path":"images/favicon.png","modified":1,"renderable":1},{"_id":"themes/docs/source/images/feature1.svg","path":"images/feature1.svg","modified":1,"renderable":1},{"_id":"themes/docs/source/images/feature2.svg","path":"images/feature2.svg","modified":1,"renderable":1},{"_id":"themes/docs/source/images/feature3.svg","path":"images/feature3.svg","modified":1,"renderable":1},{"_id":"themes/docs/source/images/github.svg","path":"images/github.svg","modified":1,"renderable":1},{"_id":"themes/docs/source/images/logo-new.svg","path":"images/logo-new.svg","modified":1,"renderable":1},{"_id":"themes/docs/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/docs/source/images/logo_bak.png","path":"images/logo_bak.png","modified":1,"renderable":1},{"_id":"themes/docs/source/images/search.png","path":"images/search.png","modified":1,"renderable":1},{"_id":"themes/docs/source/js/mobile-aside.js","path":"js/mobile-aside.js","modified":1,"renderable":1},{"_id":"themes/docs/source/images/banner.jpg","path":"images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/docs/source/images/logo-animate.js","path":"images/logo-animate.js","modified":1,"renderable":1},{"_id":"themes/docs/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/docs/source/css/page/index.less","path":"css/page/index.less","modified":1,"renderable":1},{"_id":"themes/docs/source/css/page/page.less","path":"css/page/page.less","modified":1,"renderable":1},{"_id":"themes/docs/source/css/partial/footer.less","path":"css/partial/footer.less","modified":1,"renderable":1},{"_id":"themes/docs/source/css/partial/main.less","path":"css/partial/main.less","modified":1,"renderable":1},{"_id":"themes/docs/source/css/partial/mobile.less","path":"css/partial/mobile.less","modified":1,"renderable":1},{"_id":"themes/docs/source/css/partial/nav.less","path":"css/partial/nav.less","modified":1,"renderable":1},{"_id":"themes/docs/source/css/partial/toc.less","path":"css/partial/toc.less","modified":1,"renderable":1},{"_id":"themes/docs/source/css/partial/var.less","path":"css/partial/var.less","modified":1,"renderable":1},{"_id":"themes/docs/source/css/vendor/github-markdown.less","path":"css/vendor/github-markdown.less","modified":1,"renderable":1},{"_id":"themes/docs/source/css/vendor/highlight-github.less","path":"css/vendor/highlight-github.less","modified":1,"renderable":1},{"_id":"themes/docs/source/css/vendor/normalize.less","path":"css/vendor/normalize.less","modified":1,"renderable":1},{"_id":"themes/docs/source/images/sylph/job_flow.png","path":"images/sylph/job_flow.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_data/languages.yml","hash":"3804a591802041eac34bd13681909fc9751287a5","modified":1562416660000},{"_id":"source/_data/menu.yml","hash":"571d4cfd8df6cbd3df7be76d131e2c8962be9ebd","modified":1562416660000},{"_id":"source/_data/sidebar.yml","hash":"b3047ceb7dedfa003d11922fb9749a6a2093d49b","modified":1562416660000},{"_id":"source/api/index.md","hash":"c6de5cb20ea9042d8fdc31b03fa2d15f2d2645a6","modified":1562416660000},{"_id":"source/en/faq.md","hash":"d332c4528286760480f8b4d07d69a9e1fb37b48b","modified":1562416660000},{"_id":"source/en/index.md","hash":"ed7da7a89addb5d05a0c57aee64b097e6d9172a1","modified":1562416660000},{"_id":"source/zh-cn/faq.md","hash":"7ace4703b49dbeabf8abe3bb6b026efbff84d091","modified":1562416660000},{"_id":"source/zh-cn/index.md","hash":"17eb752d219e417a454c4e3ab93e0cc375539527","modified":1562416660000},{"_id":"themes/docs/languages/en.yml","hash":"b8ee4bc221dcd8f2f686731b78af08b3668a0f88","modified":1562416660000},{"_id":"themes/docs/languages/zh-cn.yml","hash":"26fe30f4f6332b28387682ffd617f0e96687df2e","modified":1562416660000},{"_id":"themes/docs/layout/index.swig","hash":"667978381fdb7268a112dc5de6e0a6fafd5f5171","modified":1562416660000},{"_id":"themes/docs/layout/layout.swig","hash":"5be73ff4f095b78ce2460a710c8c601906aa36a4","modified":1562416660000},{"_id":"themes/docs/layout/page.swig","hash":"c5e3b8939a3a48ce20d52437eac36b257a883aa9","modified":1562416660000},{"_id":"themes/docs/layout/post.swig","hash":"f6c4327f460a9709a7f2310e577b0e5c0e2923ce","modified":1562416660000},{"_id":"themes/docs/lib/renderer.js","hash":"55ee9e54230728d7f4067946a395d01575e34909","modified":1562416660000},{"_id":"themes/docs/scripts/helpers.js","hash":"bf367435935a9d9b0652d5a956585e5e59f9cfe2","modified":1562416660000},{"_id":"source/zh-cn/fekey/quickstart.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562416660000},{"_id":"source/en/page/process.md","hash":"10c4164c54f9434d2a00b9a85b96bf618b2111dc","modified":1562416660000},{"_id":"source/en/page/user.md","hash":"c58fbbc6b5093bac101009712af4e7850de039cd","modified":1562416660000},{"_id":"source/zh-cn/fekey/index.md","hash":"5e7ccc281bfb2b8294c5c9b8a095659b28499f1c","modified":1562416660000},{"_id":"source/zh-cn/page/process.md","hash":"d6b41a9068373933508a19811d8eaa938f3cb571","modified":1562416660000},{"_id":"source/zh-cn/page/user.md","hash":"f0d730128dd066d08f1ca6b48c63f4452287c421","modified":1562416660000},{"_id":"themes/docs/layout/partial/aside.swig","hash":"d8e0c327bf6de80c58d132209161b1565e792291","modified":1562416660000},{"_id":"themes/docs/layout/partial/footer.swig","hash":"11e8e068135f093168c2a390f84e4d73d93e744e","modified":1562416660000},{"_id":"themes/docs/layout/partial/head.swig","hash":"a376e41761105485362d6f3bab2118e997f86bba","modified":1562416660000},{"_id":"themes/docs/layout/partial/header.swig","hash":"a17b91f121a43aa155b4b40a3987087cbaa99fa0","modified":1562416660000},{"_id":"themes/docs/source/css/index.less","hash":"6df5bab7876f837f4bdaba0877340e4d252b69a5","modified":1562416660000},{"_id":"themes/docs/source/images/favicon.png","hash":"e068d58e3cc69cade905380341272204f03ef5e5","modified":1562416660000},{"_id":"themes/docs/source/images/feature1.svg","hash":"89c206b01100601198db1061f1794ce5f05fbc2d","modified":1562416660000},{"_id":"themes/docs/source/images/feature2.svg","hash":"76be29924107ca51fbf2334255a405150184deab","modified":1562416660000},{"_id":"themes/docs/source/images/feature3.svg","hash":"a933c213816c27de94de652cbe8661d14058bf52","modified":1562416660000},{"_id":"themes/docs/source/images/github.svg","hash":"8aa231576e934ff412acb146b4e88d81efe9988e","modified":1562416660000},{"_id":"themes/docs/source/images/logo-new.svg","hash":"5b65eab014487a3a0b743b6b8d999094ab2698dc","modified":1562416660000},{"_id":"themes/docs/source/images/logo.svg","hash":"ca876e30393b3cd283482bd3c049c09c0c714254","modified":1562416660000},{"_id":"themes/docs/source/images/logo_bak.png","hash":"e9dc5018369c36c78c750047a2b24be7bede20f4","modified":1562416660000},{"_id":"themes/docs/source/images/search.png","hash":"4546e84b0067609c3fa3c59358c68bf82ebc03a4","modified":1562416660000},{"_id":"themes/docs/source/js/mobile-aside.js","hash":"e7ec3603be6ae1931c20279fa671c30d561faac7","modified":1562416660000},{"_id":"themes/docs/source/images/banner.jpg","hash":"6e7662ee79724bbc260caf2bbd5e8984a153f8e8","modified":1562416660000},{"_id":"themes/docs/source/images/logo-animate.js","hash":"b7c795e9bf84b34e38532b38a7314b0477a193f0","modified":1562416660000},{"_id":"themes/docs/source/images/logo.png","hash":"e0b51d3380ecdd2d247e66b41f78c1d48736975e","modified":1562416660000},{"_id":"source/en/docs/advanced/framework.md","hash":"ae3dbf3b79fae56c766fdc846019614aaf62ce4e","modified":1562416660000},{"_id":"source/en/docs/advanced/plugin_api.md","hash":"992e6514a367bede2a2a17071a3a059c2d247e8f","modified":1562416660000},{"_id":"source/en/docs/advanced/plugin_manager.md","hash":"3cc18360ceb1ba87166373f6c2c0f75a378beaf4","modified":1562416660000},{"_id":"source/en/docs/basics/deployment.md","hash":"6135f46743212af1ac3f01b20288c87909536965","modified":1562416660000},{"_id":"source/en/docs/basics/mock.md","hash":"588ffa38ca054ae0facc58b256c5822093361429","modified":1562416660000},{"_id":"source/en/docs/basics/online.md","hash":"6d87330e0dce31df963718e952baf80f9e2ce687","modified":1562416660000},{"_id":"source/en/docs/basics/service.md","hash":"b6405221dde59fa80b50b54103ad9120a5dcc59c","modified":1562416660000},{"_id":"source/en/docs/basics/setup.md","hash":"e15a849176dae6cf41adfbe3c6e168a4f315f709","modified":1562416660000},{"_id":"source/en/docs/basics/structure.md","hash":"296acef7a29df97343cf918234f185cec8e7bf63","modified":1562416660000},{"_id":"source/en/docs/core/fetch-server.md","hash":"dc7ae22801b50d30cbc1b07a7a958ebeec7d4726","modified":1562416660000},{"_id":"source/en/docs/core/framework.md","hash":"a85510ac5c06eadb2b8ef6a40b66c3e71a9ce741","modified":1562416660000},{"_id":"source/en/docs/core/plugin.md","hash":"9509ea96c7ef40ecd1fdc16b1f130e3307b34522","modified":1562416660000},{"_id":"source/en/docs/core/server-isoloton.md","hash":"cdd95fc7f1a36c20ff33396abc01318e6bbf168e","modified":1562416660000},{"_id":"source/en/docs/faq/contributing.md","hash":"1945fed999d3148d9a09de7a3bb6a975773fd961","modified":1562416660000},{"_id":"source/en/docs/faq/debug.md","hash":"e616aeb50cbbcc9dcfd43f19113a8ed5c68fcc9c","modified":1562416660000},{"_id":"source/en/docs/faq/deploy.md","hash":"e3a57d21f5648db0c961361ed4126b3f5515477a","modified":1562416660000},{"_id":"source/en/docs/faq/start.md","hash":"04753b7a34eeba4c86182812cc9b0eec3c99126f","modified":1562416660000},{"_id":"source/en/docs/faq/wechat.md","hash":"395fef963cfe71cdb2adc278e10ce4d6cb104695","modified":1562416660000},{"_id":"source/en/docs/intro/batch-join.md","hash":"279fac2e723cde5e6a8a39cb9e2e275e1a359a94","modified":1562416660000},{"_id":"source/en/docs/intro/etl.md","hash":"0f69bf4a690b047e2f7e19a45dadc714525522e7","modified":1562416660000},{"_id":"source/en/docs/intro/index.md","hash":"a01e22c84c37d80ebf21593bf5a8cbc52e7f8194","modified":1562416660000},{"_id":"source/en/docs/intro/quickstart.md","hash":"65bb697d4ef9f7420afd8156c75cc590241635a1","modified":1562416660000},{"_id":"source/zh-cn/docs/advanced/framework.md","hash":"ae3dbf3b79fae56c766fdc846019614aaf62ce4e","modified":1562416660000},{"_id":"source/zh-cn/docs/advanced/plugin_api.md","hash":"992e6514a367bede2a2a17071a3a059c2d247e8f","modified":1562416660000},{"_id":"source/zh-cn/docs/advanced/plugin_manager.md","hash":"3cc18360ceb1ba87166373f6c2c0f75a378beaf4","modified":1562416660000},{"_id":"source/zh-cn/docs/basics/deployment.md","hash":"6135f46743212af1ac3f01b20288c87909536965","modified":1562416660000},{"_id":"source/zh-cn/docs/basics/mock.md","hash":"588ffa38ca054ae0facc58b256c5822093361429","modified":1562416660000},{"_id":"source/zh-cn/docs/basics/online.md","hash":"6d87330e0dce31df963718e952baf80f9e2ce687","modified":1562416660000},{"_id":"source/zh-cn/docs/basics/service.md","hash":"b6405221dde59fa80b50b54103ad9120a5dcc59c","modified":1562416660000},{"_id":"source/zh-cn/docs/basics/setup.md","hash":"e15a849176dae6cf41adfbe3c6e168a4f315f709","modified":1562416660000},{"_id":"source/zh-cn/docs/basics/structure.md","hash":"296acef7a29df97343cf918234f185cec8e7bf63","modified":1562416660000},{"_id":"source/zh-cn/docs/core/fetch-server.md","hash":"dc7ae22801b50d30cbc1b07a7a958ebeec7d4726","modified":1562416660000},{"_id":"source/zh-cn/docs/core/framework.md","hash":"a85510ac5c06eadb2b8ef6a40b66c3e71a9ce741","modified":1562416660000},{"_id":"source/zh-cn/docs/core/plugin.md","hash":"9509ea96c7ef40ecd1fdc16b1f130e3307b34522","modified":1562416660000},{"_id":"source/zh-cn/docs/core/server-isoloton.md","hash":"cdd95fc7f1a36c20ff33396abc01318e6bbf168e","modified":1562416660000},{"_id":"source/zh-cn/docs/faq/contributing.md","hash":"1945fed999d3148d9a09de7a3bb6a975773fd961","modified":1562416660000},{"_id":"source/zh-cn/docs/faq/debug.md","hash":"e616aeb50cbbcc9dcfd43f19113a8ed5c68fcc9c","modified":1562416660000},{"_id":"source/zh-cn/docs/faq/deploy.md","hash":"e3a57d21f5648db0c961361ed4126b3f5515477a","modified":1562416660000},{"_id":"source/zh-cn/docs/faq/start.md","hash":"04753b7a34eeba4c86182812cc9b0eec3c99126f","modified":1562416660000},{"_id":"source/zh-cn/docs/faq/wechat.md","hash":"395fef963cfe71cdb2adc278e10ce4d6cb104695","modified":1562416660000},{"_id":"source/zh-cn/docs/intro/batch-join.md","hash":"279fac2e723cde5e6a8a39cb9e2e275e1a359a94","modified":1562416660000},{"_id":"source/zh-cn/docs/intro/etl.md","hash":"0f69bf4a690b047e2f7e19a45dadc714525522e7","modified":1562416660000},{"_id":"source/zh-cn/docs/intro/index.md","hash":"a01e22c84c37d80ebf21593bf5a8cbc52e7f8194","modified":1562416660000},{"_id":"source/zh-cn/docs/intro/quickstart.md","hash":"65bb697d4ef9f7420afd8156c75cc590241635a1","modified":1562416660000},{"_id":"themes/docs/source/css/page/index.less","hash":"8596afbd70fb4ad30374f3e9dc7c6590106a5280","modified":1562416660000},{"_id":"themes/docs/source/css/page/page.less","hash":"1939018cadb4ae39dfbaa19e343b2339da17e274","modified":1562416660000},{"_id":"themes/docs/source/css/partial/footer.less","hash":"1561c2233a3a798a0c3bb7a76fbe8e1b28f433c2","modified":1562416660000},{"_id":"themes/docs/source/css/partial/main.less","hash":"9ba9995365f2d00ab3e8359089b71878885a17a9","modified":1562416660000},{"_id":"themes/docs/source/css/partial/mobile.less","hash":"a388288e261d9f0521f7f68858ce12e597063667","modified":1562416660000},{"_id":"themes/docs/source/css/partial/nav.less","hash":"962c8968afd8d4e3fd7469824e0768191eb1d55a","modified":1562416660000},{"_id":"themes/docs/source/css/partial/toc.less","hash":"ae704ea8056b996345b8f657174ec1efde50dd77","modified":1562416660000},{"_id":"themes/docs/source/css/partial/var.less","hash":"6c4df2bbe3454fdb95d5785cb4487acb99ac0115","modified":1562416660000},{"_id":"themes/docs/source/css/vendor/github-markdown.less","hash":"4c278ccdb766396fcc4ca09284d3593f46d55164","modified":1562416660000},{"_id":"themes/docs/source/css/vendor/highlight-github.less","hash":"7bf93821c11af335c3807db3dc25c444559a0ede","modified":1562416660000},{"_id":"themes/docs/source/css/vendor/normalize.less","hash":"8ba9aca6723d38559c0e093bce46811dff9c5982","modified":1562416660000},{"_id":"themes/docs/source/images/sylph/job_flow.png","hash":"3d0629643d2028a6ec554a1e77d9a3538e95e60f","modified":1562416660000}],"Category":[],"Data":[{"_id":"languages","data":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}}},{"_id":"menu","data":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"}},{"_id":"sidebar","data":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}],"Page":[{"title":"FAQ","_content":"\nIf you have questions that is not contained below, please check [Egg issues](https://github.com/eggjs/egg/issues).\n\n## Why my config don't work ?\n\nFramework [Config](./basics/config.md) settings is powerfull, support different environments and different places(framework, plugins, app).\n\nWhen you got some trouble, and want to find out what is the final config using at runtime, you can checkout `run/application_config.json` and `run/agent_config.json`.\n\n## Why not choose PM2 as process management tool?\n\n1. PM2 itself is too complex to issue problems if any.\n2. Deep optimization could be difficlut to achieve if choosing PM2.\n3. Pattern like one leader process communicating with remote services, along with serveral follower processes delegating request to it ([Cluster](./core/cluster-and-ipc.md)), is a rigid demand for reducing connections and data exchange load, espeically when facing applications in very large scale. egg originates from Ant Financial Group and Alibaba Group, we start with applications in that scale at first, so we take these goals into consideration. All of these goals above could be hard to achieve with PM2.\n\nProcess management is very important. It defines the way we write code, meanwhile relates to deep runtime optimizations. So we think it's better included in framework itself.\n\n**How to start application with PM2?**\n\nAlthough PM2 is not recommanded, you can use it anyway.\n\nFirstly, put a start file in the root directory of your project:\n\n```js\n// server.js\nconst egg = require('egg');\n\nconst workers = Number(process.argv[2] || require('os').cpus().length);\negg.startCluster({\n  workers,\n  baseDir: __dirname,\n});\n```\n\nWe can start application with PM2 like this:\n\n```bash\npm2 start server.js\n```\n\n## How to resolve csrf error?\n\nThere are two kinds of common csrf errors:\n\n- `missing csrf token`\n- `invalid csrf token`\n\nBy default [egg-security](https://github.com/eggjs/egg-security/) plugin built in Egg requires CSRF validation against all 'unsafe' request such as `POST`, `PUT`, `DELETE` requests.\n\nThe error will disappear in the presence of correct csrf token in request. For more implentation details, see [./core/security.md#csrf].\n","source":"en/faq.md","raw":"title: FAQ\n---\n\nIf you have questions that is not contained below, please check [Egg issues](https://github.com/eggjs/egg/issues).\n\n## Why my config don't work ?\n\nFramework [Config](./basics/config.md) settings is powerfull, support different environments and different places(framework, plugins, app).\n\nWhen you got some trouble, and want to find out what is the final config using at runtime, you can checkout `run/application_config.json` and `run/agent_config.json`.\n\n## Why not choose PM2 as process management tool?\n\n1. PM2 itself is too complex to issue problems if any.\n2. Deep optimization could be difficlut to achieve if choosing PM2.\n3. Pattern like one leader process communicating with remote services, along with serveral follower processes delegating request to it ([Cluster](./core/cluster-and-ipc.md)), is a rigid demand for reducing connections and data exchange load, espeically when facing applications in very large scale. egg originates from Ant Financial Group and Alibaba Group, we start with applications in that scale at first, so we take these goals into consideration. All of these goals above could be hard to achieve with PM2.\n\nProcess management is very important. It defines the way we write code, meanwhile relates to deep runtime optimizations. So we think it's better included in framework itself.\n\n**How to start application with PM2?**\n\nAlthough PM2 is not recommanded, you can use it anyway.\n\nFirstly, put a start file in the root directory of your project:\n\n```js\n// server.js\nconst egg = require('egg');\n\nconst workers = Number(process.argv[2] || require('os').cpus().length);\negg.startCluster({\n  workers,\n  baseDir: __dirname,\n});\n```\n\nWe can start application with PM2 like this:\n\n```bash\npm2 start server.js\n```\n\n## How to resolve csrf error?\n\nThere are two kinds of common csrf errors:\n\n- `missing csrf token`\n- `invalid csrf token`\n\nBy default [egg-security](https://github.com/eggjs/egg-security/) plugin built in Egg requires CSRF validation against all 'unsafe' request such as `POST`, `PUT`, `DELETE` requests.\n\nThe error will disappear in the presence of correct csrf token in request. For more implentation details, see [./core/security.md#csrf].\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/faq.html","comments":1,"layout":"page","_id":"cjyd4skbw00006lq1lnu1s4ae","content":"<p>If you have questions that is not contained below, please check <a href=\"https://github.com/eggjs/egg/issues\" target=\"_blank\" rel=\"noopener\">Egg issues</a>.</p>\n<h2 id=\"why-my-config-dont-work\"><a class=\"markdown-anchor\" href=\"#why-my-config-dont-work\">#</a> Why my config don't work ?</h2>\n<p>Framework <a href=\"./basics/config.html\">Config</a> settings is powerfull, support different environments and different places(framework, plugins, app).</p>\n<p>When you got some trouble, and want to find out what is the final config using at runtime, you can checkout <code>run/application_config.json</code> and <code>run/agent_config.json</code>.</p>\n<h2 id=\"why-not-choose-pm2-as-process-management-tool\"><a class=\"markdown-anchor\" href=\"#why-not-choose-pm2-as-process-management-tool\">#</a> Why not choose PM2 as process management tool?</h2>\n<ol>\n<li>PM2 itself is too complex to issue problems if any.</li>\n<li>Deep optimization could be difficlut to achieve if choosing PM2.</li>\n<li>Pattern like one leader process communicating with remote services, along with serveral follower processes delegating request to it (<a href=\"./core/cluster-and-ipc.html\">Cluster</a>), is a rigid demand for reducing connections and data exchange load, espeically when facing applications in very large scale. egg originates from Ant Financial Group and Alibaba Group, we start with applications in that scale at first, so we take these goals into consideration. All of these goals above could be hard to achieve with PM2.</li>\n</ol>\n<p>Process management is very important. It defines the way we write code, meanwhile relates to deep runtime optimizations. So we think it's better included in framework itself.</p>\n<p><strong>How to start application with PM2?</strong></p>\n<p>Although PM2 is not recommanded, you can use it anyway.</p>\n<p>Firstly, put a start file in the root directory of your project:</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> egg = <span class=\"built_in\">require</span>(<span class=\"string\">'egg'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> workers = <span class=\"built_in\">Number</span>(process.argv[<span class=\"number\">2</span>] || <span class=\"built_in\">require</span>(<span class=\"string\">'os'</span>).cpus().length);</span><br><span class=\"line\">egg.startCluster(&#123;</span><br><span class=\"line\">  workers,</span><br><span class=\"line\">  baseDir: __dirname,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>We can start application with PM2 like this:</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 start server.js</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"how-to-resolve-csrf-error\"><a class=\"markdown-anchor\" href=\"#how-to-resolve-csrf-error\">#</a> How to resolve csrf error?</h2>\n<p>There are two kinds of common csrf errors:</p>\n<ul>\n<li><code>missing csrf token</code></li>\n<li><code>invalid csrf token</code></li>\n</ul>\n<p>By default <a href=\"https://github.com/eggjs/egg-security/\" target=\"_blank\" rel=\"noopener\">egg-security</a> plugin built in Egg requires CSRF validation against all 'unsafe' request such as <code>POST</code>, <code>PUT</code>, <code>DELETE</code> requests.</p>\n<p>The error will disappear in the presence of correct csrf token in request. For more implentation details, see [./core/security.md#csrf].</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>If you have questions that is not contained below, please check <a href=\"https://github.com/eggjs/egg/issues\" target=\"_blank\" rel=\"noopener\">Egg issues</a>.</p>\n<h2 id=\"why-my-config-dont-work\"><a class=\"markdown-anchor\" href=\"#why-my-config-dont-work\">#</a> Why my config don't work ?</h2>\n<p>Framework <a href=\"./basics/config.html\">Config</a> settings is powerfull, support different environments and different places(framework, plugins, app).</p>\n<p>When you got some trouble, and want to find out what is the final config using at runtime, you can checkout <code>run/application_config.json</code> and <code>run/agent_config.json</code>.</p>\n<h2 id=\"why-not-choose-pm2-as-process-management-tool\"><a class=\"markdown-anchor\" href=\"#why-not-choose-pm2-as-process-management-tool\">#</a> Why not choose PM2 as process management tool?</h2>\n<ol>\n<li>PM2 itself is too complex to issue problems if any.</li>\n<li>Deep optimization could be difficlut to achieve if choosing PM2.</li>\n<li>Pattern like one leader process communicating with remote services, along with serveral follower processes delegating request to it (<a href=\"./core/cluster-and-ipc.html\">Cluster</a>), is a rigid demand for reducing connections and data exchange load, espeically when facing applications in very large scale. egg originates from Ant Financial Group and Alibaba Group, we start with applications in that scale at first, so we take these goals into consideration. All of these goals above could be hard to achieve with PM2.</li>\n</ol>\n<p>Process management is very important. It defines the way we write code, meanwhile relates to deep runtime optimizations. So we think it's better included in framework itself.</p>\n<p><strong>How to start application with PM2?</strong></p>\n<p>Although PM2 is not recommanded, you can use it anyway.</p>\n<p>Firstly, put a start file in the root directory of your project:</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> egg = <span class=\"built_in\">require</span>(<span class=\"string\">'egg'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> workers = <span class=\"built_in\">Number</span>(process.argv[<span class=\"number\">2</span>] || <span class=\"built_in\">require</span>(<span class=\"string\">'os'</span>).cpus().length);</span><br><span class=\"line\">egg.startCluster(&#123;</span><br><span class=\"line\">  workers,</span><br><span class=\"line\">  baseDir: __dirname,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>We can start application with PM2 like this:</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pm2 start server.js</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"how-to-resolve-csrf-error\"><a class=\"markdown-anchor\" href=\"#how-to-resolve-csrf-error\">#</a> How to resolve csrf error?</h2>\n<p>There are two kinds of common csrf errors:</p>\n<ul>\n<li><code>missing csrf token</code></li>\n<li><code>invalid csrf token</code></li>\n</ul>\n<p>By default <a href=\"https://github.com/eggjs/egg-security/\" target=\"_blank\" rel=\"noopener\">egg-security</a> plugin built in Egg requires CSRF validation against all 'unsafe' request such as <code>POST</code>, <code>PUT</code>, <code>DELETE</code> requests.</p>\n<p>The error will disappear in the presence of correct csrf token in request. For more implentation details, see [./core/security.md#csrf].</p>\n"},{"layout":"index","description":"Hexo is a fast, simple & powerful blog framework powered by sylph.","subtitle":"Build your private stream computing experiment platform","doc":null,"_content":"","source":"en/index.md","raw":"layout: index\ndescription: Hexo is a fast, simple & powerful blog framework powered by sylph.\nsubtitle: Build your private stream computing experiment platform\ndoc: \n---\n","date":"2019-07-21T11:14:44.067Z","updated":"2019-07-06T12:37:40.000Z","path":"en/index.html","title":"","comments":1,"_id":"cjyd4skc000016lq1u8mnhr1b","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"layout":"api","title":"API","_content":"","source":"api/index.md","raw":"layout: api\ntitle: API\n---\n","date":"2019-07-21T11:14:44.065Z","updated":"2019-07-06T12:37:40.000Z","path":"api/index.html","comments":1,"_id":"cjyd4skc500026lq1jarg1956","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"常见问题","_content":"\n##  why ...？\n\n","source":"zh-cn/faq.md","raw":"title: 常见问题\n---\n\n##  why ...？\n\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/faq.html","comments":1,"layout":"page","_id":"cjyd4skc800036lq1pjn0dsxj","content":"<h2 id=\"why\"><a class=\"markdown-anchor\" href=\"#why\">#</a> why ...？</h2>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<h2 id=\"why\"><a class=\"markdown-anchor\" href=\"#why\">#</a> why ...？</h2>\n"},{"layout":"index","description":"Hexo is a fast, simple & powerful blog framework powered by sylph.","subtitle":"sylph stream framework","doc":"搭建流计算平台","comments":0,"_content":"","source":"zh-cn/index.md","raw":"layout: index\ndescription: Hexo is a fast, simple & powerful blog framework powered by sylph.\nsubtitle: sylph stream framework\ndoc: 搭建流计算平台\ncomments: false\n---","date":"2019-07-21T11:14:44.065Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/index.html","title":"","_id":"cjyd4skcb00046lq1ug1h0xvj","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"_content":"","source":"zh-cn/fekey/quickstart.md","raw":"","date":"2019-07-21T11:14:44.065Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/fekey/quickstart.html","title":"","comments":1,"layout":"page","_id":"cjyd4skd900056lq1bg0wlowi","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"layout":"post","title":"NodeUI接入流程","_content":"\n如果当前的产品开发陷入了如下的困惑：\n\n- 前端开发环境强依赖后端\n- 基于`React/Vue`移动端性能优化遇到首屏瓶颈\n- 想用`bigpipe`加速渲染\n- 后端统一输出的接口不满意，想拆分 or 想合并请求\n- 我是前端，我就是想用`Node.js`\n\n那么，恭喜你，NodeUI是非常适合你的。我们的接入流程是：\n\n#### 1. 流量预估\n\n如果你想直接把自己的业务接入线上的NodeUI服务，那么需要实现评估业务的流量。主要包括 `PV` 及 `QPS`。\n\n项目 | 预估值\n--- | ---\nQPS峰值 | 10\nPV总量  | 10W\n\n#### 2. 申请路由及模块\n\n项目 | 说明 \n--- | ---\n模块名称 | cfe_h5\niCode地址 | \n路由名称 | fly/vip\nBNS服务 | \n\n**注意：项目模块名称及fekey构建时候的namespance，与路由名称可以不一致**\n\n#### 3. 发送邮件\n","source":"en/page/process.md","raw":"layout: post\ntitle: NodeUI接入流程\n---\n\n如果当前的产品开发陷入了如下的困惑：\n\n- 前端开发环境强依赖后端\n- 基于`React/Vue`移动端性能优化遇到首屏瓶颈\n- 想用`bigpipe`加速渲染\n- 后端统一输出的接口不满意，想拆分 or 想合并请求\n- 我是前端，我就是想用`Node.js`\n\n那么，恭喜你，NodeUI是非常适合你的。我们的接入流程是：\n\n#### 1. 流量预估\n\n如果你想直接把自己的业务接入线上的NodeUI服务，那么需要实现评估业务的流量。主要包括 `PV` 及 `QPS`。\n\n项目 | 预估值\n--- | ---\nQPS峰值 | 10\nPV总量  | 10W\n\n#### 2. 申请路由及模块\n\n项目 | 说明 \n--- | ---\n模块名称 | cfe_h5\niCode地址 | \n路由名称 | fly/vip\nBNS服务 | \n\n**注意：项目模块名称及fekey构建时候的namespance，与路由名称可以不一致**\n\n#### 3. 发送邮件\n","date":"2019-07-21T11:14:44.067Z","updated":"2019-07-06T12:37:40.000Z","path":"en/page/process.html","comments":1,"_id":"cjyd4skdi00066lq1g4qdlan0","content":"<p>如果当前的产品开发陷入了如下的困惑：</p>\n<ul>\n<li>前端开发环境强依赖后端</li>\n<li>基于<code>React/Vue</code>移动端性能优化遇到首屏瓶颈</li>\n<li>想用<code>bigpipe</code>加速渲染</li>\n<li>后端统一输出的接口不满意，想拆分 or 想合并请求</li>\n<li>我是前端，我就是想用<code>Node.js</code></li>\n</ul>\n<p>那么，恭喜你，NodeUI是非常适合你的。我们的接入流程是：</p>\n<h4 id=\"1-流量预估\"><a class=\"markdown-anchor\" href=\"#1-流量预估\">#</a> 1. 流量预估</h4>\n<p>如果你想直接把自己的业务接入线上的NodeUI服务，那么需要实现评估业务的流量。主要包括 <code>PV</code> 及 <code>QPS</code>。</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>预估值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>QPS峰值</td>\n<td>10</td>\n</tr>\n<tr>\n<td>PV总量</td>\n<td>10W</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-申请路由及模块\"><a class=\"markdown-anchor\" href=\"#2-申请路由及模块\">#</a> 2. 申请路由及模块</h4>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模块名称</td>\n<td>cfe_h5</td>\n</tr>\n<tr>\n<td>iCode地址</td>\n<td></td>\n</tr>\n<tr>\n<td>路由名称</td>\n<td>fly/vip</td>\n</tr>\n<tr>\n<td>BNS服务</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：项目模块名称及fekey构建时候的namespance，与路由名称可以不一致</strong></p>\n<h4 id=\"3-发送邮件\"><a class=\"markdown-anchor\" href=\"#3-发送邮件\">#</a> 3. 发送邮件</h4>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>如果当前的产品开发陷入了如下的困惑：</p>\n<ul>\n<li>前端开发环境强依赖后端</li>\n<li>基于<code>React/Vue</code>移动端性能优化遇到首屏瓶颈</li>\n<li>想用<code>bigpipe</code>加速渲染</li>\n<li>后端统一输出的接口不满意，想拆分 or 想合并请求</li>\n<li>我是前端，我就是想用<code>Node.js</code></li>\n</ul>\n<p>那么，恭喜你，NodeUI是非常适合你的。我们的接入流程是：</p>\n<h4 id=\"1-流量预估\"><a class=\"markdown-anchor\" href=\"#1-流量预估\">#</a> 1. 流量预估</h4>\n<p>如果你想直接把自己的业务接入线上的NodeUI服务，那么需要实现评估业务的流量。主要包括 <code>PV</code> 及 <code>QPS</code>。</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>预估值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>QPS峰值</td>\n<td>10</td>\n</tr>\n<tr>\n<td>PV总量</td>\n<td>10W</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-申请路由及模块\"><a class=\"markdown-anchor\" href=\"#2-申请路由及模块\">#</a> 2. 申请路由及模块</h4>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模块名称</td>\n<td>cfe_h5</td>\n</tr>\n<tr>\n<td>iCode地址</td>\n<td></td>\n</tr>\n<tr>\n<td>路由名称</td>\n<td>fly/vip</td>\n</tr>\n<tr>\n<td>BNS服务</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：项目模块名称及fekey构建时候的namespance，与路由名称可以不一致</strong></p>\n<h4 id=\"3-发送邮件\"><a class=\"markdown-anchor\" href=\"#3-发送邮件\">#</a> 3. 发送邮件</h4>\n"},{"layout":"post","title":"Who is using stream computing","_content":"\n\n- .......","source":"en/page/user.md","raw":"layout: post\ntitle: Who is using stream computing\n---\n\n\n- .......","date":"2019-07-21T11:14:44.067Z","updated":"2019-07-06T12:37:40.000Z","path":"en/page/user.html","comments":1,"_id":"cjyd4skdk00076lq171wch0lh","content":"<ul>\n<li>.......</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<ul>\n<li>.......</li>\n</ul>\n"},{"title":"...","_content":"","source":"zh-cn/fekey/index.md","raw":"title: ...\n---\n","date":"2019-07-21T11:14:44.065Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/fekey/index.html","comments":1,"layout":"page","_id":"cjyd4skdm00086lq1zp6cv3vz","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"...","_content":"\n\n**注意：....**\n\n#### 1. ...\n","source":"zh-cn/page/process.md","raw":"title: ...\n---\n\n\n**注意：....**\n\n#### 1. ...\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/page/process.html","comments":1,"layout":"page","_id":"cjyd4skdo00096lq10s34teom","content":"<p><strong>注意：....</strong></p>\n<h4 id=\"1\"><a class=\"markdown-anchor\" href=\"#1\">#</a> 1. ...</h4>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p><strong>注意：....</strong></p>\n<h4 id=\"1\"><a class=\"markdown-anchor\" href=\"#1\">#</a> 1. ...</h4>\n"},{"layout":"post","title":"谁在使用流计算","_content":"\n\n- 实时预警\n- 实时全链路分析\n- 风控\n- 用户行为分析\n- 实时etl\n- 物联网IOT场景\n- .......","source":"zh-cn/page/user.md","raw":"layout: post\ntitle: 谁在使用流计算\n---\n\n\n- 实时预警\n- 实时全链路分析\n- 风控\n- 用户行为分析\n- 实时etl\n- 物联网IOT场景\n- .......","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/page/user.html","comments":1,"_id":"cjyd4skdq000a6lq1ww1iaz36","content":"<ul>\n<li>实时预警</li>\n<li>实时全链路分析</li>\n<li>风控</li>\n<li>用户行为分析</li>\n<li>实时etl</li>\n<li>物联网IOT场景</li>\n<li>.......</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<ul>\n<li>实时预警</li>\n<li>实时全链路分析</li>\n<li>风控</li>\n<li>用户行为分析</li>\n<li>实时etl</li>\n<li>物联网IOT场景</li>\n<li>.......</li>\n</ul>\n"},{"title":"插件api","_content":"","source":"en/docs/advanced/framework.md","raw":"\ntitle: 插件api\n---","date":"2019-07-21T11:14:44.067Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/advanced/framework.html","comments":1,"layout":"page","_id":"cjyd4ski2000b6lq19ooqz4ko","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"框架开发","_content":"","source":"en/docs/advanced/plugin_api.md","raw":"\ntitle: 框架开发\n---","date":"2019-07-21T11:14:44.067Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/advanced/plugin_api.html","comments":1,"layout":"page","_id":"cjyd4ski4000c6lq15yi3z269","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"插件管理","_content":"","source":"en/docs/advanced/plugin_manager.md","raw":"\ntitle: 插件管理\n---","date":"2019-07-21T11:14:44.067Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/advanced/plugin_manager.html","comments":1,"layout":"page","_id":"cjyd4ski5000d6lq1h4mywohg","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"应用部署","_content":"\n","source":"en/docs/basics/deployment.md","raw":"title: 应用部署\n---\n\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/basics/deployment.html","comments":1,"layout":"page","_id":"cjyd4ski7000e6lq1ub3tm37p","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"NodeUI数据模拟中心","_content":"\n数据mock主要分为前端接口的mock（client request）及向后请求的数据mock(server request)。\n\n其中，前端接口mock表现为 ajax请求。向后请求Mock主要是指nodeui向后请求php接口的mock，这种数据一般用来渲染到模板或者直接接口输出。\n\n所有的mock均支持热重启，即修改代码不需要重启nodeui，立即生效。\n\n### 目录规范\n\n```\nmock\n  ├─ server.conf // 配置中心  \n  ├─ common   // 公共接口目录\n  │  ├─ dynamic.js  // 动态数据\n  │  ├─ sample.json  // 静态json数据\n  ├─ ral // nodeui向php请求接口模拟\n  │  ├─ hongbao-getmobilebyopenid.js // 微信授权根据openid获取用户信息接口  \n  │  ├─ hongbao-updatemobilebyopenid.js // 更新用户信息接口  \n  │  ├─ huodong-2016usergrowstoryindex.js // 业务php接口模拟  \n  ├─ dumall // 业务接口\n  │  ├─ center.js // 小度商城个人中心\n  │  ├─ del.json // 删除卡片接口\n  ...\n```\n\n### 前端接口的使用\n\n前端接口的mock主要在`server.conf`里面进行配置\n    \n#### server.conf 配置语法\n\n    指令名称 正则规则 目标文件\n    \n- `指令名称` 支持 rewrite 、 redirect 和 proxy。\n- `正则规则` 用来命中需要作假的请求路径\n- `目标文件` 设置转发的目标地址，需要配置一个可请求的 url 地址。\n\n#### mock 静态假数据\n\n\n```\nrewrite ^\\/api\\/user$ /mock/sample.json\n\n// sample.json内容\n\n{\n    \"error\": 0,\n    \"message\": \"ok\",\n    \"data\": {\n        \"username\": \"younth\",\n        \"uid\": 1,\n        \"age\": 25,\n        \"company\": \"waimai\"\n    }\n}\n```\n\n#### mock 动态假数据\n\n> node 服务器可以通过 js 的方式提供动态假数据。，动态数据本质是 express 的 route.\n\n`rewrite ^\\/api\\/dynamic\\/time$ /mock/dynamic.js`\n\n```js\n// dynamic.js内容\nmodule.exports = function(req, res, next) {\n\n  res.write('Hello world ');\n\n  // set custom header.\n  // res.setHeader('xxxx', 'xxx');\n\n  res.end('The time is ' + Date.now());\n};\n\n// 更复杂的，可以直接引用其他模块，发送请求\n\n\nvar http = require('http');\nvar url = require('url');\nvar util = require('util');\nvar querystring = require('querystring');\n\n// 通过nodejs来抓取线上的结果。这样就完成了动态获取线上数据的功能\n\nmodule.exports = function(request, response, next) {\n\n    var method = request.method;\n    ...\n\n};\n\n```\n\n#### proxy 到其他服务的 api 地址\n\n```bash\n    // 支持正则分组\n    proxy ^\\/wmall\\/privilege\\/(.*)$  http://10.19.161.92:8059/wmall/privilege/$1\n```\n\n### ral 请求的mock\n\n主要是Node向下游服务(PHP)请求的数据mock，基于ral请求的数据模拟。\n\n#### 如何使用\n\n##### 1. 根据path 建立mock文件\n\n文件命名规则是 *请求的path用-符号连接*\n\n    /huodong/gamebase ->  huodong-gamebase.js\n\npath与文件名的映射关系必须按照上面的要求，否则无法mock。\n\n##### 2. 开启mock\n\n比如我们有这样的一个请求：\n\n```js\ngetData: function(req, tools, params) {\n    var options = {\n        data: params || {},\n        path: '/huodong/gamebase',\n        reqType: 'promise'\n    };\n    return tools.commonBusiness.pierce(req, 'SHOPUI', options);\n}\n```\nmock文件夹下面建立一个 `huodong-gamebase.js`,在请求的参数里面增加 `enableMock: true`开启mock\n\n```js\ngetData: function(req, tools, params) {\n    var options = {\n        data: params || {},\n        path: '/huodong/gamebase',\n        reqType: 'promise',\n        enableMock: true,//开启Mock\n    };\n    return tools.commonBusiness.pierce(req, 'SHOPUI', options);\n}\n```\n这样就完成了nodeui向php请求的数据mock\n\n## 测试链接\n\n- ral请求mock: http://127.0.0.1:8197/fly/h5/demo\n- 普通请求mock(rewrite): http://127.0.0.1:8197/api/user\n- 动态数据mock(rewrite): http://127.0.0.1:8197/api/dynamic/time\n- api proxy mock: http://127.0.0.1:8197/wmall/privilege/center\n- 重定向(redirect): http://127.0.0.1:8197/api/redirect\n","source":"en/docs/basics/mock.md","raw":"title: NodeUI数据模拟中心\n---\n\n数据mock主要分为前端接口的mock（client request）及向后请求的数据mock(server request)。\n\n其中，前端接口mock表现为 ajax请求。向后请求Mock主要是指nodeui向后请求php接口的mock，这种数据一般用来渲染到模板或者直接接口输出。\n\n所有的mock均支持热重启，即修改代码不需要重启nodeui，立即生效。\n\n### 目录规范\n\n```\nmock\n  ├─ server.conf // 配置中心  \n  ├─ common   // 公共接口目录\n  │  ├─ dynamic.js  // 动态数据\n  │  ├─ sample.json  // 静态json数据\n  ├─ ral // nodeui向php请求接口模拟\n  │  ├─ hongbao-getmobilebyopenid.js // 微信授权根据openid获取用户信息接口  \n  │  ├─ hongbao-updatemobilebyopenid.js // 更新用户信息接口  \n  │  ├─ huodong-2016usergrowstoryindex.js // 业务php接口模拟  \n  ├─ dumall // 业务接口\n  │  ├─ center.js // 小度商城个人中心\n  │  ├─ del.json // 删除卡片接口\n  ...\n```\n\n### 前端接口的使用\n\n前端接口的mock主要在`server.conf`里面进行配置\n    \n#### server.conf 配置语法\n\n    指令名称 正则规则 目标文件\n    \n- `指令名称` 支持 rewrite 、 redirect 和 proxy。\n- `正则规则` 用来命中需要作假的请求路径\n- `目标文件` 设置转发的目标地址，需要配置一个可请求的 url 地址。\n\n#### mock 静态假数据\n\n\n```\nrewrite ^\\/api\\/user$ /mock/sample.json\n\n// sample.json内容\n\n{\n    \"error\": 0,\n    \"message\": \"ok\",\n    \"data\": {\n        \"username\": \"younth\",\n        \"uid\": 1,\n        \"age\": 25,\n        \"company\": \"waimai\"\n    }\n}\n```\n\n#### mock 动态假数据\n\n> node 服务器可以通过 js 的方式提供动态假数据。，动态数据本质是 express 的 route.\n\n`rewrite ^\\/api\\/dynamic\\/time$ /mock/dynamic.js`\n\n```js\n// dynamic.js内容\nmodule.exports = function(req, res, next) {\n\n  res.write('Hello world ');\n\n  // set custom header.\n  // res.setHeader('xxxx', 'xxx');\n\n  res.end('The time is ' + Date.now());\n};\n\n// 更复杂的，可以直接引用其他模块，发送请求\n\n\nvar http = require('http');\nvar url = require('url');\nvar util = require('util');\nvar querystring = require('querystring');\n\n// 通过nodejs来抓取线上的结果。这样就完成了动态获取线上数据的功能\n\nmodule.exports = function(request, response, next) {\n\n    var method = request.method;\n    ...\n\n};\n\n```\n\n#### proxy 到其他服务的 api 地址\n\n```bash\n    // 支持正则分组\n    proxy ^\\/wmall\\/privilege\\/(.*)$  http://10.19.161.92:8059/wmall/privilege/$1\n```\n\n### ral 请求的mock\n\n主要是Node向下游服务(PHP)请求的数据mock，基于ral请求的数据模拟。\n\n#### 如何使用\n\n##### 1. 根据path 建立mock文件\n\n文件命名规则是 *请求的path用-符号连接*\n\n    /huodong/gamebase ->  huodong-gamebase.js\n\npath与文件名的映射关系必须按照上面的要求，否则无法mock。\n\n##### 2. 开启mock\n\n比如我们有这样的一个请求：\n\n```js\ngetData: function(req, tools, params) {\n    var options = {\n        data: params || {},\n        path: '/huodong/gamebase',\n        reqType: 'promise'\n    };\n    return tools.commonBusiness.pierce(req, 'SHOPUI', options);\n}\n```\nmock文件夹下面建立一个 `huodong-gamebase.js`,在请求的参数里面增加 `enableMock: true`开启mock\n\n```js\ngetData: function(req, tools, params) {\n    var options = {\n        data: params || {},\n        path: '/huodong/gamebase',\n        reqType: 'promise',\n        enableMock: true,//开启Mock\n    };\n    return tools.commonBusiness.pierce(req, 'SHOPUI', options);\n}\n```\n这样就完成了nodeui向php请求的数据mock\n\n## 测试链接\n\n- ral请求mock: http://127.0.0.1:8197/fly/h5/demo\n- 普通请求mock(rewrite): http://127.0.0.1:8197/api/user\n- 动态数据mock(rewrite): http://127.0.0.1:8197/api/dynamic/time\n- api proxy mock: http://127.0.0.1:8197/wmall/privilege/center\n- 重定向(redirect): http://127.0.0.1:8197/api/redirect\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/basics/mock.html","comments":1,"layout":"page","_id":"cjyd4ski8000f6lq1l5f03o8p","content":"<p>数据mock主要分为前端接口的mock（client request）及向后请求的数据mock(server request)。</p>\n<p>其中，前端接口mock表现为 ajax请求。向后请求Mock主要是指nodeui向后请求php接口的mock，这种数据一般用来渲染到模板或者直接接口输出。</p>\n<p>所有的mock均支持热重启，即修改代码不需要重启nodeui，立即生效。</p>\n<h3 id=\"目录规范\"><a class=\"markdown-anchor\" href=\"#目录规范\">#</a> 目录规范</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mock</span><br><span class=\"line\">  ├─ server.conf // 配置中心  </span><br><span class=\"line\">  ├─ common   // 公共接口目录</span><br><span class=\"line\">  │  ├─ dynamic.js  // 动态数据</span><br><span class=\"line\">  │  ├─ sample.json  // 静态json数据</span><br><span class=\"line\">  ├─ ral // nodeui向php请求接口模拟</span><br><span class=\"line\">  │  ├─ hongbao-getmobilebyopenid.js // 微信授权根据openid获取用户信息接口  </span><br><span class=\"line\">  │  ├─ hongbao-updatemobilebyopenid.js // 更新用户信息接口  </span><br><span class=\"line\">  │  ├─ huodong-2016usergrowstoryindex.js // 业务php接口模拟  </span><br><span class=\"line\">  ├─ dumall // 业务接口</span><br><span class=\"line\">  │  ├─ center.js // 小度商城个人中心</span><br><span class=\"line\">  │  ├─ del.json // 删除卡片接口</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"前端接口的使用\"><a class=\"markdown-anchor\" href=\"#前端接口的使用\">#</a> 前端接口的使用</h3>\n<p>前端接口的mock主要在<code>server.conf</code>里面进行配置</p>\n<h4 id=\"serverconf-配置语法\"><a class=\"markdown-anchor\" href=\"#serverconf-配置语法\">#</a> server.conf 配置语法</h4>\n<pre><code>指令名称 正则规则 目标文件\n</code></pre>\n<ul>\n<li><code>指令名称</code> 支持 rewrite 、 redirect 和 proxy。</li>\n<li><code>正则规则</code> 用来命中需要作假的请求路径</li>\n<li><code>目标文件</code> 设置转发的目标地址，需要配置一个可请求的 url 地址。</li>\n</ul>\n<h4 id=\"mock-静态假数据\"><a class=\"markdown-anchor\" href=\"#mock-静态假数据\">#</a> mock 静态假数据</h4>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rewrite ^\\/api\\/user$ /mock/sample.json</span><br><span class=\"line\"></span><br><span class=\"line\">// sample.json内容</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;error&quot;: 0,</span><br><span class=\"line\">    &quot;message&quot;: &quot;ok&quot;,</span><br><span class=\"line\">    &quot;data&quot;: &#123;</span><br><span class=\"line\">        &quot;username&quot;: &quot;younth&quot;,</span><br><span class=\"line\">        &quot;uid&quot;: 1,</span><br><span class=\"line\">        &quot;age&quot;: 25,</span><br><span class=\"line\">        &quot;company&quot;: &quot;waimai&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"mock-动态假数据\"><a class=\"markdown-anchor\" href=\"#mock-动态假数据\">#</a> mock 动态假数据</h4>\n<blockquote>\n<p>node 服务器可以通过 js 的方式提供动态假数据。，动态数据本质是 express 的 route.</p>\n</blockquote>\n<p><code>rewrite ^\\/api\\/dynamic\\/time$ /mock/dynamic.js</code></p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dynamic.js内容</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  res.write(<span class=\"string\">'Hello world '</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// set custom header.</span></span><br><span class=\"line\">  <span class=\"comment\">// res.setHeader('xxxx', 'xxx');</span></span><br><span class=\"line\"></span><br><span class=\"line\">  res.end(<span class=\"string\">'The time is '</span> + <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更复杂的，可以直接引用其他模块，发送请求</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过nodejs来抓取线上的结果。这样就完成了动态获取线上数据的功能</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, response, next</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = request.method;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"proxy-到其他服务的-api-地址\"><a class=\"markdown-anchor\" href=\"#proxy-到其他服务的-api-地址\">#</a> proxy 到其他服务的 api 地址</h4>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 支持正则分组</span><br><span class=\"line\">proxy ^\\/wmall\\/privilege\\/(.*)$  http://10.19.161.92:8059/wmall/privilege/<span class=\"variable\">$1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ral-请求的mock\"><a class=\"markdown-anchor\" href=\"#ral-请求的mock\">#</a> ral 请求的mock</h3>\n<p>主要是Node向下游服务(PHP)请求的数据mock，基于ral请求的数据模拟。</p>\n<h4 id=\"如何使用\"><a class=\"markdown-anchor\" href=\"#如何使用\">#</a> 如何使用</h4>\n<h5 id=\"1-根据path-建立mock文件\"><a class=\"markdown-anchor\" href=\"#1-根据path-建立mock文件\">#</a> 1. 根据path 建立mock文件</h5>\n<p>文件命名规则是 <em>请求的path用-符号连接</em></p>\n<pre><code>/huodong/gamebase -&gt;  huodong-gamebase.js\n</code></pre>\n<p>path与文件名的映射关系必须按照上面的要求，否则无法mock。</p>\n<h5 id=\"2-开启mock\"><a class=\"markdown-anchor\" href=\"#2-开启mock\">#</a> 2. 开启mock</h5>\n<p>比如我们有这样的一个请求：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, tools, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">        data: params || &#123;&#125;,</span><br><span class=\"line\">        path: <span class=\"string\">'/huodong/gamebase'</span>,</span><br><span class=\"line\">        reqType: <span class=\"string\">'promise'</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tools.commonBusiness.pierce(req, <span class=\"string\">'SHOPUI'</span>, options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mock文件夹下面建立一个 <code>huodong-gamebase.js</code>,在请求的参数里面增加 <code>enableMock: true</code>开启mock</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, tools, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">        data: params || &#123;&#125;,</span><br><span class=\"line\">        path: <span class=\"string\">'/huodong/gamebase'</span>,</span><br><span class=\"line\">        reqType: <span class=\"string\">'promise'</span>,</span><br><span class=\"line\">        enableMock: <span class=\"literal\">true</span>,<span class=\"comment\">//开启Mock</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tools.commonBusiness.pierce(req, <span class=\"string\">'SHOPUI'</span>, options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样就完成了nodeui向php请求的数据mock</p>\n<h2 id=\"测试链接\"><a class=\"markdown-anchor\" href=\"#测试链接\">#</a> 测试链接</h2>\n<ul>\n<li>ral请求mock: http://127.0.0.1:8197/fly/h5/demo</li>\n<li>普通请求mock(rewrite): http://127.0.0.1:8197/api/user</li>\n<li>动态数据mock(rewrite): http://127.0.0.1:8197/api/dynamic/time</li>\n<li>api proxy mock: http://127.0.0.1:8197/wmall/privilege/center</li>\n<li>重定向(redirect): http://127.0.0.1:8197/api/redirect</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>数据mock主要分为前端接口的mock（client request）及向后请求的数据mock(server request)。</p>\n<p>其中，前端接口mock表现为 ajax请求。向后请求Mock主要是指nodeui向后请求php接口的mock，这种数据一般用来渲染到模板或者直接接口输出。</p>\n<p>所有的mock均支持热重启，即修改代码不需要重启nodeui，立即生效。</p>\n<h3 id=\"目录规范\"><a class=\"markdown-anchor\" href=\"#目录规范\">#</a> 目录规范</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mock</span><br><span class=\"line\">  ├─ server.conf // 配置中心  </span><br><span class=\"line\">  ├─ common   // 公共接口目录</span><br><span class=\"line\">  │  ├─ dynamic.js  // 动态数据</span><br><span class=\"line\">  │  ├─ sample.json  // 静态json数据</span><br><span class=\"line\">  ├─ ral // nodeui向php请求接口模拟</span><br><span class=\"line\">  │  ├─ hongbao-getmobilebyopenid.js // 微信授权根据openid获取用户信息接口  </span><br><span class=\"line\">  │  ├─ hongbao-updatemobilebyopenid.js // 更新用户信息接口  </span><br><span class=\"line\">  │  ├─ huodong-2016usergrowstoryindex.js // 业务php接口模拟  </span><br><span class=\"line\">  ├─ dumall // 业务接口</span><br><span class=\"line\">  │  ├─ center.js // 小度商城个人中心</span><br><span class=\"line\">  │  ├─ del.json // 删除卡片接口</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"前端接口的使用\"><a class=\"markdown-anchor\" href=\"#前端接口的使用\">#</a> 前端接口的使用</h3>\n<p>前端接口的mock主要在<code>server.conf</code>里面进行配置</p>\n<h4 id=\"serverconf-配置语法\"><a class=\"markdown-anchor\" href=\"#serverconf-配置语法\">#</a> server.conf 配置语法</h4>\n<pre><code>指令名称 正则规则 目标文件\n</code></pre>\n<ul>\n<li><code>指令名称</code> 支持 rewrite 、 redirect 和 proxy。</li>\n<li><code>正则规则</code> 用来命中需要作假的请求路径</li>\n<li><code>目标文件</code> 设置转发的目标地址，需要配置一个可请求的 url 地址。</li>\n</ul>\n<h4 id=\"mock-静态假数据\"><a class=\"markdown-anchor\" href=\"#mock-静态假数据\">#</a> mock 静态假数据</h4>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rewrite ^\\/api\\/user$ /mock/sample.json</span><br><span class=\"line\"></span><br><span class=\"line\">// sample.json内容</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;error&quot;: 0,</span><br><span class=\"line\">    &quot;message&quot;: &quot;ok&quot;,</span><br><span class=\"line\">    &quot;data&quot;: &#123;</span><br><span class=\"line\">        &quot;username&quot;: &quot;younth&quot;,</span><br><span class=\"line\">        &quot;uid&quot;: 1,</span><br><span class=\"line\">        &quot;age&quot;: 25,</span><br><span class=\"line\">        &quot;company&quot;: &quot;waimai&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"mock-动态假数据\"><a class=\"markdown-anchor\" href=\"#mock-动态假数据\">#</a> mock 动态假数据</h4>\n<blockquote>\n<p>node 服务器可以通过 js 的方式提供动态假数据。，动态数据本质是 express 的 route.</p>\n</blockquote>\n<p><code>rewrite ^\\/api\\/dynamic\\/time$ /mock/dynamic.js</code></p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dynamic.js内容</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  res.write(<span class=\"string\">'Hello world '</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// set custom header.</span></span><br><span class=\"line\">  <span class=\"comment\">// res.setHeader('xxxx', 'xxx');</span></span><br><span class=\"line\"></span><br><span class=\"line\">  res.end(<span class=\"string\">'The time is '</span> + <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更复杂的，可以直接引用其他模块，发送请求</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过nodejs来抓取线上的结果。这样就完成了动态获取线上数据的功能</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, response, next</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = request.method;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"proxy-到其他服务的-api-地址\"><a class=\"markdown-anchor\" href=\"#proxy-到其他服务的-api-地址\">#</a> proxy 到其他服务的 api 地址</h4>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 支持正则分组</span><br><span class=\"line\">proxy ^\\/wmall\\/privilege\\/(.*)$  http://10.19.161.92:8059/wmall/privilege/<span class=\"variable\">$1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ral-请求的mock\"><a class=\"markdown-anchor\" href=\"#ral-请求的mock\">#</a> ral 请求的mock</h3>\n<p>主要是Node向下游服务(PHP)请求的数据mock，基于ral请求的数据模拟。</p>\n<h4 id=\"如何使用\"><a class=\"markdown-anchor\" href=\"#如何使用\">#</a> 如何使用</h4>\n<h5 id=\"1-根据path-建立mock文件\"><a class=\"markdown-anchor\" href=\"#1-根据path-建立mock文件\">#</a> 1. 根据path 建立mock文件</h5>\n<p>文件命名规则是 <em>请求的path用-符号连接</em></p>\n<pre><code>/huodong/gamebase -&gt;  huodong-gamebase.js\n</code></pre>\n<p>path与文件名的映射关系必须按照上面的要求，否则无法mock。</p>\n<h5 id=\"2-开启mock\"><a class=\"markdown-anchor\" href=\"#2-开启mock\">#</a> 2. 开启mock</h5>\n<p>比如我们有这样的一个请求：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, tools, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">        data: params || &#123;&#125;,</span><br><span class=\"line\">        path: <span class=\"string\">'/huodong/gamebase'</span>,</span><br><span class=\"line\">        reqType: <span class=\"string\">'promise'</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tools.commonBusiness.pierce(req, <span class=\"string\">'SHOPUI'</span>, options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mock文件夹下面建立一个 <code>huodong-gamebase.js</code>,在请求的参数里面增加 <code>enableMock: true</code>开启mock</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, tools, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">        data: params || &#123;&#125;,</span><br><span class=\"line\">        path: <span class=\"string\">'/huodong/gamebase'</span>,</span><br><span class=\"line\">        reqType: <span class=\"string\">'promise'</span>,</span><br><span class=\"line\">        enableMock: <span class=\"literal\">true</span>,<span class=\"comment\">//开启Mock</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tools.commonBusiness.pierce(req, <span class=\"string\">'SHOPUI'</span>, options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样就完成了nodeui向php请求的数据mock</p>\n<h2 id=\"测试链接\"><a class=\"markdown-anchor\" href=\"#测试链接\">#</a> 测试链接</h2>\n<ul>\n<li>ral请求mock: http://127.0.0.1:8197/fly/h5/demo</li>\n<li>普通请求mock(rewrite): http://127.0.0.1:8197/api/user</li>\n<li>动态数据mock(rewrite): http://127.0.0.1:8197/api/dynamic/time</li>\n<li>api proxy mock: http://127.0.0.1:8197/wmall/privilege/center</li>\n<li>重定向(redirect): http://127.0.0.1:8197/api/redirect</li>\n</ul>\n"},{"title":"应用上线和路由","_content":"\n在任务管理页面可以点击上线可以一键上线任务到yarn上,上线成功后可以直接在webui查看任务无需登录到yarn上面\n\n\n### 注意\n\nspark execur在8042上面的节点无法进行代理,需手动\n\n## todo\n\n需要升级\n","source":"en/docs/basics/online.md","raw":"title: 应用上线和路由\n---\n\n在任务管理页面可以点击上线可以一键上线任务到yarn上,上线成功后可以直接在webui查看任务无需登录到yarn上面\n\n\n### 注意\n\nspark execur在8042上面的节点无法进行代理,需手动\n\n## todo\n\n需要升级\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/basics/online.html","comments":1,"layout":"page","_id":"cjyd4skia000g6lq1jgefxcat","content":"<p>在任务管理页面可以点击上线可以一键上线任务到yarn上,上线成功后可以直接在webui查看任务无需登录到yarn上面</p>\n<h3 id=\"注意\"><a class=\"markdown-anchor\" href=\"#注意\">#</a> 注意</h3>\n<p>spark execur在8042上面的节点无法进行代理,需手动</p>\n<h2 id=\"todo\"><a class=\"markdown-anchor\" href=\"#todo\">#</a> todo</h2>\n<p>需要升级</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>在任务管理页面可以点击上线可以一键上线任务到yarn上,上线成功后可以直接在webui查看任务无需登录到yarn上面</p>\n<h3 id=\"注意\"><a class=\"markdown-anchor\" href=\"#注意\">#</a> 注意</h3>\n<p>spark execur在8042上面的节点无法进行代理,需手动</p>\n<h2 id=\"todo\"><a class=\"markdown-anchor\" href=\"#todo\">#</a> todo</h2>\n<p>需要升级</p>\n"},{"title":"REST Service","_content":"\nSYLPH 中，使用restful风格接口:\n\n- 后端服务配置统一管理\n- 封装异常处理、超时重试，提升系统稳定性\n- 封装日志，便于线上问题追查\n- 抽象请求协议、数据格式与数据编码，统一接口\n\n## 主要特征\n\n- compile\n- proxy\n\n## 使用 Service\n\n接口在`sylph-controller`模块中管理,主要分布在`ideal.sylph.controller.action`包下:\n\n```java\n    @javax.inject.Singleton\n    @Path(\"/stream_sql\")\n    public class StreamSqlResource\n    {\n    ...\n        \n        @POST\n        @Path(\"save\")\n        @Consumes({MediaType.MULTIPART_FORM_DATA, MediaType.APPLICATION_JSON})\n        @Produces({MediaType.APPLICATION_JSON})\n        public Map saveJob(@Context HttpServletRequest request){\n            ...\n        }\n```\n\n\n","source":"en/docs/basics/service.md","raw":"title: REST Service\n---\n\nSYLPH 中，使用restful风格接口:\n\n- 后端服务配置统一管理\n- 封装异常处理、超时重试，提升系统稳定性\n- 封装日志，便于线上问题追查\n- 抽象请求协议、数据格式与数据编码，统一接口\n\n## 主要特征\n\n- compile\n- proxy\n\n## 使用 Service\n\n接口在`sylph-controller`模块中管理,主要分布在`ideal.sylph.controller.action`包下:\n\n```java\n    @javax.inject.Singleton\n    @Path(\"/stream_sql\")\n    public class StreamSqlResource\n    {\n    ...\n        \n        @POST\n        @Path(\"save\")\n        @Consumes({MediaType.MULTIPART_FORM_DATA, MediaType.APPLICATION_JSON})\n        @Produces({MediaType.APPLICATION_JSON})\n        public Map saveJob(@Context HttpServletRequest request){\n            ...\n        }\n```\n\n\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/basics/service.html","comments":1,"layout":"page","_id":"cjyd4skic000h6lq1t40f1sk0","content":"<p>SYLPH 中，使用restful风格接口:</p>\n<ul>\n<li>后端服务配置统一管理</li>\n<li>封装异常处理、超时重试，提升系统稳定性</li>\n<li>封装日志，便于线上问题追查</li>\n<li>抽象请求协议、数据格式与数据编码，统一接口</li>\n</ul>\n<h2 id=\"主要特征\"><a class=\"markdown-anchor\" href=\"#主要特征\">#</a> 主要特征</h2>\n<ul>\n<li>compile</li>\n<li>proxy</li>\n</ul>\n<h2 id=\"使用-service\"><a class=\"markdown-anchor\" href=\"#使用-service\">#</a> 使用 Service</h2>\n<p>接口在<code>sylph-controller</code>模块中管理,主要分布在<code>ideal.sylph.controller.action</code>包下:</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@javax</span>.inject.Singleton</span><br><span class=\"line\"><span class=\"meta\">@Path</span>(<span class=\"string\">\"/stream_sql\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamSqlResource</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@POST</span></span><br><span class=\"line\">    <span class=\"meta\">@Path</span>(<span class=\"string\">\"save\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Consumes</span>(&#123;MediaType.MULTIPART_FORM_DATA, MediaType.APPLICATION_JSON&#125;)</span><br><span class=\"line\">    <span class=\"meta\">@Produces</span>(&#123;MediaType.APPLICATION_JSON&#125;)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">saveJob</span><span class=\"params\">(@Context HttpServletRequest request)</span></span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>SYLPH 中，使用restful风格接口:</p>\n<ul>\n<li>后端服务配置统一管理</li>\n<li>封装异常处理、超时重试，提升系统稳定性</li>\n<li>封装日志，便于线上问题追查</li>\n<li>抽象请求协议、数据格式与数据编码，统一接口</li>\n</ul>\n<h2 id=\"主要特征\"><a class=\"markdown-anchor\" href=\"#主要特征\">#</a> 主要特征</h2>\n<ul>\n<li>compile</li>\n<li>proxy</li>\n</ul>\n<h2 id=\"使用-service\"><a class=\"markdown-anchor\" href=\"#使用-service\">#</a> 使用 Service</h2>\n<p>接口在<code>sylph-controller</code>模块中管理,主要分布在<code>ideal.sylph.controller.action</code>包下:</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@javax</span>.inject.Singleton</span><br><span class=\"line\"><span class=\"meta\">@Path</span>(<span class=\"string\">\"/stream_sql\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamSqlResource</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@POST</span></span><br><span class=\"line\">    <span class=\"meta\">@Path</span>(<span class=\"string\">\"save\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Consumes</span>(&#123;MediaType.MULTIPART_FORM_DATA, MediaType.APPLICATION_JSON&#125;)</span><br><span class=\"line\">    <span class=\"meta\">@Produces</span>(&#123;MediaType.APPLICATION_JSON&#125;)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">saveJob</span><span class=\"params\">(@Context HttpServletRequest request)</span></span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Sylph安装","_content":"\n### 下载源码\nhttps://github.com/harbby/sylph/releases/\n\n### 编译\n**编译sylph需要使用Gradle并需要Java 8.请确保您的JAVA_HOME环境为java8**\n\n编译\n```bash\n./gradlew clean assemble install\n```","source":"en/docs/basics/setup.md","raw":"title: Sylph安装\n---\n\n### 下载源码\nhttps://github.com/harbby/sylph/releases/\n\n### 编译\n**编译sylph需要使用Gradle并需要Java 8.请确保您的JAVA_HOME环境为java8**\n\n编译\n```bash\n./gradlew clean assemble install\n```","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/basics/setup.html","comments":1,"layout":"page","_id":"cjyd4skie000i6lq1gk0k89ff","content":"<h3 id=\"下载源码\"><a class=\"markdown-anchor\" href=\"#下载源码\">#</a> 下载源码</h3>\n<p>https://github.com/harbby/sylph/releases/</p>\n<h3 id=\"编译\"><a class=\"markdown-anchor\" href=\"#编译\">#</a> 编译</h3>\n<p><strong>编译sylph需要使用Gradle并需要Java 8.请确保您的JAVA_HOME环境为java8</strong></p>\n<p>编译\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./gradlew clean assemble install</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<h3 id=\"下载源码\"><a class=\"markdown-anchor\" href=\"#下载源码\">#</a> 下载源码</h3>\n<p>https://github.com/harbby/sylph/releases/</p>\n<h3 id=\"编译\"><a class=\"markdown-anchor\" href=\"#编译\">#</a> 编译</h3>\n<p><strong>编译sylph需要使用Gradle并需要Java 8.请确保您的JAVA_HOME环境为java8</strong></p>\n<p>编译\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./gradlew clean assemble install</span><br></pre></td></tr></table></figure></p>\n"},{"title":"目录结构","_content":"\n在[快速入门](../intro/quickstart.md)中，对sylph有了初步的印象，接下来我们简单了解下安装目录约定规范。\n\n### 1. 框架目录结构\n![framework]\n\n### 2. 业务模块结构\n![business]\n\n[framework]: ../../../images/logo.png\n[business]: ../../../images/logo.png\n\n```bash\nsylph-bin-${version}\n├── bin (启动脚本)\n├── etc \n│   └── sylph (配置)\n├── etl-plugins (pipeline插件,如下有两个插件包)\n│   ├── flink-node-plugin\n│   └── spark-node-plugin\n├── jobs (job保存目录)\n│   ├── a2\n│   ├── spark_test1\n│   └── sql_test1\n├── lib (核心依赖)\n├── logs\n├── modules (执行器 如有flink,spark执行器)\n│   ├── sylph-runner-flink\n│   │   └── lib\n│   └── sylph-runner-spark\n│       └── lib\n└── webapps (webUI)\n    ├── css\n    ├── fonts\n    ├── img\n    ├── js\n    ├── ...\n```\n\n如上，整个sylph的安装目录：\n","source":"en/docs/basics/structure.md","raw":"title: 目录结构\n---\n\n在[快速入门](../intro/quickstart.md)中，对sylph有了初步的印象，接下来我们简单了解下安装目录约定规范。\n\n### 1. 框架目录结构\n![framework]\n\n### 2. 业务模块结构\n![business]\n\n[framework]: ../../../images/logo.png\n[business]: ../../../images/logo.png\n\n```bash\nsylph-bin-${version}\n├── bin (启动脚本)\n├── etc \n│   └── sylph (配置)\n├── etl-plugins (pipeline插件,如下有两个插件包)\n│   ├── flink-node-plugin\n│   └── spark-node-plugin\n├── jobs (job保存目录)\n│   ├── a2\n│   ├── spark_test1\n│   └── sql_test1\n├── lib (核心依赖)\n├── logs\n├── modules (执行器 如有flink,spark执行器)\n│   ├── sylph-runner-flink\n│   │   └── lib\n│   └── sylph-runner-spark\n│       └── lib\n└── webapps (webUI)\n    ├── css\n    ├── fonts\n    ├── img\n    ├── js\n    ├── ...\n```\n\n如上，整个sylph的安装目录：\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/basics/structure.html","comments":1,"layout":"page","_id":"cjyd4skif000j6lq1djdhf0uy","content":"<p>在<a href=\"../intro/quickstart.html\">快速入门</a>中，对sylph有了初步的印象，接下来我们简单了解下安装目录约定规范。</p>\n<h3 id=\"1-框架目录结构\"><a class=\"markdown-anchor\" href=\"#1-框架目录结构\">#</a> 1. 框架目录结构</h3>\n<p><img src=\"../../../images/logo.png\" alt=\"framework\"></p>\n<h3 id=\"2-业务模块结构\"><a class=\"markdown-anchor\" href=\"#2-业务模块结构\">#</a> 2. 业务模块结构</h3>\n<p><img src=\"../../../images/logo.png\" alt=\"business\"></p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sylph-bin-<span class=\"variable\">$&#123;version&#125;</span></span><br><span class=\"line\">├── bin (启动脚本)</span><br><span class=\"line\">├── etc </span><br><span class=\"line\">│   └── sylph (配置)</span><br><span class=\"line\">├── etl-plugins (pipeline插件,如下有两个插件包)</span><br><span class=\"line\">│   ├── flink-node-plugin</span><br><span class=\"line\">│   └── spark-node-plugin</span><br><span class=\"line\">├── <span class=\"built_in\">jobs</span> (job保存目录)</span><br><span class=\"line\">│   ├── a2</span><br><span class=\"line\">│   ├── spark_test1</span><br><span class=\"line\">│   └── sql_test1</span><br><span class=\"line\">├── lib (核心依赖)</span><br><span class=\"line\">├── logs</span><br><span class=\"line\">├── modules (执行器 如有flink,spark执行器)</span><br><span class=\"line\">│   ├── sylph-runner-flink</span><br><span class=\"line\">│   │   └── lib</span><br><span class=\"line\">│   └── sylph-runner-spark</span><br><span class=\"line\">│       └── lib</span><br><span class=\"line\">└── webapps (webUI)</span><br><span class=\"line\">    ├── css</span><br><span class=\"line\">    ├── fonts</span><br><span class=\"line\">    ├── img</span><br><span class=\"line\">    ├── js</span><br><span class=\"line\">    ├── ...</span><br></pre></td></tr></table></figure></p>\n<p>如上，整个sylph的安装目录：</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>在<a href=\"../intro/quickstart.html\">快速入门</a>中，对sylph有了初步的印象，接下来我们简单了解下安装目录约定规范。</p>\n<h3 id=\"1-框架目录结构\"><a class=\"markdown-anchor\" href=\"#1-框架目录结构\">#</a> 1. 框架目录结构</h3>\n<p><img src=\"../../../images/logo.png\" alt=\"framework\"></p>\n<h3 id=\"2-业务模块结构\"><a class=\"markdown-anchor\" href=\"#2-业务模块结构\">#</a> 2. 业务模块结构</h3>\n<p><img src=\"../../../images/logo.png\" alt=\"business\"></p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sylph-bin-<span class=\"variable\">$&#123;version&#125;</span></span><br><span class=\"line\">├── bin (启动脚本)</span><br><span class=\"line\">├── etc </span><br><span class=\"line\">│   └── sylph (配置)</span><br><span class=\"line\">├── etl-plugins (pipeline插件,如下有两个插件包)</span><br><span class=\"line\">│   ├── flink-node-plugin</span><br><span class=\"line\">│   └── spark-node-plugin</span><br><span class=\"line\">├── <span class=\"built_in\">jobs</span> (job保存目录)</span><br><span class=\"line\">│   ├── a2</span><br><span class=\"line\">│   ├── spark_test1</span><br><span class=\"line\">│   └── sql_test1</span><br><span class=\"line\">├── lib (核心依赖)</span><br><span class=\"line\">├── logs</span><br><span class=\"line\">├── modules (执行器 如有flink,spark执行器)</span><br><span class=\"line\">│   ├── sylph-runner-flink</span><br><span class=\"line\">│   │   └── lib</span><br><span class=\"line\">│   └── sylph-runner-spark</span><br><span class=\"line\">│       └── lib</span><br><span class=\"line\">└── webapps (webUI)</span><br><span class=\"line\">    ├── css</span><br><span class=\"line\">    ├── fonts</span><br><span class=\"line\">    ├── img</span><br><span class=\"line\">    ├── js</span><br><span class=\"line\">    ├── ...</span><br></pre></td></tr></table></figure></p>\n<p>如上，整个sylph的安装目录：</p>\n"},{"title":"NodeUI与PHP服务通信负载均衡策略","_content":"\n### 1. roundrobin\n\n```\nRoundRobinBalance.prototype.fetchServer = function (balanceContext) {\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    balanceContext.lastRoundRobinID = balanceContext.lastRoundRobinID || 0;\n    balanceContext.lastRoundRobinID++;\n    if (balanceContext.lastRoundRobinID < 0 || balanceContext.lastRoundRobinID >= servers.length) {\n        balanceContext.lastRoundRobinID = 0;\n    }\n    logger.trace(\n        ['RoundRobinBalance fetchServer RoundRobinID=', balanceContext.lastRoundRobinID, ' ServiceID=',\n            balanceContext.serviceID\n        ].join('')\n    );\n    return servers[balanceContext.lastRoundRobinID];\n};\n```\n\n### 2. random\n\n\n```\nRandomBalance.prototype.fetchServer = function (balanceContext) {\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    // Math.random takes 250ms on first call\n    var index = Math.floor(Math.random() * servers.length);\n    logger.trace('RandomBalance fetchServer index=' + index + ' ServiceID=' + balanceContext.serviceID);\n    // TODO add server filter\n    return servers[index];\n};\n\n```\n\n### 3. hashring\n\n```\nHashringBalance.prototype.fetchServer = function (balanceContext, conf, prevBackend) {\n    if (conf.balanceKey === undefined || conf.balanceKey === null) {\n        throw new Error('balanceKey is needed when using consistent hashing');\n    }\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    if (!balanceContext.hashring) {\n        balanceContext.hashring = this.createHashring(balanceContext.reqIDCServers);\n    }\n    var ringIndex = bs(balanceContext.hashring, {\n        index: null,\n        value: this.generateHash(conf.balanceKey)\n    }, function (a, b) {\n        return a.value - b.value;\n    });\n    if (ringIndex < 0) {\n        ringIndex = -ringIndex - 1;\n    }\n    ringIndex = Math.min(ringIndex, balanceContext.hashring.length - 1);\n    var index = balanceContext.hashring[ringIndex].index;\n    logger.trace('RandomBalance fetchServer index=' + index + ' ServiceID=' + balanceContext.serviceID);\n    return servers[index];\n};\n\n```\n","source":"en/docs/core/fetch-server.md","raw":"title: NodeUI与PHP服务通信负载均衡策略\n---\n\n### 1. roundrobin\n\n```\nRoundRobinBalance.prototype.fetchServer = function (balanceContext) {\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    balanceContext.lastRoundRobinID = balanceContext.lastRoundRobinID || 0;\n    balanceContext.lastRoundRobinID++;\n    if (balanceContext.lastRoundRobinID < 0 || balanceContext.lastRoundRobinID >= servers.length) {\n        balanceContext.lastRoundRobinID = 0;\n    }\n    logger.trace(\n        ['RoundRobinBalance fetchServer RoundRobinID=', balanceContext.lastRoundRobinID, ' ServiceID=',\n            balanceContext.serviceID\n        ].join('')\n    );\n    return servers[balanceContext.lastRoundRobinID];\n};\n```\n\n### 2. random\n\n\n```\nRandomBalance.prototype.fetchServer = function (balanceContext) {\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    // Math.random takes 250ms on first call\n    var index = Math.floor(Math.random() * servers.length);\n    logger.trace('RandomBalance fetchServer index=' + index + ' ServiceID=' + balanceContext.serviceID);\n    // TODO add server filter\n    return servers[index];\n};\n\n```\n\n### 3. hashring\n\n```\nHashringBalance.prototype.fetchServer = function (balanceContext, conf, prevBackend) {\n    if (conf.balanceKey === undefined || conf.balanceKey === null) {\n        throw new Error('balanceKey is needed when using consistent hashing');\n    }\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    if (!balanceContext.hashring) {\n        balanceContext.hashring = this.createHashring(balanceContext.reqIDCServers);\n    }\n    var ringIndex = bs(balanceContext.hashring, {\n        index: null,\n        value: this.generateHash(conf.balanceKey)\n    }, function (a, b) {\n        return a.value - b.value;\n    });\n    if (ringIndex < 0) {\n        ringIndex = -ringIndex - 1;\n    }\n    ringIndex = Math.min(ringIndex, balanceContext.hashring.length - 1);\n    var index = balanceContext.hashring[ringIndex].index;\n    logger.trace('RandomBalance fetchServer index=' + index + ' ServiceID=' + balanceContext.serviceID);\n    return servers[index];\n};\n\n```\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/core/fetch-server.html","comments":1,"layout":"page","_id":"cjyd4skih000k6lq16vr9be11","content":"<h3 id=\"1-roundrobin\"><a class=\"markdown-anchor\" href=\"#1-roundrobin\">#</a> 1. roundrobin</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">RoundRobinBalance.prototype.fetchServer = function (balanceContext) &#123;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    balanceContext.lastRoundRobinID = balanceContext.lastRoundRobinID || 0;</span><br><span class=\"line\">    balanceContext.lastRoundRobinID++;</span><br><span class=\"line\">    if (balanceContext.lastRoundRobinID &lt; 0 || balanceContext.lastRoundRobinID &gt;= servers.length) &#123;</span><br><span class=\"line\">        balanceContext.lastRoundRobinID = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.trace(</span><br><span class=\"line\">        [&apos;RoundRobinBalance fetchServer RoundRobinID=&apos;, balanceContext.lastRoundRobinID, &apos; ServiceID=&apos;,</span><br><span class=\"line\">            balanceContext.serviceID</span><br><span class=\"line\">        ].join(&apos;&apos;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    return servers[balanceContext.lastRoundRobinID];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-random\"><a class=\"markdown-anchor\" href=\"#2-random\">#</a> 2. random</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">RandomBalance.prototype.fetchServer = function (balanceContext) &#123;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // Math.random takes 250ms on first call</span><br><span class=\"line\">    var index = Math.floor(Math.random() * servers.length);</span><br><span class=\"line\">    logger.trace(&apos;RandomBalance fetchServer index=&apos; + index + &apos; ServiceID=&apos; + balanceContext.serviceID);</span><br><span class=\"line\">    // TODO add server filter</span><br><span class=\"line\">    return servers[index];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-hashring\"><a class=\"markdown-anchor\" href=\"#3-hashring\">#</a> 3. hashring</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HashringBalance.prototype.fetchServer = function (balanceContext, conf, prevBackend) &#123;</span><br><span class=\"line\">    if (conf.balanceKey === undefined || conf.balanceKey === null) &#123;</span><br><span class=\"line\">        throw new Error(&apos;balanceKey is needed when using consistent hashing&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!balanceContext.hashring) &#123;</span><br><span class=\"line\">        balanceContext.hashring = this.createHashring(balanceContext.reqIDCServers);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var ringIndex = bs(balanceContext.hashring, &#123;</span><br><span class=\"line\">        index: null,</span><br><span class=\"line\">        value: this.generateHash(conf.balanceKey)</span><br><span class=\"line\">    &#125;, function (a, b) &#123;</span><br><span class=\"line\">        return a.value - b.value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    if (ringIndex &lt; 0) &#123;</span><br><span class=\"line\">        ringIndex = -ringIndex - 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ringIndex = Math.min(ringIndex, balanceContext.hashring.length - 1);</span><br><span class=\"line\">    var index = balanceContext.hashring[ringIndex].index;</span><br><span class=\"line\">    logger.trace(&apos;RandomBalance fetchServer index=&apos; + index + &apos; ServiceID=&apos; + balanceContext.serviceID);</span><br><span class=\"line\">    return servers[index];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<h3 id=\"1-roundrobin\"><a class=\"markdown-anchor\" href=\"#1-roundrobin\">#</a> 1. roundrobin</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">RoundRobinBalance.prototype.fetchServer = function (balanceContext) &#123;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    balanceContext.lastRoundRobinID = balanceContext.lastRoundRobinID || 0;</span><br><span class=\"line\">    balanceContext.lastRoundRobinID++;</span><br><span class=\"line\">    if (balanceContext.lastRoundRobinID &lt; 0 || balanceContext.lastRoundRobinID &gt;= servers.length) &#123;</span><br><span class=\"line\">        balanceContext.lastRoundRobinID = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.trace(</span><br><span class=\"line\">        [&apos;RoundRobinBalance fetchServer RoundRobinID=&apos;, balanceContext.lastRoundRobinID, &apos; ServiceID=&apos;,</span><br><span class=\"line\">            balanceContext.serviceID</span><br><span class=\"line\">        ].join(&apos;&apos;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    return servers[balanceContext.lastRoundRobinID];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-random\"><a class=\"markdown-anchor\" href=\"#2-random\">#</a> 2. random</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">RandomBalance.prototype.fetchServer = function (balanceContext) &#123;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // Math.random takes 250ms on first call</span><br><span class=\"line\">    var index = Math.floor(Math.random() * servers.length);</span><br><span class=\"line\">    logger.trace(&apos;RandomBalance fetchServer index=&apos; + index + &apos; ServiceID=&apos; + balanceContext.serviceID);</span><br><span class=\"line\">    // TODO add server filter</span><br><span class=\"line\">    return servers[index];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-hashring\"><a class=\"markdown-anchor\" href=\"#3-hashring\">#</a> 3. hashring</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HashringBalance.prototype.fetchServer = function (balanceContext, conf, prevBackend) &#123;</span><br><span class=\"line\">    if (conf.balanceKey === undefined || conf.balanceKey === null) &#123;</span><br><span class=\"line\">        throw new Error(&apos;balanceKey is needed when using consistent hashing&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!balanceContext.hashring) &#123;</span><br><span class=\"line\">        balanceContext.hashring = this.createHashring(balanceContext.reqIDCServers);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var ringIndex = bs(balanceContext.hashring, &#123;</span><br><span class=\"line\">        index: null,</span><br><span class=\"line\">        value: this.generateHash(conf.balanceKey)</span><br><span class=\"line\">    &#125;, function (a, b) &#123;</span><br><span class=\"line\">        return a.value - b.value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    if (ringIndex &lt; 0) &#123;</span><br><span class=\"line\">        ringIndex = -ringIndex - 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ringIndex = Math.min(ringIndex, balanceContext.hashring.length - 1);</span><br><span class=\"line\">    var index = balanceContext.hashring[ringIndex].index;</span><br><span class=\"line\">    logger.trace(&apos;RandomBalance fetchServer index=&apos; + index + &apos; ServiceID=&apos; + balanceContext.serviceID);</span><br><span class=\"line\">    return servers[index];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"框架开发","_content":"\n\n","source":"en/docs/core/framework.md","raw":"title: 框架开发\n---\n\n\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/core/framework.html","comments":1,"layout":"page","_id":"cjyd4skii000l6lq1c19mkyp6","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"插件开发","_content":"\n插件机制是我们框架的一大特色。它不但可以保证框架核心的足够精简、稳定、高效，还可以促进业务逻辑的复用，生态圈的形成。有人可能会问了\n\n> Koa 已经有了中间件的机制，为啥还要插件呢？\n> 中间件、插件、应用它们之间是什么关系，有什么区别？\n> 我该怎么使用一个插件？\n> 如何编写一个插件？\n> ...\n\n接下来我们就来逐一讨论\n\n## 为什么要插件\n\n我们在使用 Koa 中间件过程中发现了下面一些问题：\n\n1. 中间件加载其实是有先后顺序的，但是中间件自身却无法管理这种顺序，只能交给使用者。这样其实非常不友好，一旦顺序不对，结果可能有天壤之别。\n2. 中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：定时任务、消息订阅、后台逻辑等等。\n3. 有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。\n\n综上所述，我们需要一套更加强大的机制，来管理、编排那些相对独立的业务逻辑。\n\n## 什么是插件\n\n一个插件其实就是一个『迷你的应用』，下面展示的是一个插件的目录结构，和应用（app）几乎一样。\n\n```js\n. hello-plugin\n├── package.json\n├── app.js (可选)\n├── agent.js (可选)\n├── app\n│   ├── extend (可选)\n│   |   ├── helper.js (可选)\n│   |   ├── request.js (可选)\n│   |   ├── response.js (可选)\n│   |   ├── context.js (可选)\n│   |   ├── application.js (可选)\n│   |   └── agent.js (可选)\n│   ├── service (可选)\n│   └── middleware (可选)\n│       └── mw.js\n├── config\n|   ├── config.default.js\n│   ├── config.prod.js\n|   ├── config.test.js (可选)\n|   ├── config.local.js (可选)\n|   └── config.unittest.js (可选)\n└── test\n    └── middleware\n        └── mw.test.js\n```\n\n那区别在哪儿呢？\n\n1. 插件没有独立的 router 和 controller。这主要出于几点考虑：\n\n    - 路由一般和应用强绑定的，不具备通用性。\n    - 一个应用可能依赖很多个插件，如果插件支持路由可能导致路由冲突。\n    - 如果确实有统一路由的需求，可以考虑在插件里通过中间件来实现。\n\n2. 插件需要在 `package.json` 中的 `eggPlugin` 节点指定插件特有的信息\n\n    - `{String} name` - 插件名（必须配置），具有唯一性，配置依赖关系时会指定依赖插件的 name。\n    - `{Array} dependencies` - 当前插件强依赖的插件列表（如果依赖的插件没找到，应用启动失败）。\n    - `{Array} optionalDependencies` - 当前插件的可选依赖插件列表（如果依赖的插件未开启，只会 warning，不会影响应用启动）。\n    - `{Array} env` - 只有在指定运行环境才能开启，具体有哪些环境可以参考[运行环境](../basics/env.md)。此配置是可选的，一般情况下都不需要配置。\n\n    ```json\n    {\n      \"name\": \"egg-rpc\",\n      \"eggPlugin\": {\n        \"name\": \"rpc\",\n        \"dependencies\": [ \"registry\" ],\n        \"optionalDependencies\": [ \"vip\" ],\n        \"env\": [ \"local\", \"test\", \"unittest\", \"prod\" ]\n      }\n    }\n    ```\n\n## 插件的依赖管理\n\n和中间件不同，插件是自己管理依赖的。应用在加载所有插件前会预先从它们的 `package.json` 中读取 `eggPlugin > dependencies` 和 `eggPlugin > optionalDependencies` 节点，然后根据依赖关系计算出加载顺序，举个例子，下面三个插件的加载顺序就应该是 `c => b => a`\n\n```json\n// plugin a\n{\n  \"name\": \"egg-plugin-a\",\n  \"eggPlugin\": {\n    \"name\": \"a\",\n    \"dependencies\": [ \"b\" ]\n  }\n}\n\n// plugin b\n{\n  \"name\": \"egg-plugin-b\",\n  \"egg-Plugin\": {\n    \"name\": \"b\",\n    \"optionalDependencies\": [ \"c\" ]\n  }\n}\n\n// plugin c\n{\n  \"name\": \"egg-plugin-c\",\n  \"egg-Plugin\": {\n    \"name\": \"c\"\n  }\n}\n```\n\n**注意：`dependencies` 和 `optionalDependencies` 的取值是另一个插件的 `eggPlugin.name`，而不是 `package name`。**\n\n`dependencies` 和 `optionalDependencies` 是从 `npm` 借鉴来的概念，大多数情况下我们都使用 `dependencies`，这也是我们最推荐的依赖方式。那什么时候可以用 `optionalDependencies` 呢？大致就两种：\n\n- 只在某些环境下才依赖，比如：一个鉴权插件，只在开发环境依赖一个 mock 数据的插件\n- 弱依赖，比如：A 依赖 B，但是如果没有 B，A 有相应的降级方案\n\n需要特别强调的是：如果采用 `optionalDependencies` 那么框架不会校验依赖的插件是否开启，它的作用仅仅是计算加载顺序。所以，这时候依赖方需要通过『接口探测』等方式来决定相应的处理逻辑。\n\n## 插件能做什么？\n\n上面给出了插件的定义，那插件到底能做什么？\n\n### 扩展内置对象的接口\n\n在插件相应的文件内对框架内置对象进行扩展，和应用一样\n\n- `app/extend/request.js` - 扩展 Koa#Request 类\n- `app/extend/response.js` - 扩展 Koa#Response 类\n- `app/extend/context.js` - 扩展 Koa#Context 类\n- `app/extend/helper.js ` - 扩展 Helper 类\n- `app/extend/application.js` - 扩展 Application 类\n- `app/extend/agent.js` - 扩展 Agent 类\n\n### 插入自定义中间件\n\n1. 首先在 `app/middleware` 目录下定义好中间件实现\n\n  ```js\n  'use strict';\n\n  const staticCache = require('koa-static-cache');\n  const assert = require('assert');\n  const mkdirp = require('mkdirp');\n\n  module.exports = (options, app) => {\n    assert.strictEqual(typeof options.dir, 'string', 'Must set `app.config.static.dir` when static plugin enable');\n\n    // ensure directory exists\n    mkdirp.sync(options.dir);\n\n    app.loggers.coreLogger.info('[egg-static] starting static serve %s -> %s', options.prefix, options.dir);\n\n    return staticCache(options);\n  };\n  ```\n\n2. 在 `app.js` 中将中间件插入到合适的位置（例如：下面将 static 中间件放到 bodyParser 之前）\n\n  ```js\n  const assert = require('assert');\n\n  module.exports = app => {\n    // 将 static 中间件放到 bodyParser 之前\n    const index = app.config.coreMiddleware.indexOf('bodyParser');\n    assert(index >= 0, 'bodyParser 中间件必须存在');\n\n    app.config.coreMiddleware.splice(index, 0, 'static');\n  };\n  ```\n\n### 在应用启动时做一些初始化工作\n\n- 我在启动前想读取一些本地配置\n\n  ```js\n  // ${plugin_root}/app.js\n  const fs = require('fs');\n  const path = require('path');\n\n  module.exports = app => {\n    app.customData = fs.readFileSync(path.join(app.config.baseDir, 'data.bin'));\n\n    app.coreLogger.info('read data ok');\n  };\n  ```\n\n- 如果有异步启动逻辑，可以使用 `app.beforeStart` API\n\n  ```js\n  // ${plugin_root}/app.js\n  const MyClient = require('my-client');\n\n  module.exports = app => {\n    app.myClient = new MyClient();\n    app.myClient.on('error', err => {\n      app.coreLogger.error(err);\n    });\n    app.beforeStart(function* () {\n      yield app.myClient.ready();\n      app.coreLogger.info('my client is ready');\n    });\n  };\n  ```\n\n- 也可以添加 agent 启动逻辑，使用 `agent.beforeStart` API\n\n  ```js\n  // ${plugin_root}/agent.js\n  const MyClient = require('my-client');\n\n  module.exports = agent => {\n    agent.myClient = new MyClient();\n    agent.myClient.on('error', err => {\n      agent.coreLogger.error(err);\n    });\n    agent.beforeStart(function* () {\n      yield agent.myClient.ready();\n      agent.coreLogger.info('my client is ready');\n    });\n  };\n  ```\n\n### 设置定时任务\n\n1. 在 `package.json` 里设置依赖 schedule 插件\n\n  ```json\n  {\n    \"name\": \"your-plugin\",\n    \"eggPlugin\": {\n      \"name\": \"your-plugin\",\n      \"dependencies\": [ \"schedule\" ]\n    }\n  }\n  ```\n\n2. 在 `${plugin_root}/app/schedule/` 目录下新建文件，编写你的定时任务\n\n  ```js\n  exports.schedule = {\n    type: 'worker',\n    cron: '0 0 3 * * *',\n    // interval: '1h',\n    // immediate: true,\n  };\n\n  exports.task = function* (ctx) {\n    // your logic code\n  };\n  ```\n\n### 全局实例插件的最佳实践\n\n许多插件的目的都是将一些已有的服务引入到框架中，如 [egg-mysql], [egg-oss]。他们都需要在 app 上创建对应的实例。而在开发这一类的插件时，我们发现存在一些普遍性的问题：\n\n- 在一个应用中同时使用同一个服务的不同实例（连接到两个不同的 MySQL 数据库）。\n- 从其他服务获取配置后动态初始化连接（从配置中心获取到 MySQL 服务地址后再建立连接）。\n\n如果让插件各自实现，可能会出现各种奇怪的配置方式和初始化方式，所以框架提供了 `app.addSingleton(name, creator)` 方法来统一这一类服务的创建。\n\n#### 插件写法\n\n我们将 [egg-mysql] 的实现简化之后来看看如何编写此类插件：\n\n```js\n// egg-mysql/app.js\nmodule.exports = app => {\n  // 第一个参数 mysql 指定了挂载到 app 上的字段，我们可以通过 `app.mysql` 访问到 MySQL singleton 实例\n  // 第二个参数 createMysql 接受两个参数(config, app)，并返回一个 MySQL 的实例\n  app.addSingleton('mysql', createMysql);\n}\n\n/**\n * @param  {Object} config   框架处理之后的配置项，如果应用配置了多个 MySQL 实例，会将每一个配置项分别传入并调用多次 createMysql\n * @param  {Application} app 当前的应用\n * @return {Object}          返回创建的 MySQL 实例\n */\nfunction createMysql(config, app) {\n  assert(config.host && config.port && config.user && config.database);\n  // 创建实例\n  const client = new Mysql(config);\n\n  // 做启动应用前的检查\n  app.beforeStart(function* () {\n    const rows = yield client.query('select now() as currentTime;');\n    const index = count++;\n    app.coreLogger.info(`[egg-mysql] instance[${index}] status OK, rds currentTime: ${rows[0].currentTime}`);\n  });\n\n  return client;\n}\n```\n\n可以看到，插件中我们只需要提供要挂载的字段以及对应服务的初始化方法，所有的配置管理、实例获取方式都由框架封装并统一提供了。\n\n#### 应用层使用方案\n\n##### 单实例\n\n1. 在配置文件中声明 MySQL 的配置。\n\n```js\n// config/config.default.js\nmodule.exports = {\n  mysql: {\n    client: {\n      host: 'mysql.com',\n      port: '3306',\n      user: 'test_user',\n      password: 'test_password',\n      database: 'test',\n    },\n  },\n};\n```\n\n2. 直接通过 `app.mysql` 访问数据库。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.mysql.query(sql, values);\n    },\n  };\n};\n```\n\n##### 多实例\n\n1. 同样需要在配置文件中声明 MySQL 的配置，不过和单实例时不同，配置项中需要有一个 `clients` 字段，分别申明不同实例的配置，同时可以通过 `default` 字段来配置多个实例中共享的配置（如 host 和 port）。\n\n```js\n// config/config.default.js\nexports.mysql = {\n  clients: {\n    // clientId, access the client instance by app.mysql.get('clientId')\n    db1: {\n      user: 'user1',\n      password: 'upassword1',\n      database: 'db1',\n    },\n    db2: {\n      user: 'user2',\n      password: 'upassword2',\n      database: 'db2',\n    },\n  },\n  // default configuration for all databases\n  default: {\n    host: 'mysql.com',\n    port: '3306',\n  },\n};\n```\n\n2. 通过 `app.mysql.get('db1')` 来获取对应的实例并使用。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.mysql.get('db1').query(sql, values);\n    },\n  };\n};\n```\n\n##### 动态创建实例\n\n我们可以不需要将配置提前申明在配置文件中，而是在应用运行时动态的初始化一个实例。\n\n```js\n// app.js\nmodule.exports = app => {\n  app.beforeStart(function* () {\n    // 从配置中心获取 MySQL 的配置 { host, post, password, ... }\n    const mysqlConfig = yield app.configCenter.fetch('mysql');\n    // 动态创建 MySQL 实例\n    app.database = app.mysql.createInstance(mysqlConfig);\n  });\n};\n```\n\n通过 `app.database` 来使用这个实例。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.databse.query(sql, values);\n    },\n  };\n};\n```\n\n**注意，在动态创建实例的时候，框架也会读取配置中 `default` 字段内的配置项作为默认配置。**\n\n## 插件使用指南\n\n### 安装\n\n和安装普通 `npm` 包一样\n\n```bash\n$ npm i egg-onerror --save\n```\n\n**注意：插件即使是只在 local 运行的，也需要配置为 dependencies 而不是 devDependencies，否则线上 `npm i --production` 时将无法找到插件。**\n\n### 开启和关闭\n\n在应用的 `${app_root}/config/plugin.js` 文件里配置\n\n```js\nmodule.exports = {\n  onerror: {\n    enable: true,\n    package: 'egg-onerror',\n  },\n};\n```\n\n每个配置项有一下配置参数：\n- `{Boolean} enable` - 是否开启此插件\n- `{String} package` - `npm` 模块名称，允许插件以 `npm` 模块形式引入\n- `{String} path` - 插件绝对路径，跟 package 配置互斥\n- `{Array} env` - 只有在指定运行环境才能开启，会覆盖插件自己的配置\n\n这里稍微讲下 package 和 path 的区别\n\n- package 是 `npm` 方式引入，也是最常见的引入方式\n- path 是绝对路径引入，一般是内置插件，比如：应用内部抽了一个插件，但还没来得及发布到 `npm`，或者是应用自己覆盖了框架的一些插件\n\n_说明：_ 框架内部内置了一些插件，而应用在使用这些插件的时候就不用配置 package 或者 path，只需要指定 enable 与否\n\n```js\n// 对于内置插件，可以用下面的简洁方式开启或关闭\nexports.onerror = false;\n```\n\n框架已内置插件列表：\n\n- [onerror](https://github.com/eggjs/egg-onerror) 统一异常处理\n- [Session](https://github.com/eggjs/egg-session) Session 实现\n- [i18n](https://github.com/eggjs/egg-i18n) 多语言\n- [watcher](https://github.com/eggjs/egg-watcher) 文件和文件夹监控\n- [multipart](https://github.com/eggjs/egg-multipart) 文件流式上传\n- [security](https://github.com/eggjs/egg-security) 安全\n- [development](https://github.com/eggjs/egg-development) 开发环境配置\n- [logrotator](https://github.com/eggjs/egg-logrotator) 日志切分\n- [schedule](https://github.com/eggjs/egg-schedule) 定时任务\n- [static](https://github.com/eggjs/egg-static) 静态服务器\n- [jsonp](https://github.com/eggjs/egg-jsonp) jsonp 支持\n- [view](https://github.com/eggjs/egg-view) 模板引擎\n\n### 根据环境配置\n\n插件还支持 `plugin.{env}.js` 这种模式，会根据[环境](../basics/env.md)加载插件配置。\n\n比如定义了一个开发环境使用的插件 `egg-dev`，只希望在本地环境加载，可以如下定义\n\n```js\n// package.json\n{\n  \"devDependencies\": {\n    \"egg-dev\": \"*\"\n  }\n}\n\n// config/plugin.local.js\nexports.dev = {\n  enable: true,\n  package: 'egg-dev',\n};\n```\n\n这样在生产环境可以不需要下载 `egg-dev` 的包了。\n\n### 插件的寻址规则\n\n框架在加载插件的时候，遵循下面的寻址规则：\n\n- 如果配置了 path，直接按照 path 加载\n- 没有 path 根据 package 名去查找，查找的顺序依次是\n\n  1. 应用根目录下的 `node_modules`\n  2. 应用依赖框架路径下的 `node_modules`\n  3. 当前路径下的 `node_modules` （主要是兼容单元测试场景）\n\n## 插件开发\n\n### 使用脚手架快速开发\n\n你可以直接通过 [egg-init] 选择 [plugin][egg-boilerplate-plugin] 脚手架来快速上手。\n\n```bash\n$ egg-init egg-xxx --type=plugin\n$ cd egg-xxx\n$ npm i\n$ npm test\n```\n\n### 插件规范\n\n我们非常欢迎您贡献新的插件，同时也希望您遵守下面一些规范：\n\n- 命名规范\n  - `npm` 包名以 `egg-` 开头，且为全小写，例如：`egg-xx`。比较长的词组用中划线：`egg-foo-bar`\n  - 对应的插件名使用小驼峰，小驼峰转换规则以 `npm` 包名的中划线为准 `egg-foo-bar` => `fooBar`\n  - 对于可以中划线也可以不用的情况，不做强制约定，例如：userservice(egg-userservice) 还是 user-service(egg-user-service) 都可以\n- `package.json` 书写规范\n  - 按照上面的文档添加 `eggPlugin` 节点\n  - 在 `keywords` 里加上 `egg`、`egg-plugin`、`eggPlugin` 等关键字，便于索引\n\n  ```json\n  {\n    \"name\": \"egg-view-nunjucks\",\n    \"version\": \"1.0.0\",\n    \"description\": \"view plugin for egg\",\n    \"eggPlugin\": {\n      \"name\": \"nunjucks\",\n      \"dep\": [\n        \"security\"\n      ]\n    },\n    \"keywords\": [\n      \"egg\",\n      \"egg-plugin\",\n      \"eggPlugin\",\n      \"egg-plugin-view\",\n      \"egg-view\",\n      \"nunjucks\"\n    ],\n  }\n  ```\n\n## 为何不使用 npm 包名来做插件名？\n\nEgg 是通过 `eggPlugin.name` 来定义插件名的，只在应用或框架具备唯一性，也就是说**多个 npm 包可能有相同的插件名**，为什么这么设计呢？\n\n首先 Egg 插件不仅仅支持 npm 包，还支持通过目录来找插件。在[渐进式开发](../tutorials/progressive.md)章节提到如何使用这两个配置来进行代码演进。目录对单元测试也比较友好。所以 Egg 无法通过 npm 的包名来做唯一性。\n\n更重要的是 Egg 可以使用这种特性来做适配器。比如[模板开发规范](./view-plugin.md#插件命名规范)定义的插件名为 view，而存在 `egg-view-nunjucks`，`egg-view-react` 等插件，使用者只需要更换插件和修改模板，不需要动 Controller， 因为所有的模板插件都实现了相同的 API。\n\n**将相同功能的插件赋予相同的插件名，具备相同的 API，可以快速切换**。这在模板、数据库等领域非常适用。\n\n[egg-init]: https://github.com/eggjs/egg-init\n[egg-boilerplate-plugin]: https://github.com/eggjs/egg-boilerplate-plugin\n[egg-mysql]: https://github.com/eggjs/egg-mysql\n[egg-oss]: https://github.com/eggjs/egg-oss\n","source":"en/docs/core/plugin.md","raw":"\ntitle: 插件开发\n---\n\n插件机制是我们框架的一大特色。它不但可以保证框架核心的足够精简、稳定、高效，还可以促进业务逻辑的复用，生态圈的形成。有人可能会问了\n\n> Koa 已经有了中间件的机制，为啥还要插件呢？\n> 中间件、插件、应用它们之间是什么关系，有什么区别？\n> 我该怎么使用一个插件？\n> 如何编写一个插件？\n> ...\n\n接下来我们就来逐一讨论\n\n## 为什么要插件\n\n我们在使用 Koa 中间件过程中发现了下面一些问题：\n\n1. 中间件加载其实是有先后顺序的，但是中间件自身却无法管理这种顺序，只能交给使用者。这样其实非常不友好，一旦顺序不对，结果可能有天壤之别。\n2. 中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：定时任务、消息订阅、后台逻辑等等。\n3. 有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。\n\n综上所述，我们需要一套更加强大的机制，来管理、编排那些相对独立的业务逻辑。\n\n## 什么是插件\n\n一个插件其实就是一个『迷你的应用』，下面展示的是一个插件的目录结构，和应用（app）几乎一样。\n\n```js\n. hello-plugin\n├── package.json\n├── app.js (可选)\n├── agent.js (可选)\n├── app\n│   ├── extend (可选)\n│   |   ├── helper.js (可选)\n│   |   ├── request.js (可选)\n│   |   ├── response.js (可选)\n│   |   ├── context.js (可选)\n│   |   ├── application.js (可选)\n│   |   └── agent.js (可选)\n│   ├── service (可选)\n│   └── middleware (可选)\n│       └── mw.js\n├── config\n|   ├── config.default.js\n│   ├── config.prod.js\n|   ├── config.test.js (可选)\n|   ├── config.local.js (可选)\n|   └── config.unittest.js (可选)\n└── test\n    └── middleware\n        └── mw.test.js\n```\n\n那区别在哪儿呢？\n\n1. 插件没有独立的 router 和 controller。这主要出于几点考虑：\n\n    - 路由一般和应用强绑定的，不具备通用性。\n    - 一个应用可能依赖很多个插件，如果插件支持路由可能导致路由冲突。\n    - 如果确实有统一路由的需求，可以考虑在插件里通过中间件来实现。\n\n2. 插件需要在 `package.json` 中的 `eggPlugin` 节点指定插件特有的信息\n\n    - `{String} name` - 插件名（必须配置），具有唯一性，配置依赖关系时会指定依赖插件的 name。\n    - `{Array} dependencies` - 当前插件强依赖的插件列表（如果依赖的插件没找到，应用启动失败）。\n    - `{Array} optionalDependencies` - 当前插件的可选依赖插件列表（如果依赖的插件未开启，只会 warning，不会影响应用启动）。\n    - `{Array} env` - 只有在指定运行环境才能开启，具体有哪些环境可以参考[运行环境](../basics/env.md)。此配置是可选的，一般情况下都不需要配置。\n\n    ```json\n    {\n      \"name\": \"egg-rpc\",\n      \"eggPlugin\": {\n        \"name\": \"rpc\",\n        \"dependencies\": [ \"registry\" ],\n        \"optionalDependencies\": [ \"vip\" ],\n        \"env\": [ \"local\", \"test\", \"unittest\", \"prod\" ]\n      }\n    }\n    ```\n\n## 插件的依赖管理\n\n和中间件不同，插件是自己管理依赖的。应用在加载所有插件前会预先从它们的 `package.json` 中读取 `eggPlugin > dependencies` 和 `eggPlugin > optionalDependencies` 节点，然后根据依赖关系计算出加载顺序，举个例子，下面三个插件的加载顺序就应该是 `c => b => a`\n\n```json\n// plugin a\n{\n  \"name\": \"egg-plugin-a\",\n  \"eggPlugin\": {\n    \"name\": \"a\",\n    \"dependencies\": [ \"b\" ]\n  }\n}\n\n// plugin b\n{\n  \"name\": \"egg-plugin-b\",\n  \"egg-Plugin\": {\n    \"name\": \"b\",\n    \"optionalDependencies\": [ \"c\" ]\n  }\n}\n\n// plugin c\n{\n  \"name\": \"egg-plugin-c\",\n  \"egg-Plugin\": {\n    \"name\": \"c\"\n  }\n}\n```\n\n**注意：`dependencies` 和 `optionalDependencies` 的取值是另一个插件的 `eggPlugin.name`，而不是 `package name`。**\n\n`dependencies` 和 `optionalDependencies` 是从 `npm` 借鉴来的概念，大多数情况下我们都使用 `dependencies`，这也是我们最推荐的依赖方式。那什么时候可以用 `optionalDependencies` 呢？大致就两种：\n\n- 只在某些环境下才依赖，比如：一个鉴权插件，只在开发环境依赖一个 mock 数据的插件\n- 弱依赖，比如：A 依赖 B，但是如果没有 B，A 有相应的降级方案\n\n需要特别强调的是：如果采用 `optionalDependencies` 那么框架不会校验依赖的插件是否开启，它的作用仅仅是计算加载顺序。所以，这时候依赖方需要通过『接口探测』等方式来决定相应的处理逻辑。\n\n## 插件能做什么？\n\n上面给出了插件的定义，那插件到底能做什么？\n\n### 扩展内置对象的接口\n\n在插件相应的文件内对框架内置对象进行扩展，和应用一样\n\n- `app/extend/request.js` - 扩展 Koa#Request 类\n- `app/extend/response.js` - 扩展 Koa#Response 类\n- `app/extend/context.js` - 扩展 Koa#Context 类\n- `app/extend/helper.js ` - 扩展 Helper 类\n- `app/extend/application.js` - 扩展 Application 类\n- `app/extend/agent.js` - 扩展 Agent 类\n\n### 插入自定义中间件\n\n1. 首先在 `app/middleware` 目录下定义好中间件实现\n\n  ```js\n  'use strict';\n\n  const staticCache = require('koa-static-cache');\n  const assert = require('assert');\n  const mkdirp = require('mkdirp');\n\n  module.exports = (options, app) => {\n    assert.strictEqual(typeof options.dir, 'string', 'Must set `app.config.static.dir` when static plugin enable');\n\n    // ensure directory exists\n    mkdirp.sync(options.dir);\n\n    app.loggers.coreLogger.info('[egg-static] starting static serve %s -> %s', options.prefix, options.dir);\n\n    return staticCache(options);\n  };\n  ```\n\n2. 在 `app.js` 中将中间件插入到合适的位置（例如：下面将 static 中间件放到 bodyParser 之前）\n\n  ```js\n  const assert = require('assert');\n\n  module.exports = app => {\n    // 将 static 中间件放到 bodyParser 之前\n    const index = app.config.coreMiddleware.indexOf('bodyParser');\n    assert(index >= 0, 'bodyParser 中间件必须存在');\n\n    app.config.coreMiddleware.splice(index, 0, 'static');\n  };\n  ```\n\n### 在应用启动时做一些初始化工作\n\n- 我在启动前想读取一些本地配置\n\n  ```js\n  // ${plugin_root}/app.js\n  const fs = require('fs');\n  const path = require('path');\n\n  module.exports = app => {\n    app.customData = fs.readFileSync(path.join(app.config.baseDir, 'data.bin'));\n\n    app.coreLogger.info('read data ok');\n  };\n  ```\n\n- 如果有异步启动逻辑，可以使用 `app.beforeStart` API\n\n  ```js\n  // ${plugin_root}/app.js\n  const MyClient = require('my-client');\n\n  module.exports = app => {\n    app.myClient = new MyClient();\n    app.myClient.on('error', err => {\n      app.coreLogger.error(err);\n    });\n    app.beforeStart(function* () {\n      yield app.myClient.ready();\n      app.coreLogger.info('my client is ready');\n    });\n  };\n  ```\n\n- 也可以添加 agent 启动逻辑，使用 `agent.beforeStart` API\n\n  ```js\n  // ${plugin_root}/agent.js\n  const MyClient = require('my-client');\n\n  module.exports = agent => {\n    agent.myClient = new MyClient();\n    agent.myClient.on('error', err => {\n      agent.coreLogger.error(err);\n    });\n    agent.beforeStart(function* () {\n      yield agent.myClient.ready();\n      agent.coreLogger.info('my client is ready');\n    });\n  };\n  ```\n\n### 设置定时任务\n\n1. 在 `package.json` 里设置依赖 schedule 插件\n\n  ```json\n  {\n    \"name\": \"your-plugin\",\n    \"eggPlugin\": {\n      \"name\": \"your-plugin\",\n      \"dependencies\": [ \"schedule\" ]\n    }\n  }\n  ```\n\n2. 在 `${plugin_root}/app/schedule/` 目录下新建文件，编写你的定时任务\n\n  ```js\n  exports.schedule = {\n    type: 'worker',\n    cron: '0 0 3 * * *',\n    // interval: '1h',\n    // immediate: true,\n  };\n\n  exports.task = function* (ctx) {\n    // your logic code\n  };\n  ```\n\n### 全局实例插件的最佳实践\n\n许多插件的目的都是将一些已有的服务引入到框架中，如 [egg-mysql], [egg-oss]。他们都需要在 app 上创建对应的实例。而在开发这一类的插件时，我们发现存在一些普遍性的问题：\n\n- 在一个应用中同时使用同一个服务的不同实例（连接到两个不同的 MySQL 数据库）。\n- 从其他服务获取配置后动态初始化连接（从配置中心获取到 MySQL 服务地址后再建立连接）。\n\n如果让插件各自实现，可能会出现各种奇怪的配置方式和初始化方式，所以框架提供了 `app.addSingleton(name, creator)` 方法来统一这一类服务的创建。\n\n#### 插件写法\n\n我们将 [egg-mysql] 的实现简化之后来看看如何编写此类插件：\n\n```js\n// egg-mysql/app.js\nmodule.exports = app => {\n  // 第一个参数 mysql 指定了挂载到 app 上的字段，我们可以通过 `app.mysql` 访问到 MySQL singleton 实例\n  // 第二个参数 createMysql 接受两个参数(config, app)，并返回一个 MySQL 的实例\n  app.addSingleton('mysql', createMysql);\n}\n\n/**\n * @param  {Object} config   框架处理之后的配置项，如果应用配置了多个 MySQL 实例，会将每一个配置项分别传入并调用多次 createMysql\n * @param  {Application} app 当前的应用\n * @return {Object}          返回创建的 MySQL 实例\n */\nfunction createMysql(config, app) {\n  assert(config.host && config.port && config.user && config.database);\n  // 创建实例\n  const client = new Mysql(config);\n\n  // 做启动应用前的检查\n  app.beforeStart(function* () {\n    const rows = yield client.query('select now() as currentTime;');\n    const index = count++;\n    app.coreLogger.info(`[egg-mysql] instance[${index}] status OK, rds currentTime: ${rows[0].currentTime}`);\n  });\n\n  return client;\n}\n```\n\n可以看到，插件中我们只需要提供要挂载的字段以及对应服务的初始化方法，所有的配置管理、实例获取方式都由框架封装并统一提供了。\n\n#### 应用层使用方案\n\n##### 单实例\n\n1. 在配置文件中声明 MySQL 的配置。\n\n```js\n// config/config.default.js\nmodule.exports = {\n  mysql: {\n    client: {\n      host: 'mysql.com',\n      port: '3306',\n      user: 'test_user',\n      password: 'test_password',\n      database: 'test',\n    },\n  },\n};\n```\n\n2. 直接通过 `app.mysql` 访问数据库。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.mysql.query(sql, values);\n    },\n  };\n};\n```\n\n##### 多实例\n\n1. 同样需要在配置文件中声明 MySQL 的配置，不过和单实例时不同，配置项中需要有一个 `clients` 字段，分别申明不同实例的配置，同时可以通过 `default` 字段来配置多个实例中共享的配置（如 host 和 port）。\n\n```js\n// config/config.default.js\nexports.mysql = {\n  clients: {\n    // clientId, access the client instance by app.mysql.get('clientId')\n    db1: {\n      user: 'user1',\n      password: 'upassword1',\n      database: 'db1',\n    },\n    db2: {\n      user: 'user2',\n      password: 'upassword2',\n      database: 'db2',\n    },\n  },\n  // default configuration for all databases\n  default: {\n    host: 'mysql.com',\n    port: '3306',\n  },\n};\n```\n\n2. 通过 `app.mysql.get('db1')` 来获取对应的实例并使用。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.mysql.get('db1').query(sql, values);\n    },\n  };\n};\n```\n\n##### 动态创建实例\n\n我们可以不需要将配置提前申明在配置文件中，而是在应用运行时动态的初始化一个实例。\n\n```js\n// app.js\nmodule.exports = app => {\n  app.beforeStart(function* () {\n    // 从配置中心获取 MySQL 的配置 { host, post, password, ... }\n    const mysqlConfig = yield app.configCenter.fetch('mysql');\n    // 动态创建 MySQL 实例\n    app.database = app.mysql.createInstance(mysqlConfig);\n  });\n};\n```\n\n通过 `app.database` 来使用这个实例。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.databse.query(sql, values);\n    },\n  };\n};\n```\n\n**注意，在动态创建实例的时候，框架也会读取配置中 `default` 字段内的配置项作为默认配置。**\n\n## 插件使用指南\n\n### 安装\n\n和安装普通 `npm` 包一样\n\n```bash\n$ npm i egg-onerror --save\n```\n\n**注意：插件即使是只在 local 运行的，也需要配置为 dependencies 而不是 devDependencies，否则线上 `npm i --production` 时将无法找到插件。**\n\n### 开启和关闭\n\n在应用的 `${app_root}/config/plugin.js` 文件里配置\n\n```js\nmodule.exports = {\n  onerror: {\n    enable: true,\n    package: 'egg-onerror',\n  },\n};\n```\n\n每个配置项有一下配置参数：\n- `{Boolean} enable` - 是否开启此插件\n- `{String} package` - `npm` 模块名称，允许插件以 `npm` 模块形式引入\n- `{String} path` - 插件绝对路径，跟 package 配置互斥\n- `{Array} env` - 只有在指定运行环境才能开启，会覆盖插件自己的配置\n\n这里稍微讲下 package 和 path 的区别\n\n- package 是 `npm` 方式引入，也是最常见的引入方式\n- path 是绝对路径引入，一般是内置插件，比如：应用内部抽了一个插件，但还没来得及发布到 `npm`，或者是应用自己覆盖了框架的一些插件\n\n_说明：_ 框架内部内置了一些插件，而应用在使用这些插件的时候就不用配置 package 或者 path，只需要指定 enable 与否\n\n```js\n// 对于内置插件，可以用下面的简洁方式开启或关闭\nexports.onerror = false;\n```\n\n框架已内置插件列表：\n\n- [onerror](https://github.com/eggjs/egg-onerror) 统一异常处理\n- [Session](https://github.com/eggjs/egg-session) Session 实现\n- [i18n](https://github.com/eggjs/egg-i18n) 多语言\n- [watcher](https://github.com/eggjs/egg-watcher) 文件和文件夹监控\n- [multipart](https://github.com/eggjs/egg-multipart) 文件流式上传\n- [security](https://github.com/eggjs/egg-security) 安全\n- [development](https://github.com/eggjs/egg-development) 开发环境配置\n- [logrotator](https://github.com/eggjs/egg-logrotator) 日志切分\n- [schedule](https://github.com/eggjs/egg-schedule) 定时任务\n- [static](https://github.com/eggjs/egg-static) 静态服务器\n- [jsonp](https://github.com/eggjs/egg-jsonp) jsonp 支持\n- [view](https://github.com/eggjs/egg-view) 模板引擎\n\n### 根据环境配置\n\n插件还支持 `plugin.{env}.js` 这种模式，会根据[环境](../basics/env.md)加载插件配置。\n\n比如定义了一个开发环境使用的插件 `egg-dev`，只希望在本地环境加载，可以如下定义\n\n```js\n// package.json\n{\n  \"devDependencies\": {\n    \"egg-dev\": \"*\"\n  }\n}\n\n// config/plugin.local.js\nexports.dev = {\n  enable: true,\n  package: 'egg-dev',\n};\n```\n\n这样在生产环境可以不需要下载 `egg-dev` 的包了。\n\n### 插件的寻址规则\n\n框架在加载插件的时候，遵循下面的寻址规则：\n\n- 如果配置了 path，直接按照 path 加载\n- 没有 path 根据 package 名去查找，查找的顺序依次是\n\n  1. 应用根目录下的 `node_modules`\n  2. 应用依赖框架路径下的 `node_modules`\n  3. 当前路径下的 `node_modules` （主要是兼容单元测试场景）\n\n## 插件开发\n\n### 使用脚手架快速开发\n\n你可以直接通过 [egg-init] 选择 [plugin][egg-boilerplate-plugin] 脚手架来快速上手。\n\n```bash\n$ egg-init egg-xxx --type=plugin\n$ cd egg-xxx\n$ npm i\n$ npm test\n```\n\n### 插件规范\n\n我们非常欢迎您贡献新的插件，同时也希望您遵守下面一些规范：\n\n- 命名规范\n  - `npm` 包名以 `egg-` 开头，且为全小写，例如：`egg-xx`。比较长的词组用中划线：`egg-foo-bar`\n  - 对应的插件名使用小驼峰，小驼峰转换规则以 `npm` 包名的中划线为准 `egg-foo-bar` => `fooBar`\n  - 对于可以中划线也可以不用的情况，不做强制约定，例如：userservice(egg-userservice) 还是 user-service(egg-user-service) 都可以\n- `package.json` 书写规范\n  - 按照上面的文档添加 `eggPlugin` 节点\n  - 在 `keywords` 里加上 `egg`、`egg-plugin`、`eggPlugin` 等关键字，便于索引\n\n  ```json\n  {\n    \"name\": \"egg-view-nunjucks\",\n    \"version\": \"1.0.0\",\n    \"description\": \"view plugin for egg\",\n    \"eggPlugin\": {\n      \"name\": \"nunjucks\",\n      \"dep\": [\n        \"security\"\n      ]\n    },\n    \"keywords\": [\n      \"egg\",\n      \"egg-plugin\",\n      \"eggPlugin\",\n      \"egg-plugin-view\",\n      \"egg-view\",\n      \"nunjucks\"\n    ],\n  }\n  ```\n\n## 为何不使用 npm 包名来做插件名？\n\nEgg 是通过 `eggPlugin.name` 来定义插件名的，只在应用或框架具备唯一性，也就是说**多个 npm 包可能有相同的插件名**，为什么这么设计呢？\n\n首先 Egg 插件不仅仅支持 npm 包，还支持通过目录来找插件。在[渐进式开发](../tutorials/progressive.md)章节提到如何使用这两个配置来进行代码演进。目录对单元测试也比较友好。所以 Egg 无法通过 npm 的包名来做唯一性。\n\n更重要的是 Egg 可以使用这种特性来做适配器。比如[模板开发规范](./view-plugin.md#插件命名规范)定义的插件名为 view，而存在 `egg-view-nunjucks`，`egg-view-react` 等插件，使用者只需要更换插件和修改模板，不需要动 Controller， 因为所有的模板插件都实现了相同的 API。\n\n**将相同功能的插件赋予相同的插件名，具备相同的 API，可以快速切换**。这在模板、数据库等领域非常适用。\n\n[egg-init]: https://github.com/eggjs/egg-init\n[egg-boilerplate-plugin]: https://github.com/eggjs/egg-boilerplate-plugin\n[egg-mysql]: https://github.com/eggjs/egg-mysql\n[egg-oss]: https://github.com/eggjs/egg-oss\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/core/plugin.html","comments":1,"layout":"page","_id":"cjyd4skik000m6lq1vytd4abk","content":"<p>插件机制是我们框架的一大特色。它不但可以保证框架核心的足够精简、稳定、高效，还可以促进业务逻辑的复用，生态圈的形成。有人可能会问了</p>\n<blockquote>\n<p>Koa 已经有了中间件的机制，为啥还要插件呢？\n中间件、插件、应用它们之间是什么关系，有什么区别？\n我该怎么使用一个插件？\n如何编写一个插件？\n...</p>\n</blockquote>\n<p>接下来我们就来逐一讨论</p>\n<h2 id=\"为什么要插件\"><a class=\"markdown-anchor\" href=\"#为什么要插件\">#</a> 为什么要插件</h2>\n<p>我们在使用 Koa 中间件过程中发现了下面一些问题：</p>\n<ol>\n<li>中间件加载其实是有先后顺序的，但是中间件自身却无法管理这种顺序，只能交给使用者。这样其实非常不友好，一旦顺序不对，结果可能有天壤之别。</li>\n<li>中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：定时任务、消息订阅、后台逻辑等等。</li>\n<li>有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。</li>\n</ol>\n<p>综上所述，我们需要一套更加强大的机制，来管理、编排那些相对独立的业务逻辑。</p>\n<h2 id=\"什么是插件\"><a class=\"markdown-anchor\" href=\"#什么是插件\">#</a> 什么是插件</h2>\n<p>一个插件其实就是一个『迷你的应用』，下面展示的是一个插件的目录结构，和应用（app）几乎一样。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">. hello-plugin</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── app.js (可选)</span><br><span class=\"line\">├── agent.js (可选)</span><br><span class=\"line\">├── app</span><br><span class=\"line\">│   ├── extend (可选)</span><br><span class=\"line\">│   |   ├── helper.js (可选)</span><br><span class=\"line\">│   |   ├── request.js (可选)</span><br><span class=\"line\">│   |   ├── response.js (可选)</span><br><span class=\"line\">│   |   ├── context.js (可选)</span><br><span class=\"line\">│   |   ├── application.js (可选)</span><br><span class=\"line\">│   |   └── agent.js (可选)</span><br><span class=\"line\">│   ├── service (可选)</span><br><span class=\"line\">│   └── middleware (可选)</span><br><span class=\"line\">│       └── mw.js</span><br><span class=\"line\">├── config</span><br><span class=\"line\">|   ├── config.default.js</span><br><span class=\"line\">│   ├── config.prod.js</span><br><span class=\"line\">|   ├── config.test.js (可选)</span><br><span class=\"line\">|   ├── config.local.js (可选)</span><br><span class=\"line\">|   └── config.unittest.js (可选)</span><br><span class=\"line\">└── test</span><br><span class=\"line\">    └── middleware</span><br><span class=\"line\">        └── mw.test.js</span><br></pre></td></tr></table></figure></p>\n<p>那区别在哪儿呢？</p>\n<ol>\n<li>\n<p>插件没有独立的 router 和 controller。这主要出于几点考虑：</p>\n<ul>\n<li>路由一般和应用强绑定的，不具备通用性。</li>\n<li>一个应用可能依赖很多个插件，如果插件支持路由可能导致路由冲突。</li>\n<li>如果确实有统一路由的需求，可以考虑在插件里通过中间件来实现。</li>\n</ul>\n</li>\n<li>\n<p>插件需要在 <code>package.json</code> 中的 <code>eggPlugin</code> 节点指定插件特有的信息</p>\n<ul>\n<li><code>{String} name</code> - 插件名（必须配置），具有唯一性，配置依赖关系时会指定依赖插件的 name。</li>\n<li><code>{Array} dependencies</code> - 当前插件强依赖的插件列表（如果依赖的插件没找到，应用启动失败）。</li>\n<li><code>{Array} optionalDependencies</code> - 当前插件的可选依赖插件列表（如果依赖的插件未开启，只会 warning，不会影响应用启动）。</li>\n<li><code>{Array} env</code> - 只有在指定运行环境才能开启，具体有哪些环境可以参考<a href=\"../basics/env.html\">运行环境</a>。此配置是可选的，一般情况下都不需要配置。</li>\n</ul>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-rpc\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"rpc\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"registry\"</span> ],</span><br><span class=\"line\">    <span class=\"attr\">\"optionalDependencies\"</span>: [ <span class=\"string\">\"vip\"</span> ],</span><br><span class=\"line\">    <span class=\"attr\">\"env\"</span>: [ <span class=\"string\">\"local\"</span>, <span class=\"string\">\"test\"</span>, <span class=\"string\">\"unittest\"</span>, <span class=\"string\">\"prod\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ol>\n<h2 id=\"插件的依赖管理\"><a class=\"markdown-anchor\" href=\"#插件的依赖管理\">#</a> 插件的依赖管理</h2>\n<p>和中间件不同，插件是自己管理依赖的。应用在加载所有插件前会预先从它们的 <code>package.json</code> 中读取 <code>eggPlugin &gt; dependencies</code> 和 <code>eggPlugin &gt; optionalDependencies</code> 节点，然后根据依赖关系计算出加载顺序，举个例子，下面三个插件的加载顺序就应该是 <code>c =&gt; b =&gt; a</code></p>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">// plugin a</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-a\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"a\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"b\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// plugin b</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-b\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"egg-Plugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"b\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"optionalDependencies\"</span>: [ <span class=\"string\">\"c\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// plugin c</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-c\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"egg-Plugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"c\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：<code>dependencies</code> 和 <code>optionalDependencies</code> 的取值是另一个插件的 <code>eggPlugin.name</code>，而不是 <code>package name</code>。</strong></p>\n<p><code>dependencies</code> 和 <code>optionalDependencies</code> 是从 <code>npm</code> 借鉴来的概念，大多数情况下我们都使用 <code>dependencies</code>，这也是我们最推荐的依赖方式。那什么时候可以用 <code>optionalDependencies</code> 呢？大致就两种：</p>\n<ul>\n<li>只在某些环境下才依赖，比如：一个鉴权插件，只在开发环境依赖一个 mock 数据的插件</li>\n<li>弱依赖，比如：A 依赖 B，但是如果没有 B，A 有相应的降级方案</li>\n</ul>\n<p>需要特别强调的是：如果采用 <code>optionalDependencies</code> 那么框架不会校验依赖的插件是否开启，它的作用仅仅是计算加载顺序。所以，这时候依赖方需要通过『接口探测』等方式来决定相应的处理逻辑。</p>\n<h2 id=\"插件能做什么\"><a class=\"markdown-anchor\" href=\"#插件能做什么\">#</a> 插件能做什么？</h2>\n<p>上面给出了插件的定义，那插件到底能做什么？</p>\n<h3 id=\"扩展内置对象的接口\"><a class=\"markdown-anchor\" href=\"#扩展内置对象的接口\">#</a> 扩展内置对象的接口</h3>\n<p>在插件相应的文件内对框架内置对象进行扩展，和应用一样</p>\n<ul>\n<li><code>app/extend/request.js</code> - 扩展 Koa#Request 类</li>\n<li><code>app/extend/response.js</code> - 扩展 Koa#Response 类</li>\n<li><code>app/extend/context.js</code> - 扩展 Koa#Context 类</li>\n<li><code>app/extend/helper.js</code> - 扩展 Helper 类</li>\n<li><code>app/extend/application.js</code> - 扩展 Application 类</li>\n<li><code>app/extend/agent.js</code> - 扩展 Agent 类</li>\n</ul>\n<h3 id=\"插入自定义中间件\"><a class=\"markdown-anchor\" href=\"#插入自定义中间件\">#</a> 插入自定义中间件</h3>\n<ol>\n<li>首先在 <code>app/middleware</code> 目录下定义好中间件实现</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> staticCache = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-static-cache'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">'assert'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mkdirp = <span class=\"built_in\">require</span>(<span class=\"string\">'mkdirp'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\">(<span class=\"params\">options, app</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  assert.strictEqual(<span class=\"keyword\">typeof</span> options.dir, <span class=\"string\">'string'</span>, <span class=\"string\">'Must set `app.config.static.dir` when static plugin enable'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ensure directory exists</span></span><br><span class=\"line\">  mkdirp.sync(options.dir);</span><br><span class=\"line\"></span><br><span class=\"line\">  app.loggers.coreLogger.info(<span class=\"string\">'[egg-static] starting static serve %s -&gt; %s'</span>, options.prefix, options.dir);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> staticCache(options);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>在 <code>app.js</code> 中将中间件插入到合适的位置（例如：下面将 static 中间件放到 bodyParser 之前）</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">'assert'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将 static 中间件放到 bodyParser 之前</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> index = app.config.coreMiddleware.indexOf(<span class=\"string\">'bodyParser'</span>);</span><br><span class=\"line\">  assert(index &gt;= <span class=\"number\">0</span>, <span class=\"string\">'bodyParser 中间件必须存在'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  app.config.coreMiddleware.splice(index, <span class=\"number\">0</span>, <span class=\"string\">'static'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"在应用启动时做一些初始化工作\"><a class=\"markdown-anchor\" href=\"#在应用启动时做一些初始化工作\">#</a> 在应用启动时做一些初始化工作</h3>\n<ul>\n<li>\n<p>我在启动前想读取一些本地配置</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.customData = fs.readFileSync(path.join(app.config.baseDir, <span class=\"string\">'data.bin'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  app.coreLogger.info(<span class=\"string\">'read data ok'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>如果有异步启动逻辑，可以使用 <code>app.beforeStart</code> API</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyClient = <span class=\"built_in\">require</span>(<span class=\"string\">'my-client'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.myClient = <span class=\"keyword\">new</span> MyClient();</span><br><span class=\"line\">  app.myClient.on(<span class=\"string\">'error'</span>, err =&gt; &#123;</span><br><span class=\"line\">    app.coreLogger.error(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> app.myClient.ready();</span><br><span class=\"line\">    app.coreLogger.info(<span class=\"string\">'my client is ready'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>也可以添加 agent 启动逻辑，使用 <code>agent.beforeStart</code> API</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/agent.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyClient = <span class=\"built_in\">require</span>(<span class=\"string\">'my-client'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">agent</span> =&gt;</span> &#123;</span><br><span class=\"line\">  agent.myClient = <span class=\"keyword\">new</span> MyClient();</span><br><span class=\"line\">  agent.myClient.on(<span class=\"string\">'error'</span>, err =&gt; &#123;</span><br><span class=\"line\">    agent.coreLogger.error(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  agent.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> agent.myClient.ready();</span><br><span class=\"line\">    agent.coreLogger.info(<span class=\"string\">'my client is ready'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h3 id=\"设置定时任务\"><a class=\"markdown-anchor\" href=\"#设置定时任务\">#</a> 设置定时任务</h3>\n<ol>\n<li>在 <code>package.json</code> 里设置依赖 schedule 插件</li>\n</ol>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"your-plugin\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"your-plugin\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"schedule\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>在 <code>${plugin_root}/app/schedule/</code> 目录下新建文件，编写你的定时任务</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">exports.schedule = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">'worker'</span>,</span><br><span class=\"line\">  cron: <span class=\"string\">'0 0 3 * * *'</span>,</span><br><span class=\"line\">  <span class=\"comment\">// interval: '1h',</span></span><br><span class=\"line\">  <span class=\"comment\">// immediate: true,</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.task = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\">ctx</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// your logic code</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"全局实例插件的最佳实践\"><a class=\"markdown-anchor\" href=\"#全局实例插件的最佳实践\">#</a> 全局实例插件的最佳实践</h3>\n<p>许多插件的目的都是将一些已有的服务引入到框架中，如 <a href=\"https://github.com/eggjs/egg-mysql\" target=\"_blank\" rel=\"noopener\">egg-mysql</a>, <a href=\"https://github.com/eggjs/egg-oss\" target=\"_blank\" rel=\"noopener\">egg-oss</a>。他们都需要在 app 上创建对应的实例。而在开发这一类的插件时，我们发现存在一些普遍性的问题：</p>\n<ul>\n<li>在一个应用中同时使用同一个服务的不同实例（连接到两个不同的 MySQL 数据库）。</li>\n<li>从其他服务获取配置后动态初始化连接（从配置中心获取到 MySQL 服务地址后再建立连接）。</li>\n</ul>\n<p>如果让插件各自实现，可能会出现各种奇怪的配置方式和初始化方式，所以框架提供了 <code>app.addSingleton(name, creator)</code> 方法来统一这一类服务的创建。</p>\n<h4 id=\"插件写法\"><a class=\"markdown-anchor\" href=\"#插件写法\">#</a> 插件写法</h4>\n<p>我们将 <a href=\"https://github.com/eggjs/egg-mysql\" target=\"_blank\" rel=\"noopener\">egg-mysql</a> 的实现简化之后来看看如何编写此类插件：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// egg-mysql/app.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 第一个参数 mysql 指定了挂载到 app 上的字段，我们可以通过 `app.mysql` 访问到 MySQL singleton 实例</span></span><br><span class=\"line\">  <span class=\"comment\">// 第二个参数 createMysql 接受两个参数(config, app)，并返回一个 MySQL 的实例</span></span><br><span class=\"line\">  app.addSingleton(<span class=\"string\">'mysql'</span>, createMysql);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;Object&#125; config   框架处理之后的配置项，如果应用配置了多个 MySQL 实例，会将每一个配置项分别传入并调用多次 createMysql</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;Application&#125; app 当前的应用</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;Object&#125;          返回创建的 MySQL 实例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createMysql</span>(<span class=\"params\">config, app</span>) </span>&#123;</span><br><span class=\"line\">  assert(config.host &amp;&amp; config.port &amp;&amp; config.user &amp;&amp; config.database);</span><br><span class=\"line\">  <span class=\"comment\">// 创建实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> Mysql(config);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 做启动应用前的检查</span></span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> rows = <span class=\"keyword\">yield</span> client.query(<span class=\"string\">'select now() as currentTime;'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = count++;</span><br><span class=\"line\">    app.coreLogger.info(<span class=\"string\">`[egg-mysql] instance[<span class=\"subst\">$&#123;index&#125;</span>] status OK, rds currentTime: <span class=\"subst\">$&#123;rows[<span class=\"number\">0</span>].currentTime&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，插件中我们只需要提供要挂载的字段以及对应服务的初始化方法，所有的配置管理、实例获取方式都由框架封装并统一提供了。</p>\n<h4 id=\"应用层使用方案\"><a class=\"markdown-anchor\" href=\"#应用层使用方案\">#</a> 应用层使用方案</h4>\n<h5 id=\"单实例\"><a class=\"markdown-anchor\" href=\"#单实例\">#</a> 单实例</h5>\n<ol>\n<li>在配置文件中声明 MySQL 的配置。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/config.default.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  mysql: &#123;</span><br><span class=\"line\">    client: &#123;</span><br><span class=\"line\">      host: <span class=\"string\">'mysql.com'</span>,</span><br><span class=\"line\">      port: <span class=\"string\">'3306'</span>,</span><br><span class=\"line\">      user: <span class=\"string\">'test_user'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'test_password'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>直接通过 <code>app.mysql</code> 访问数据库。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.mysql.query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"多实例\"><a class=\"markdown-anchor\" href=\"#多实例\">#</a> 多实例</h5>\n<ol>\n<li>同样需要在配置文件中声明 MySQL 的配置，不过和单实例时不同，配置项中需要有一个 <code>clients</code> 字段，分别申明不同实例的配置，同时可以通过 <code>default</code> 字段来配置多个实例中共享的配置（如 host 和 port）。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/config.default.js</span></span><br><span class=\"line\">exports.mysql = &#123;</span><br><span class=\"line\">  clients: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// clientId, access the client instance by app.mysql.get('clientId')</span></span><br><span class=\"line\">    db1: &#123;</span><br><span class=\"line\">      user: <span class=\"string\">'user1'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'upassword1'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'db1'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    db2: &#123;</span><br><span class=\"line\">      user: <span class=\"string\">'user2'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'upassword2'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'db2'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// default configuration for all databases</span></span><br><span class=\"line\">  <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'mysql.com'</span>,</span><br><span class=\"line\">    port: <span class=\"string\">'3306'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>通过 <code>app.mysql.get('db1')</code> 来获取对应的实例并使用。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.mysql.get(<span class=\"string\">'db1'</span>).query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"动态创建实例\"><a class=\"markdown-anchor\" href=\"#动态创建实例\">#</a> 动态创建实例</h5>\n<p>我们可以不需要将配置提前申明在配置文件中，而是在应用运行时动态的初始化一个实例。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从配置中心获取 MySQL 的配置 &#123; host, post, password, ... &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> mysqlConfig = <span class=\"keyword\">yield</span> app.configCenter.fetch(<span class=\"string\">'mysql'</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 动态创建 MySQL 实例</span></span><br><span class=\"line\">    app.database = app.mysql.createInstance(mysqlConfig);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>通过 <code>app.database</code> 来使用这个实例。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.databse.query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意，在动态创建实例的时候，框架也会读取配置中 <code>default</code> 字段内的配置项作为默认配置。</strong></p>\n<h2 id=\"插件使用指南\"><a class=\"markdown-anchor\" href=\"#插件使用指南\">#</a> 插件使用指南</h2>\n<h3 id=\"安装\"><a class=\"markdown-anchor\" href=\"#安装\">#</a> 安装</h3>\n<p>和安装普通 <code>npm</code> 包一样</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm i egg-onerror --save</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：插件即使是只在 local 运行的，也需要配置为 dependencies 而不是 devDependencies，否则线上 <code>npm i --production</code> 时将无法找到插件。</strong></p>\n<h3 id=\"开启和关闭\"><a class=\"markdown-anchor\" href=\"#开启和关闭\">#</a> 开启和关闭</h3>\n<p>在应用的 <code>${app_root}/config/plugin.js</code> 文件里配置</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  onerror: &#123;</span><br><span class=\"line\">    enable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    package: <span class=\"string\">'egg-onerror'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>每个配置项有一下配置参数：</p>\n<ul>\n<li><code>{Boolean} enable</code> - 是否开启此插件</li>\n<li><code>{String} package</code> - <code>npm</code> 模块名称，允许插件以 <code>npm</code> 模块形式引入</li>\n<li><code>{String} path</code> - 插件绝对路径，跟 package 配置互斥</li>\n<li><code>{Array} env</code> - 只有在指定运行环境才能开启，会覆盖插件自己的配置</li>\n</ul>\n<p>这里稍微讲下 package 和 path 的区别</p>\n<ul>\n<li>package 是 <code>npm</code> 方式引入，也是最常见的引入方式</li>\n<li>path 是绝对路径引入，一般是内置插件，比如：应用内部抽了一个插件，但还没来得及发布到 <code>npm</code>，或者是应用自己覆盖了框架的一些插件</li>\n</ul>\n<p><em>说明：</em> 框架内部内置了一些插件，而应用在使用这些插件的时候就不用配置 package 或者 path，只需要指定 enable 与否</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于内置插件，可以用下面的简洁方式开启或关闭</span></span><br><span class=\"line\">exports.onerror = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure></p>\n<p>框架已内置插件列表：</p>\n<ul>\n<li><a href=\"https://github.com/eggjs/egg-onerror\" target=\"_blank\" rel=\"noopener\">onerror</a> 统一异常处理</li>\n<li><a href=\"https://github.com/eggjs/egg-session\" target=\"_blank\" rel=\"noopener\">Session</a> Session 实现</li>\n<li><a href=\"https://github.com/eggjs/egg-i18n\" target=\"_blank\" rel=\"noopener\">i18n</a> 多语言</li>\n<li><a href=\"https://github.com/eggjs/egg-watcher\" target=\"_blank\" rel=\"noopener\">watcher</a> 文件和文件夹监控</li>\n<li><a href=\"https://github.com/eggjs/egg-multipart\" target=\"_blank\" rel=\"noopener\">multipart</a> 文件流式上传</li>\n<li><a href=\"https://github.com/eggjs/egg-security\" target=\"_blank\" rel=\"noopener\">security</a> 安全</li>\n<li><a href=\"https://github.com/eggjs/egg-development\" target=\"_blank\" rel=\"noopener\">development</a> 开发环境配置</li>\n<li><a href=\"https://github.com/eggjs/egg-logrotator\" target=\"_blank\" rel=\"noopener\">logrotator</a> 日志切分</li>\n<li><a href=\"https://github.com/eggjs/egg-schedule\" target=\"_blank\" rel=\"noopener\">schedule</a> 定时任务</li>\n<li><a href=\"https://github.com/eggjs/egg-static\" target=\"_blank\" rel=\"noopener\">static</a> 静态服务器</li>\n<li><a href=\"https://github.com/eggjs/egg-jsonp\" target=\"_blank\" rel=\"noopener\">jsonp</a> jsonp 支持</li>\n<li><a href=\"https://github.com/eggjs/egg-view\" target=\"_blank\" rel=\"noopener\">view</a> 模板引擎</li>\n</ul>\n<h3 id=\"根据环境配置\"><a class=\"markdown-anchor\" href=\"#根据环境配置\">#</a> 根据环境配置</h3>\n<p>插件还支持 <code>plugin.{env}.js</code> 这种模式，会根据<a href=\"../basics/env.html\">环境</a>加载插件配置。</p>\n<p>比如定义了一个开发环境使用的插件 <code>egg-dev</code>，只希望在本地环境加载，可以如下定义</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"egg-dev\"</span>: <span class=\"string\">\"*\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// config/plugin.local.js</span></span><br><span class=\"line\">exports.dev = &#123;</span><br><span class=\"line\">  enable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  package: <span class=\"string\">'egg-dev'</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样在生产环境可以不需要下载 <code>egg-dev</code> 的包了。</p>\n<h3 id=\"插件的寻址规则\"><a class=\"markdown-anchor\" href=\"#插件的寻址规则\">#</a> 插件的寻址规则</h3>\n<p>框架在加载插件的时候，遵循下面的寻址规则：</p>\n<ul>\n<li>\n<p>如果配置了 path，直接按照 path 加载</p>\n</li>\n<li>\n<p>没有 path 根据 package 名去查找，查找的顺序依次是</p>\n<ol>\n<li>应用根目录下的 <code>node_modules</code></li>\n<li>应用依赖框架路径下的 <code>node_modules</code></li>\n<li>当前路径下的 <code>node_modules</code> （主要是兼容单元测试场景）</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"插件开发\"><a class=\"markdown-anchor\" href=\"#插件开发\">#</a> 插件开发</h2>\n<h3 id=\"使用脚手架快速开发\"><a class=\"markdown-anchor\" href=\"#使用脚手架快速开发\">#</a> 使用脚手架快速开发</h3>\n<p>你可以直接通过 <a href=\"https://github.com/eggjs/egg-init\" target=\"_blank\" rel=\"noopener\">egg-init</a> 选择 <a href=\"https://github.com/eggjs/egg-boilerplate-plugin\" target=\"_blank\" rel=\"noopener\">plugin</a> 脚手架来快速上手。</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ egg-init egg-xxx --<span class=\"built_in\">type</span>=plugin</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> egg-xxx</span><br><span class=\"line\">$ npm i</span><br><span class=\"line\">$ npm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"插件规范\"><a class=\"markdown-anchor\" href=\"#插件规范\">#</a> 插件规范</h3>\n<p>我们非常欢迎您贡献新的插件，同时也希望您遵守下面一些规范：</p>\n<ul>\n<li>\n<p>命名规范</p>\n<ul>\n<li><code>npm</code> 包名以 <code>egg-</code> 开头，且为全小写，例如：<code>egg-xx</code>。比较长的词组用中划线：<code>egg-foo-bar</code></li>\n<li>对应的插件名使用小驼峰，小驼峰转换规则以 <code>npm</code> 包名的中划线为准 <code>egg-foo-bar</code> =&gt; <code>fooBar</code></li>\n<li>对于可以中划线也可以不用的情况，不做强制约定，例如：userservice(egg-userservice) 还是 user-service(egg-user-service) 都可以</li>\n</ul>\n</li>\n<li>\n<p><code>package.json</code> 书写规范</p>\n<ul>\n<li>按照上面的文档添加 <code>eggPlugin</code> 节点</li>\n<li>在 <code>keywords</code> 里加上 <code>egg</code>、<code>egg-plugin</code>、<code>eggPlugin</code> 等关键字，便于索引</li>\n</ul>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-view-nunjucks\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"view plugin for egg\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"nunjucks\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dep\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"security\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"keywords\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-plugin\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"eggPlugin\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-plugin-view\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-view\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"nunjucks\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h2 id=\"为何不使用-npm-包名来做插件名\"><a class=\"markdown-anchor\" href=\"#为何不使用-npm-包名来做插件名\">#</a> 为何不使用 npm 包名来做插件名？</h2>\n<p>Egg 是通过 <code>eggPlugin.name</code> 来定义插件名的，只在应用或框架具备唯一性，也就是说<strong>多个 npm 包可能有相同的插件名</strong>，为什么这么设计呢？</p>\n<p>首先 Egg 插件不仅仅支持 npm 包，还支持通过目录来找插件。在<a href=\"../tutorials/progressive.html\">渐进式开发</a>章节提到如何使用这两个配置来进行代码演进。目录对单元测试也比较友好。所以 Egg 无法通过 npm 的包名来做唯一性。</p>\n<p>更重要的是 Egg 可以使用这种特性来做适配器。比如<a href=\"./view-plugin.html#%E6%8F%92%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83\">模板开发规范</a>定义的插件名为 view，而存在 <code>egg-view-nunjucks</code>，<code>egg-view-react</code> 等插件，使用者只需要更换插件和修改模板，不需要动 Controller， 因为所有的模板插件都实现了相同的 API。</p>\n<p><strong>将相同功能的插件赋予相同的插件名，具备相同的 API，可以快速切换</strong>。这在模板、数据库等领域非常适用。</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>插件机制是我们框架的一大特色。它不但可以保证框架核心的足够精简、稳定、高效，还可以促进业务逻辑的复用，生态圈的形成。有人可能会问了</p>\n<blockquote>\n<p>Koa 已经有了中间件的机制，为啥还要插件呢？\n中间件、插件、应用它们之间是什么关系，有什么区别？\n我该怎么使用一个插件？\n如何编写一个插件？\n...</p>\n</blockquote>\n<p>接下来我们就来逐一讨论</p>\n<h2 id=\"为什么要插件\"><a class=\"markdown-anchor\" href=\"#为什么要插件\">#</a> 为什么要插件</h2>\n<p>我们在使用 Koa 中间件过程中发现了下面一些问题：</p>\n<ol>\n<li>中间件加载其实是有先后顺序的，但是中间件自身却无法管理这种顺序，只能交给使用者。这样其实非常不友好，一旦顺序不对，结果可能有天壤之别。</li>\n<li>中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：定时任务、消息订阅、后台逻辑等等。</li>\n<li>有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。</li>\n</ol>\n<p>综上所述，我们需要一套更加强大的机制，来管理、编排那些相对独立的业务逻辑。</p>\n<h2 id=\"什么是插件\"><a class=\"markdown-anchor\" href=\"#什么是插件\">#</a> 什么是插件</h2>\n<p>一个插件其实就是一个『迷你的应用』，下面展示的是一个插件的目录结构，和应用（app）几乎一样。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">. hello-plugin</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── app.js (可选)</span><br><span class=\"line\">├── agent.js (可选)</span><br><span class=\"line\">├── app</span><br><span class=\"line\">│   ├── extend (可选)</span><br><span class=\"line\">│   |   ├── helper.js (可选)</span><br><span class=\"line\">│   |   ├── request.js (可选)</span><br><span class=\"line\">│   |   ├── response.js (可选)</span><br><span class=\"line\">│   |   ├── context.js (可选)</span><br><span class=\"line\">│   |   ├── application.js (可选)</span><br><span class=\"line\">│   |   └── agent.js (可选)</span><br><span class=\"line\">│   ├── service (可选)</span><br><span class=\"line\">│   └── middleware (可选)</span><br><span class=\"line\">│       └── mw.js</span><br><span class=\"line\">├── config</span><br><span class=\"line\">|   ├── config.default.js</span><br><span class=\"line\">│   ├── config.prod.js</span><br><span class=\"line\">|   ├── config.test.js (可选)</span><br><span class=\"line\">|   ├── config.local.js (可选)</span><br><span class=\"line\">|   └── config.unittest.js (可选)</span><br><span class=\"line\">└── test</span><br><span class=\"line\">    └── middleware</span><br><span class=\"line\">        └── mw.test.js</span><br></pre></td></tr></table></figure></p>\n<p>那区别在哪儿呢？</p>\n<ol>\n<li>\n<p>插件没有独立的 router 和 controller。这主要出于几点考虑：</p>\n<ul>\n<li>路由一般和应用强绑定的，不具备通用性。</li>\n<li>一个应用可能依赖很多个插件，如果插件支持路由可能导致路由冲突。</li>\n<li>如果确实有统一路由的需求，可以考虑在插件里通过中间件来实现。</li>\n</ul>\n</li>\n<li>\n<p>插件需要在 <code>package.json</code> 中的 <code>eggPlugin</code> 节点指定插件特有的信息</p>\n<ul>\n<li><code>{String} name</code> - 插件名（必须配置），具有唯一性，配置依赖关系时会指定依赖插件的 name。</li>\n<li><code>{Array} dependencies</code> - 当前插件强依赖的插件列表（如果依赖的插件没找到，应用启动失败）。</li>\n<li><code>{Array} optionalDependencies</code> - 当前插件的可选依赖插件列表（如果依赖的插件未开启，只会 warning，不会影响应用启动）。</li>\n<li><code>{Array} env</code> - 只有在指定运行环境才能开启，具体有哪些环境可以参考<a href=\"../basics/env.html\">运行环境</a>。此配置是可选的，一般情况下都不需要配置。</li>\n</ul>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-rpc\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"rpc\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"registry\"</span> ],</span><br><span class=\"line\">    <span class=\"attr\">\"optionalDependencies\"</span>: [ <span class=\"string\">\"vip\"</span> ],</span><br><span class=\"line\">    <span class=\"attr\">\"env\"</span>: [ <span class=\"string\">\"local\"</span>, <span class=\"string\">\"test\"</span>, <span class=\"string\">\"unittest\"</span>, <span class=\"string\">\"prod\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ol>\n<h2 id=\"插件的依赖管理\"><a class=\"markdown-anchor\" href=\"#插件的依赖管理\">#</a> 插件的依赖管理</h2>\n<p>和中间件不同，插件是自己管理依赖的。应用在加载所有插件前会预先从它们的 <code>package.json</code> 中读取 <code>eggPlugin &gt; dependencies</code> 和 <code>eggPlugin &gt; optionalDependencies</code> 节点，然后根据依赖关系计算出加载顺序，举个例子，下面三个插件的加载顺序就应该是 <code>c =&gt; b =&gt; a</code></p>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">// plugin a</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-a\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"a\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"b\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// plugin b</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-b\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"egg-Plugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"b\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"optionalDependencies\"</span>: [ <span class=\"string\">\"c\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// plugin c</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-c\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"egg-Plugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"c\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：<code>dependencies</code> 和 <code>optionalDependencies</code> 的取值是另一个插件的 <code>eggPlugin.name</code>，而不是 <code>package name</code>。</strong></p>\n<p><code>dependencies</code> 和 <code>optionalDependencies</code> 是从 <code>npm</code> 借鉴来的概念，大多数情况下我们都使用 <code>dependencies</code>，这也是我们最推荐的依赖方式。那什么时候可以用 <code>optionalDependencies</code> 呢？大致就两种：</p>\n<ul>\n<li>只在某些环境下才依赖，比如：一个鉴权插件，只在开发环境依赖一个 mock 数据的插件</li>\n<li>弱依赖，比如：A 依赖 B，但是如果没有 B，A 有相应的降级方案</li>\n</ul>\n<p>需要特别强调的是：如果采用 <code>optionalDependencies</code> 那么框架不会校验依赖的插件是否开启，它的作用仅仅是计算加载顺序。所以，这时候依赖方需要通过『接口探测』等方式来决定相应的处理逻辑。</p>\n<h2 id=\"插件能做什么\"><a class=\"markdown-anchor\" href=\"#插件能做什么\">#</a> 插件能做什么？</h2>\n<p>上面给出了插件的定义，那插件到底能做什么？</p>\n<h3 id=\"扩展内置对象的接口\"><a class=\"markdown-anchor\" href=\"#扩展内置对象的接口\">#</a> 扩展内置对象的接口</h3>\n<p>在插件相应的文件内对框架内置对象进行扩展，和应用一样</p>\n<ul>\n<li><code>app/extend/request.js</code> - 扩展 Koa#Request 类</li>\n<li><code>app/extend/response.js</code> - 扩展 Koa#Response 类</li>\n<li><code>app/extend/context.js</code> - 扩展 Koa#Context 类</li>\n<li><code>app/extend/helper.js</code> - 扩展 Helper 类</li>\n<li><code>app/extend/application.js</code> - 扩展 Application 类</li>\n<li><code>app/extend/agent.js</code> - 扩展 Agent 类</li>\n</ul>\n<h3 id=\"插入自定义中间件\"><a class=\"markdown-anchor\" href=\"#插入自定义中间件\">#</a> 插入自定义中间件</h3>\n<ol>\n<li>首先在 <code>app/middleware</code> 目录下定义好中间件实现</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> staticCache = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-static-cache'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">'assert'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mkdirp = <span class=\"built_in\">require</span>(<span class=\"string\">'mkdirp'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\">(<span class=\"params\">options, app</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  assert.strictEqual(<span class=\"keyword\">typeof</span> options.dir, <span class=\"string\">'string'</span>, <span class=\"string\">'Must set `app.config.static.dir` when static plugin enable'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ensure directory exists</span></span><br><span class=\"line\">  mkdirp.sync(options.dir);</span><br><span class=\"line\"></span><br><span class=\"line\">  app.loggers.coreLogger.info(<span class=\"string\">'[egg-static] starting static serve %s -&gt; %s'</span>, options.prefix, options.dir);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> staticCache(options);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>在 <code>app.js</code> 中将中间件插入到合适的位置（例如：下面将 static 中间件放到 bodyParser 之前）</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">'assert'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将 static 中间件放到 bodyParser 之前</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> index = app.config.coreMiddleware.indexOf(<span class=\"string\">'bodyParser'</span>);</span><br><span class=\"line\">  assert(index &gt;= <span class=\"number\">0</span>, <span class=\"string\">'bodyParser 中间件必须存在'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  app.config.coreMiddleware.splice(index, <span class=\"number\">0</span>, <span class=\"string\">'static'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"在应用启动时做一些初始化工作\"><a class=\"markdown-anchor\" href=\"#在应用启动时做一些初始化工作\">#</a> 在应用启动时做一些初始化工作</h3>\n<ul>\n<li>\n<p>我在启动前想读取一些本地配置</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.customData = fs.readFileSync(path.join(app.config.baseDir, <span class=\"string\">'data.bin'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  app.coreLogger.info(<span class=\"string\">'read data ok'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>如果有异步启动逻辑，可以使用 <code>app.beforeStart</code> API</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyClient = <span class=\"built_in\">require</span>(<span class=\"string\">'my-client'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.myClient = <span class=\"keyword\">new</span> MyClient();</span><br><span class=\"line\">  app.myClient.on(<span class=\"string\">'error'</span>, err =&gt; &#123;</span><br><span class=\"line\">    app.coreLogger.error(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> app.myClient.ready();</span><br><span class=\"line\">    app.coreLogger.info(<span class=\"string\">'my client is ready'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>也可以添加 agent 启动逻辑，使用 <code>agent.beforeStart</code> API</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/agent.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyClient = <span class=\"built_in\">require</span>(<span class=\"string\">'my-client'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">agent</span> =&gt;</span> &#123;</span><br><span class=\"line\">  agent.myClient = <span class=\"keyword\">new</span> MyClient();</span><br><span class=\"line\">  agent.myClient.on(<span class=\"string\">'error'</span>, err =&gt; &#123;</span><br><span class=\"line\">    agent.coreLogger.error(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  agent.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> agent.myClient.ready();</span><br><span class=\"line\">    agent.coreLogger.info(<span class=\"string\">'my client is ready'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h3 id=\"设置定时任务\"><a class=\"markdown-anchor\" href=\"#设置定时任务\">#</a> 设置定时任务</h3>\n<ol>\n<li>在 <code>package.json</code> 里设置依赖 schedule 插件</li>\n</ol>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"your-plugin\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"your-plugin\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"schedule\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>在 <code>${plugin_root}/app/schedule/</code> 目录下新建文件，编写你的定时任务</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">exports.schedule = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">'worker'</span>,</span><br><span class=\"line\">  cron: <span class=\"string\">'0 0 3 * * *'</span>,</span><br><span class=\"line\">  <span class=\"comment\">// interval: '1h',</span></span><br><span class=\"line\">  <span class=\"comment\">// immediate: true,</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.task = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\">ctx</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// your logic code</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"全局实例插件的最佳实践\"><a class=\"markdown-anchor\" href=\"#全局实例插件的最佳实践\">#</a> 全局实例插件的最佳实践</h3>\n<p>许多插件的目的都是将一些已有的服务引入到框架中，如 <a href=\"https://github.com/eggjs/egg-mysql\" target=\"_blank\" rel=\"noopener\">egg-mysql</a>, <a href=\"https://github.com/eggjs/egg-oss\" target=\"_blank\" rel=\"noopener\">egg-oss</a>。他们都需要在 app 上创建对应的实例。而在开发这一类的插件时，我们发现存在一些普遍性的问题：</p>\n<ul>\n<li>在一个应用中同时使用同一个服务的不同实例（连接到两个不同的 MySQL 数据库）。</li>\n<li>从其他服务获取配置后动态初始化连接（从配置中心获取到 MySQL 服务地址后再建立连接）。</li>\n</ul>\n<p>如果让插件各自实现，可能会出现各种奇怪的配置方式和初始化方式，所以框架提供了 <code>app.addSingleton(name, creator)</code> 方法来统一这一类服务的创建。</p>\n<h4 id=\"插件写法\"><a class=\"markdown-anchor\" href=\"#插件写法\">#</a> 插件写法</h4>\n<p>我们将 <a href=\"https://github.com/eggjs/egg-mysql\" target=\"_blank\" rel=\"noopener\">egg-mysql</a> 的实现简化之后来看看如何编写此类插件：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// egg-mysql/app.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 第一个参数 mysql 指定了挂载到 app 上的字段，我们可以通过 `app.mysql` 访问到 MySQL singleton 实例</span></span><br><span class=\"line\">  <span class=\"comment\">// 第二个参数 createMysql 接受两个参数(config, app)，并返回一个 MySQL 的实例</span></span><br><span class=\"line\">  app.addSingleton(<span class=\"string\">'mysql'</span>, createMysql);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;Object&#125; config   框架处理之后的配置项，如果应用配置了多个 MySQL 实例，会将每一个配置项分别传入并调用多次 createMysql</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;Application&#125; app 当前的应用</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;Object&#125;          返回创建的 MySQL 实例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createMysql</span>(<span class=\"params\">config, app</span>) </span>&#123;</span><br><span class=\"line\">  assert(config.host &amp;&amp; config.port &amp;&amp; config.user &amp;&amp; config.database);</span><br><span class=\"line\">  <span class=\"comment\">// 创建实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> Mysql(config);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 做启动应用前的检查</span></span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> rows = <span class=\"keyword\">yield</span> client.query(<span class=\"string\">'select now() as currentTime;'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = count++;</span><br><span class=\"line\">    app.coreLogger.info(<span class=\"string\">`[egg-mysql] instance[<span class=\"subst\">$&#123;index&#125;</span>] status OK, rds currentTime: <span class=\"subst\">$&#123;rows[<span class=\"number\">0</span>].currentTime&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，插件中我们只需要提供要挂载的字段以及对应服务的初始化方法，所有的配置管理、实例获取方式都由框架封装并统一提供了。</p>\n<h4 id=\"应用层使用方案\"><a class=\"markdown-anchor\" href=\"#应用层使用方案\">#</a> 应用层使用方案</h4>\n<h5 id=\"单实例\"><a class=\"markdown-anchor\" href=\"#单实例\">#</a> 单实例</h5>\n<ol>\n<li>在配置文件中声明 MySQL 的配置。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/config.default.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  mysql: &#123;</span><br><span class=\"line\">    client: &#123;</span><br><span class=\"line\">      host: <span class=\"string\">'mysql.com'</span>,</span><br><span class=\"line\">      port: <span class=\"string\">'3306'</span>,</span><br><span class=\"line\">      user: <span class=\"string\">'test_user'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'test_password'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>直接通过 <code>app.mysql</code> 访问数据库。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.mysql.query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"多实例\"><a class=\"markdown-anchor\" href=\"#多实例\">#</a> 多实例</h5>\n<ol>\n<li>同样需要在配置文件中声明 MySQL 的配置，不过和单实例时不同，配置项中需要有一个 <code>clients</code> 字段，分别申明不同实例的配置，同时可以通过 <code>default</code> 字段来配置多个实例中共享的配置（如 host 和 port）。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/config.default.js</span></span><br><span class=\"line\">exports.mysql = &#123;</span><br><span class=\"line\">  clients: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// clientId, access the client instance by app.mysql.get('clientId')</span></span><br><span class=\"line\">    db1: &#123;</span><br><span class=\"line\">      user: <span class=\"string\">'user1'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'upassword1'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'db1'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    db2: &#123;</span><br><span class=\"line\">      user: <span class=\"string\">'user2'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'upassword2'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'db2'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// default configuration for all databases</span></span><br><span class=\"line\">  <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'mysql.com'</span>,</span><br><span class=\"line\">    port: <span class=\"string\">'3306'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>通过 <code>app.mysql.get('db1')</code> 来获取对应的实例并使用。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.mysql.get(<span class=\"string\">'db1'</span>).query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"动态创建实例\"><a class=\"markdown-anchor\" href=\"#动态创建实例\">#</a> 动态创建实例</h5>\n<p>我们可以不需要将配置提前申明在配置文件中，而是在应用运行时动态的初始化一个实例。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从配置中心获取 MySQL 的配置 &#123; host, post, password, ... &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> mysqlConfig = <span class=\"keyword\">yield</span> app.configCenter.fetch(<span class=\"string\">'mysql'</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 动态创建 MySQL 实例</span></span><br><span class=\"line\">    app.database = app.mysql.createInstance(mysqlConfig);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>通过 <code>app.database</code> 来使用这个实例。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.databse.query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意，在动态创建实例的时候，框架也会读取配置中 <code>default</code> 字段内的配置项作为默认配置。</strong></p>\n<h2 id=\"插件使用指南\"><a class=\"markdown-anchor\" href=\"#插件使用指南\">#</a> 插件使用指南</h2>\n<h3 id=\"安装\"><a class=\"markdown-anchor\" href=\"#安装\">#</a> 安装</h3>\n<p>和安装普通 <code>npm</code> 包一样</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm i egg-onerror --save</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：插件即使是只在 local 运行的，也需要配置为 dependencies 而不是 devDependencies，否则线上 <code>npm i --production</code> 时将无法找到插件。</strong></p>\n<h3 id=\"开启和关闭\"><a class=\"markdown-anchor\" href=\"#开启和关闭\">#</a> 开启和关闭</h3>\n<p>在应用的 <code>${app_root}/config/plugin.js</code> 文件里配置</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  onerror: &#123;</span><br><span class=\"line\">    enable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    package: <span class=\"string\">'egg-onerror'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>每个配置项有一下配置参数：</p>\n<ul>\n<li><code>{Boolean} enable</code> - 是否开启此插件</li>\n<li><code>{String} package</code> - <code>npm</code> 模块名称，允许插件以 <code>npm</code> 模块形式引入</li>\n<li><code>{String} path</code> - 插件绝对路径，跟 package 配置互斥</li>\n<li><code>{Array} env</code> - 只有在指定运行环境才能开启，会覆盖插件自己的配置</li>\n</ul>\n<p>这里稍微讲下 package 和 path 的区别</p>\n<ul>\n<li>package 是 <code>npm</code> 方式引入，也是最常见的引入方式</li>\n<li>path 是绝对路径引入，一般是内置插件，比如：应用内部抽了一个插件，但还没来得及发布到 <code>npm</code>，或者是应用自己覆盖了框架的一些插件</li>\n</ul>\n<p><em>说明：</em> 框架内部内置了一些插件，而应用在使用这些插件的时候就不用配置 package 或者 path，只需要指定 enable 与否</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于内置插件，可以用下面的简洁方式开启或关闭</span></span><br><span class=\"line\">exports.onerror = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure></p>\n<p>框架已内置插件列表：</p>\n<ul>\n<li><a href=\"https://github.com/eggjs/egg-onerror\" target=\"_blank\" rel=\"noopener\">onerror</a> 统一异常处理</li>\n<li><a href=\"https://github.com/eggjs/egg-session\" target=\"_blank\" rel=\"noopener\">Session</a> Session 实现</li>\n<li><a href=\"https://github.com/eggjs/egg-i18n\" target=\"_blank\" rel=\"noopener\">i18n</a> 多语言</li>\n<li><a href=\"https://github.com/eggjs/egg-watcher\" target=\"_blank\" rel=\"noopener\">watcher</a> 文件和文件夹监控</li>\n<li><a href=\"https://github.com/eggjs/egg-multipart\" target=\"_blank\" rel=\"noopener\">multipart</a> 文件流式上传</li>\n<li><a href=\"https://github.com/eggjs/egg-security\" target=\"_blank\" rel=\"noopener\">security</a> 安全</li>\n<li><a href=\"https://github.com/eggjs/egg-development\" target=\"_blank\" rel=\"noopener\">development</a> 开发环境配置</li>\n<li><a href=\"https://github.com/eggjs/egg-logrotator\" target=\"_blank\" rel=\"noopener\">logrotator</a> 日志切分</li>\n<li><a href=\"https://github.com/eggjs/egg-schedule\" target=\"_blank\" rel=\"noopener\">schedule</a> 定时任务</li>\n<li><a href=\"https://github.com/eggjs/egg-static\" target=\"_blank\" rel=\"noopener\">static</a> 静态服务器</li>\n<li><a href=\"https://github.com/eggjs/egg-jsonp\" target=\"_blank\" rel=\"noopener\">jsonp</a> jsonp 支持</li>\n<li><a href=\"https://github.com/eggjs/egg-view\" target=\"_blank\" rel=\"noopener\">view</a> 模板引擎</li>\n</ul>\n<h3 id=\"根据环境配置\"><a class=\"markdown-anchor\" href=\"#根据环境配置\">#</a> 根据环境配置</h3>\n<p>插件还支持 <code>plugin.{env}.js</code> 这种模式，会根据<a href=\"../basics/env.html\">环境</a>加载插件配置。</p>\n<p>比如定义了一个开发环境使用的插件 <code>egg-dev</code>，只希望在本地环境加载，可以如下定义</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"egg-dev\"</span>: <span class=\"string\">\"*\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// config/plugin.local.js</span></span><br><span class=\"line\">exports.dev = &#123;</span><br><span class=\"line\">  enable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  package: <span class=\"string\">'egg-dev'</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样在生产环境可以不需要下载 <code>egg-dev</code> 的包了。</p>\n<h3 id=\"插件的寻址规则\"><a class=\"markdown-anchor\" href=\"#插件的寻址规则\">#</a> 插件的寻址规则</h3>\n<p>框架在加载插件的时候，遵循下面的寻址规则：</p>\n<ul>\n<li>\n<p>如果配置了 path，直接按照 path 加载</p>\n</li>\n<li>\n<p>没有 path 根据 package 名去查找，查找的顺序依次是</p>\n<ol>\n<li>应用根目录下的 <code>node_modules</code></li>\n<li>应用依赖框架路径下的 <code>node_modules</code></li>\n<li>当前路径下的 <code>node_modules</code> （主要是兼容单元测试场景）</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"插件开发\"><a class=\"markdown-anchor\" href=\"#插件开发\">#</a> 插件开发</h2>\n<h3 id=\"使用脚手架快速开发\"><a class=\"markdown-anchor\" href=\"#使用脚手架快速开发\">#</a> 使用脚手架快速开发</h3>\n<p>你可以直接通过 <a href=\"https://github.com/eggjs/egg-init\" target=\"_blank\" rel=\"noopener\">egg-init</a> 选择 <a href=\"https://github.com/eggjs/egg-boilerplate-plugin\" target=\"_blank\" rel=\"noopener\">plugin</a> 脚手架来快速上手。</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ egg-init egg-xxx --<span class=\"built_in\">type</span>=plugin</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> egg-xxx</span><br><span class=\"line\">$ npm i</span><br><span class=\"line\">$ npm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"插件规范\"><a class=\"markdown-anchor\" href=\"#插件规范\">#</a> 插件规范</h3>\n<p>我们非常欢迎您贡献新的插件，同时也希望您遵守下面一些规范：</p>\n<ul>\n<li>\n<p>命名规范</p>\n<ul>\n<li><code>npm</code> 包名以 <code>egg-</code> 开头，且为全小写，例如：<code>egg-xx</code>。比较长的词组用中划线：<code>egg-foo-bar</code></li>\n<li>对应的插件名使用小驼峰，小驼峰转换规则以 <code>npm</code> 包名的中划线为准 <code>egg-foo-bar</code> =&gt; <code>fooBar</code></li>\n<li>对于可以中划线也可以不用的情况，不做强制约定，例如：userservice(egg-userservice) 还是 user-service(egg-user-service) 都可以</li>\n</ul>\n</li>\n<li>\n<p><code>package.json</code> 书写规范</p>\n<ul>\n<li>按照上面的文档添加 <code>eggPlugin</code> 节点</li>\n<li>在 <code>keywords</code> 里加上 <code>egg</code>、<code>egg-plugin</code>、<code>eggPlugin</code> 等关键字，便于索引</li>\n</ul>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-view-nunjucks\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"view plugin for egg\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"nunjucks\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dep\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"security\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"keywords\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-plugin\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"eggPlugin\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-plugin-view\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-view\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"nunjucks\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h2 id=\"为何不使用-npm-包名来做插件名\"><a class=\"markdown-anchor\" href=\"#为何不使用-npm-包名来做插件名\">#</a> 为何不使用 npm 包名来做插件名？</h2>\n<p>Egg 是通过 <code>eggPlugin.name</code> 来定义插件名的，只在应用或框架具备唯一性，也就是说<strong>多个 npm 包可能有相同的插件名</strong>，为什么这么设计呢？</p>\n<p>首先 Egg 插件不仅仅支持 npm 包，还支持通过目录来找插件。在<a href=\"../tutorials/progressive.html\">渐进式开发</a>章节提到如何使用这两个配置来进行代码演进。目录对单元测试也比较友好。所以 Egg 无法通过 npm 的包名来做唯一性。</p>\n<p>更重要的是 Egg 可以使用这种特性来做适配器。比如<a href=\"./view-plugin.html#%E6%8F%92%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83\">模板开发规范</a>定义的插件名为 view，而存在 <code>egg-view-nunjucks</code>，<code>egg-view-react</code> 等插件，使用者只需要更换插件和修改模板，不需要动 Controller， 因为所有的模板插件都实现了相同的 API。</p>\n<p><strong>将相同功能的插件赋予相同的插件名，具备相同的 API，可以快速切换</strong>。这在模板、数据库等领域非常适用。</p>\n"},{"title":"主要工作","_content":"\n通过PM2拆分服务，确保不同服务相互不受影响。\n\n### 1. 改造现有`pm2.json`，支持多app启动\n\n根据当前公有云Node集群现状（机器均为24核），拆分为两个独立服务：\n\n- `nuomi`: 承载糯米组件流量，端口为`8197`，实例数为14\n- `h5`: 承载所有h5模块渲染流量，端口为`8198`,实例数为10\n\n```\n{\n    \"apps\": [{\n        \"exec_interpreter\": \"node\",\n        \"name\": \"nuomi\",\n        \"exec_mode\": \"cluster_mode\",\n        \"instances\": \"14\",\n        \"max_memory_restart\": \"500M\",\n        \"merge_logs\": false,\n        \"script\": \"app.js\",\n        \"ignoreWatch\": [\"pm2\", \"log\", \"node_modules\"],\n        \"env\": {\n            \"NODE_ENV\": \"production\",\n            \"PM2_GRACEFUL_TIMEOUT\": 1000,\n            \"PORT\": 8197,\n            \"DEBUG\": true\n        },\n        \"env_dev\": {\n            \"NODE_ENV\": \"development\",\n            \"DEBUG\": true\n        },\n        \"env_test\": {\n            \"NODE_ENV\": \"qa\"\n        }\n    }, {\n        \"exec_interpreter\": \"node\",\n        \"name\": \"h5\",\n        \"exec_mode\": \"cluster_mode\",\n        \"instances\": \"10\",\n        \"max_memory_restart\": \"500M\",\n        \"merge_logs\": false,\n        \"script\": \"app.js\",\n        \"ignoreWatch\": [\"pm2\", \"log\", \"node_modules\"],\n        \"env\": {\n            \"NODE_ENV\": \"production\",\n            \"PM2_GRACEFUL_TIMEOUT\": 1000,\n            \"PORT\": 8198,\n            \"DEBUG\": true\n        },\n        \"env_dev\": {\n            \"NODE_ENV\": \"development\",\n            \"DEBUG\": true\n        },\n        \"env_test\": {\n            \"NODE_ENV\": \"qa\"\n        }\n    }]\n}\n\n```\n\n### 2. 改造启动脚本，支持业务APP独立重启\n\n    nuomi_restart.sh\n    h5_restart.sh\n\n命令改造：\n\n    bin/control start  // 开启所有服务\n    bin/control stop appname // 关闭某个服务（h5、nuomi）\n    bin/control delete appname // 删除某个服务（h5、nuomi）\n    bin/control restart appname // 重启某个服务\n    bin/control reload appname // 0宕机重启，后续上线重启采用reload方案\n    \n![reload](http://younth.coding.me/static/nodeui/reload.jpeg)\n\n## 上线步骤\n\n### 1. 上线NodeUI服务\n\n- 上线前先确定线上的服务进程名称\n\n- 涉及底层上线，上线前需要先stop/delete掉老的进程，为确保服务稳定，采用先stop，然后上线新的隔离方案，回归正常后，delete老的服务进程。\n\n- 需要review方案，或者直接OP操作删除老的进程。\n- 增加上线模块\n- 绑定上线重启脚本\n\n\n\n### 2. 上线ng rewrite 端口\n\n- 配置新的vip服务\n- 修改rewrite\n\n```\n/home/work/odp_cater/webserver/conf/vhost/\n```\n\n## 重点关注\n\n- 组件业务 \n- h5业务 \n- 日志（pm2+业务，关注日志是否会错乱）\n- 服务稳定（Node进程状态）\n\n## 回滚方案\n\n由于目前公有云回滚可能有坑，回滚过程进程应该不会被杀掉，可能有残留进程，需要杀掉。所以最佳回归方式是**覆盖上线**。涉及的模块：\n\n- fly\n- runtime\n","source":"en/docs/core/server-isoloton.md","raw":"title: 主要工作\n---\n\n通过PM2拆分服务，确保不同服务相互不受影响。\n\n### 1. 改造现有`pm2.json`，支持多app启动\n\n根据当前公有云Node集群现状（机器均为24核），拆分为两个独立服务：\n\n- `nuomi`: 承载糯米组件流量，端口为`8197`，实例数为14\n- `h5`: 承载所有h5模块渲染流量，端口为`8198`,实例数为10\n\n```\n{\n    \"apps\": [{\n        \"exec_interpreter\": \"node\",\n        \"name\": \"nuomi\",\n        \"exec_mode\": \"cluster_mode\",\n        \"instances\": \"14\",\n        \"max_memory_restart\": \"500M\",\n        \"merge_logs\": false,\n        \"script\": \"app.js\",\n        \"ignoreWatch\": [\"pm2\", \"log\", \"node_modules\"],\n        \"env\": {\n            \"NODE_ENV\": \"production\",\n            \"PM2_GRACEFUL_TIMEOUT\": 1000,\n            \"PORT\": 8197,\n            \"DEBUG\": true\n        },\n        \"env_dev\": {\n            \"NODE_ENV\": \"development\",\n            \"DEBUG\": true\n        },\n        \"env_test\": {\n            \"NODE_ENV\": \"qa\"\n        }\n    }, {\n        \"exec_interpreter\": \"node\",\n        \"name\": \"h5\",\n        \"exec_mode\": \"cluster_mode\",\n        \"instances\": \"10\",\n        \"max_memory_restart\": \"500M\",\n        \"merge_logs\": false,\n        \"script\": \"app.js\",\n        \"ignoreWatch\": [\"pm2\", \"log\", \"node_modules\"],\n        \"env\": {\n            \"NODE_ENV\": \"production\",\n            \"PM2_GRACEFUL_TIMEOUT\": 1000,\n            \"PORT\": 8198,\n            \"DEBUG\": true\n        },\n        \"env_dev\": {\n            \"NODE_ENV\": \"development\",\n            \"DEBUG\": true\n        },\n        \"env_test\": {\n            \"NODE_ENV\": \"qa\"\n        }\n    }]\n}\n\n```\n\n### 2. 改造启动脚本，支持业务APP独立重启\n\n    nuomi_restart.sh\n    h5_restart.sh\n\n命令改造：\n\n    bin/control start  // 开启所有服务\n    bin/control stop appname // 关闭某个服务（h5、nuomi）\n    bin/control delete appname // 删除某个服务（h5、nuomi）\n    bin/control restart appname // 重启某个服务\n    bin/control reload appname // 0宕机重启，后续上线重启采用reload方案\n    \n![reload](http://younth.coding.me/static/nodeui/reload.jpeg)\n\n## 上线步骤\n\n### 1. 上线NodeUI服务\n\n- 上线前先确定线上的服务进程名称\n\n- 涉及底层上线，上线前需要先stop/delete掉老的进程，为确保服务稳定，采用先stop，然后上线新的隔离方案，回归正常后，delete老的服务进程。\n\n- 需要review方案，或者直接OP操作删除老的进程。\n- 增加上线模块\n- 绑定上线重启脚本\n\n\n\n### 2. 上线ng rewrite 端口\n\n- 配置新的vip服务\n- 修改rewrite\n\n```\n/home/work/odp_cater/webserver/conf/vhost/\n```\n\n## 重点关注\n\n- 组件业务 \n- h5业务 \n- 日志（pm2+业务，关注日志是否会错乱）\n- 服务稳定（Node进程状态）\n\n## 回滚方案\n\n由于目前公有云回滚可能有坑，回滚过程进程应该不会被杀掉，可能有残留进程，需要杀掉。所以最佳回归方式是**覆盖上线**。涉及的模块：\n\n- fly\n- runtime\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/core/server-isoloton.html","comments":1,"layout":"page","_id":"cjyd4skim000n6lq10onn7tey","content":"<p>通过PM2拆分服务，确保不同服务相互不受影响。</p>\n<h3 id=\"1-改造现有pm2json支持多app启动\"><a class=\"markdown-anchor\" href=\"#1-改造现有pm2json支持多app启动\">#</a> 1. 改造现有<code>pm2.json</code>，支持多app启动</h3>\n<p>根据当前公有云Node集群现状（机器均为24核），拆分为两个独立服务：</p>\n<ul>\n<li><code>nuomi</code>: 承载糯米组件流量，端口为<code>8197</code>，实例数为14</li>\n<li><code>h5</code>: 承载所有h5模块渲染流量，端口为<code>8198</code>,实例数为10</li>\n</ul>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;apps&quot;: [&#123;</span><br><span class=\"line\">        &quot;exec_interpreter&quot;: &quot;node&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;nuomi&quot;,</span><br><span class=\"line\">        &quot;exec_mode&quot;: &quot;cluster_mode&quot;,</span><br><span class=\"line\">        &quot;instances&quot;: &quot;14&quot;,</span><br><span class=\"line\">        &quot;max_memory_restart&quot;: &quot;500M&quot;,</span><br><span class=\"line\">        &quot;merge_logs&quot;: false,</span><br><span class=\"line\">        &quot;script&quot;: &quot;app.js&quot;,</span><br><span class=\"line\">        &quot;ignoreWatch&quot;: [&quot;pm2&quot;, &quot;log&quot;, &quot;node_modules&quot;],</span><br><span class=\"line\">        &quot;env&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class=\"line\">            &quot;PM2_GRACEFUL_TIMEOUT&quot;: 1000,</span><br><span class=\"line\">            &quot;PORT&quot;: 8197,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_dev&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_test&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;qa&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        &quot;exec_interpreter&quot;: &quot;node&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;h5&quot;,</span><br><span class=\"line\">        &quot;exec_mode&quot;: &quot;cluster_mode&quot;,</span><br><span class=\"line\">        &quot;instances&quot;: &quot;10&quot;,</span><br><span class=\"line\">        &quot;max_memory_restart&quot;: &quot;500M&quot;,</span><br><span class=\"line\">        &quot;merge_logs&quot;: false,</span><br><span class=\"line\">        &quot;script&quot;: &quot;app.js&quot;,</span><br><span class=\"line\">        &quot;ignoreWatch&quot;: [&quot;pm2&quot;, &quot;log&quot;, &quot;node_modules&quot;],</span><br><span class=\"line\">        &quot;env&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class=\"line\">            &quot;PM2_GRACEFUL_TIMEOUT&quot;: 1000,</span><br><span class=\"line\">            &quot;PORT&quot;: 8198,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_dev&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_test&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;qa&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-改造启动脚本支持业务app独立重启\"><a class=\"markdown-anchor\" href=\"#2-改造启动脚本支持业务app独立重启\">#</a> 2. 改造启动脚本，支持业务APP独立重启</h3>\n<pre><code>nuomi_restart.sh\nh5_restart.sh\n</code></pre>\n<p>命令改造：</p>\n<pre><code>bin/control start  // 开启所有服务\nbin/control stop appname // 关闭某个服务（h5、nuomi）\nbin/control delete appname // 删除某个服务（h5、nuomi）\nbin/control restart appname // 重启某个服务\nbin/control reload appname // 0宕机重启，后续上线重启采用reload方案\n</code></pre>\n<p><img src=\"http://younth.coding.me/static/nodeui/reload.jpeg\" alt=\"reload\"></p>\n<h2 id=\"上线步骤\"><a class=\"markdown-anchor\" href=\"#上线步骤\">#</a> 上线步骤</h2>\n<h3 id=\"1-上线nodeui服务\"><a class=\"markdown-anchor\" href=\"#1-上线nodeui服务\">#</a> 1. 上线NodeUI服务</h3>\n<ul>\n<li>\n<p>上线前先确定线上的服务进程名称</p>\n</li>\n<li>\n<p>涉及底层上线，上线前需要先stop/delete掉老的进程，为确保服务稳定，采用先stop，然后上线新的隔离方案，回归正常后，delete老的服务进程。</p>\n</li>\n<li>\n<p>需要review方案，或者直接OP操作删除老的进程。</p>\n</li>\n<li>\n<p>增加上线模块</p>\n</li>\n<li>\n<p>绑定上线重启脚本</p>\n</li>\n</ul>\n<h3 id=\"2-上线ng-rewrite-端口\"><a class=\"markdown-anchor\" href=\"#2-上线ng-rewrite-端口\">#</a> 2. 上线ng rewrite 端口</h3>\n<ul>\n<li>配置新的vip服务</li>\n<li>修改rewrite</li>\n</ul>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home/work/odp_cater/webserver/conf/vhost/</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"重点关注\"><a class=\"markdown-anchor\" href=\"#重点关注\">#</a> 重点关注</h2>\n<ul>\n<li>组件业务</li>\n<li>h5业务</li>\n<li>日志（pm2+业务，关注日志是否会错乱）</li>\n<li>服务稳定（Node进程状态）</li>\n</ul>\n<h2 id=\"回滚方案\"><a class=\"markdown-anchor\" href=\"#回滚方案\">#</a> 回滚方案</h2>\n<p>由于目前公有云回滚可能有坑，回滚过程进程应该不会被杀掉，可能有残留进程，需要杀掉。所以最佳回归方式是<strong>覆盖上线</strong>。涉及的模块：</p>\n<ul>\n<li>fly</li>\n<li>runtime</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>通过PM2拆分服务，确保不同服务相互不受影响。</p>\n<h3 id=\"1-改造现有pm2json支持多app启动\"><a class=\"markdown-anchor\" href=\"#1-改造现有pm2json支持多app启动\">#</a> 1. 改造现有<code>pm2.json</code>，支持多app启动</h3>\n<p>根据当前公有云Node集群现状（机器均为24核），拆分为两个独立服务：</p>\n<ul>\n<li><code>nuomi</code>: 承载糯米组件流量，端口为<code>8197</code>，实例数为14</li>\n<li><code>h5</code>: 承载所有h5模块渲染流量，端口为<code>8198</code>,实例数为10</li>\n</ul>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;apps&quot;: [&#123;</span><br><span class=\"line\">        &quot;exec_interpreter&quot;: &quot;node&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;nuomi&quot;,</span><br><span class=\"line\">        &quot;exec_mode&quot;: &quot;cluster_mode&quot;,</span><br><span class=\"line\">        &quot;instances&quot;: &quot;14&quot;,</span><br><span class=\"line\">        &quot;max_memory_restart&quot;: &quot;500M&quot;,</span><br><span class=\"line\">        &quot;merge_logs&quot;: false,</span><br><span class=\"line\">        &quot;script&quot;: &quot;app.js&quot;,</span><br><span class=\"line\">        &quot;ignoreWatch&quot;: [&quot;pm2&quot;, &quot;log&quot;, &quot;node_modules&quot;],</span><br><span class=\"line\">        &quot;env&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class=\"line\">            &quot;PM2_GRACEFUL_TIMEOUT&quot;: 1000,</span><br><span class=\"line\">            &quot;PORT&quot;: 8197,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_dev&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_test&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;qa&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        &quot;exec_interpreter&quot;: &quot;node&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;h5&quot;,</span><br><span class=\"line\">        &quot;exec_mode&quot;: &quot;cluster_mode&quot;,</span><br><span class=\"line\">        &quot;instances&quot;: &quot;10&quot;,</span><br><span class=\"line\">        &quot;max_memory_restart&quot;: &quot;500M&quot;,</span><br><span class=\"line\">        &quot;merge_logs&quot;: false,</span><br><span class=\"line\">        &quot;script&quot;: &quot;app.js&quot;,</span><br><span class=\"line\">        &quot;ignoreWatch&quot;: [&quot;pm2&quot;, &quot;log&quot;, &quot;node_modules&quot;],</span><br><span class=\"line\">        &quot;env&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class=\"line\">            &quot;PM2_GRACEFUL_TIMEOUT&quot;: 1000,</span><br><span class=\"line\">            &quot;PORT&quot;: 8198,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_dev&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_test&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;qa&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-改造启动脚本支持业务app独立重启\"><a class=\"markdown-anchor\" href=\"#2-改造启动脚本支持业务app独立重启\">#</a> 2. 改造启动脚本，支持业务APP独立重启</h3>\n<pre><code>nuomi_restart.sh\nh5_restart.sh\n</code></pre>\n<p>命令改造：</p>\n<pre><code>bin/control start  // 开启所有服务\nbin/control stop appname // 关闭某个服务（h5、nuomi）\nbin/control delete appname // 删除某个服务（h5、nuomi）\nbin/control restart appname // 重启某个服务\nbin/control reload appname // 0宕机重启，后续上线重启采用reload方案\n</code></pre>\n<p><img src=\"http://younth.coding.me/static/nodeui/reload.jpeg\" alt=\"reload\"></p>\n<h2 id=\"上线步骤\"><a class=\"markdown-anchor\" href=\"#上线步骤\">#</a> 上线步骤</h2>\n<h3 id=\"1-上线nodeui服务\"><a class=\"markdown-anchor\" href=\"#1-上线nodeui服务\">#</a> 1. 上线NodeUI服务</h3>\n<ul>\n<li>\n<p>上线前先确定线上的服务进程名称</p>\n</li>\n<li>\n<p>涉及底层上线，上线前需要先stop/delete掉老的进程，为确保服务稳定，采用先stop，然后上线新的隔离方案，回归正常后，delete老的服务进程。</p>\n</li>\n<li>\n<p>需要review方案，或者直接OP操作删除老的进程。</p>\n</li>\n<li>\n<p>增加上线模块</p>\n</li>\n<li>\n<p>绑定上线重启脚本</p>\n</li>\n</ul>\n<h3 id=\"2-上线ng-rewrite-端口\"><a class=\"markdown-anchor\" href=\"#2-上线ng-rewrite-端口\">#</a> 2. 上线ng rewrite 端口</h3>\n<ul>\n<li>配置新的vip服务</li>\n<li>修改rewrite</li>\n</ul>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home/work/odp_cater/webserver/conf/vhost/</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"重点关注\"><a class=\"markdown-anchor\" href=\"#重点关注\">#</a> 重点关注</h2>\n<ul>\n<li>组件业务</li>\n<li>h5业务</li>\n<li>日志（pm2+业务，关注日志是否会错乱）</li>\n<li>服务稳定（Node进程状态）</li>\n</ul>\n<h2 id=\"回滚方案\"><a class=\"markdown-anchor\" href=\"#回滚方案\">#</a> 回滚方案</h2>\n<p>由于目前公有云回滚可能有坑，回滚过程进程应该不会被杀掉，可能有残留进程，需要杀掉。所以最佳回归方式是<strong>覆盖上线</strong>。涉及的模块：</p>\n<ul>\n<li>fly</li>\n<li>runtime</li>\n</ul>\n"},{"title":"NodeUI文档平台正式启动","_content":"\n各位同学，**NodeUI本季度将对外承接服务**，为保证其他业务部门同学顺利接入，同时也为其他对NodeUI感兴趣的同学提供学习平台，文档建设亟待完善。\n\n无论你是刚接触 Node 还是 Node 的老司机，都可以贡献出自己的文章（`仅限markdown文档格式`）。包括不局限：\n\n- NodeUI如何在业务中使用\n- NodeUI 服务通信原理\n- NodeUI 运维\n- fekey 开发工具在 NodeUI 中的使用\n- 微信授权的那些坑\n- Universal Link 流程\n- NodeUI 服务运行原理\n- 线上部署\n- 监控报警\n- 守护进程原理\n- ......\n\n大家平时使用过程中有任何建议也欢迎提出来，共同改进，建设 NodeUI 生态 ~~\n\n","source":"en/docs/faq/contributing.md","raw":"title: NodeUI文档平台正式启动\n---\n\n各位同学，**NodeUI本季度将对外承接服务**，为保证其他业务部门同学顺利接入，同时也为其他对NodeUI感兴趣的同学提供学习平台，文档建设亟待完善。\n\n无论你是刚接触 Node 还是 Node 的老司机，都可以贡献出自己的文章（`仅限markdown文档格式`）。包括不局限：\n\n- NodeUI如何在业务中使用\n- NodeUI 服务通信原理\n- NodeUI 运维\n- fekey 开发工具在 NodeUI 中的使用\n- 微信授权的那些坑\n- Universal Link 流程\n- NodeUI 服务运行原理\n- 线上部署\n- 监控报警\n- 守护进程原理\n- ......\n\n大家平时使用过程中有任何建议也欢迎提出来，共同改进，建设 NodeUI 生态 ~~\n\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/faq/contributing.html","comments":1,"layout":"page","_id":"cjyd4skin000o6lq1grnsvruu","content":"<p>各位同学，<strong>NodeUI本季度将对外承接服务</strong>，为保证其他业务部门同学顺利接入，同时也为其他对NodeUI感兴趣的同学提供学习平台，文档建设亟待完善。</p>\n<p>无论你是刚接触 Node 还是 Node 的老司机，都可以贡献出自己的文章（<code>仅限markdown文档格式</code>）。包括不局限：</p>\n<ul>\n<li>NodeUI如何在业务中使用</li>\n<li>NodeUI 服务通信原理</li>\n<li>NodeUI 运维</li>\n<li>fekey 开发工具在 NodeUI 中的使用</li>\n<li>微信授权的那些坑</li>\n<li>Universal Link 流程</li>\n<li>NodeUI 服务运行原理</li>\n<li>线上部署</li>\n<li>监控报警</li>\n<li>守护进程原理</li>\n<li>......</li>\n</ul>\n<p>大家平时使用过程中有任何建议也欢迎提出来，共同改进，建设 NodeUI 生态 ~~</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>各位同学，<strong>NodeUI本季度将对外承接服务</strong>，为保证其他业务部门同学顺利接入，同时也为其他对NodeUI感兴趣的同学提供学习平台，文档建设亟待完善。</p>\n<p>无论你是刚接触 Node 还是 Node 的老司机，都可以贡献出自己的文章（<code>仅限markdown文档格式</code>）。包括不局限：</p>\n<ul>\n<li>NodeUI如何在业务中使用</li>\n<li>NodeUI 服务通信原理</li>\n<li>NodeUI 运维</li>\n<li>fekey 开发工具在 NodeUI 中的使用</li>\n<li>微信授权的那些坑</li>\n<li>Universal Link 流程</li>\n<li>NodeUI 服务运行原理</li>\n<li>线上部署</li>\n<li>监控报警</li>\n<li>守护进程原理</li>\n<li>......</li>\n</ul>\n<p>大家平时使用过程中有任何建议也欢迎提出来，共同改进，建设 NodeUI 生态 ~~</p>\n"},{"title":"Node.js调试","_content":"\n## 线下调试\n    \n### 需求\n\n- http请求断点调试\n- node-ral 向后请求查看\n- 启动调试\n\n\n## 版本\n\n    node v4.2.4\n    Node Inspector v0.12.5\n\n## node-inspector\n\n```\nnpm i -g node-inspector\n\nnpm run debug(node --debug app.js)\n\nnode-inspector --web-port=5006\n\n```\n\n> 建议配合 `supervisor` 使用,支持node 自动重启。\n    \n## devtool\n\n> 建议大家尝试，取代node-inspector\n\n    https://github.com/Jam3/devtool\n\n## 线上—日志\n\n    线上通过日志排查 access nodeui等\n    \n## 远程调试\n\n\n## 错误捕获\n\n```js\n'use strict';\n\nconst Http = require('http');\n\nconst server = Http.createServer((req, res) => {\n  const promise = new Promise((resolve, reject) => {\n    let result = '';\n    req.on('data', (data) => {\n      result += data;\n    });\n\n    req.once('end', () => {\n      const obj = JSON.parse(result);\n      resolve(obj);\n    });\n  });\n\n  promise.then((obj) => {\n    res.writeHead(200);\n    // 这里会报错\n    res.end(obj.foo.bar);\n  }).catch((reason) => {\n    res.writeHead(500);\n    res.end();\n    console.error(reason);\n    // 抛错后退出程序\n    process.abort()\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('listening at http://localhost:8080');\n});\n\n```\n    // post请求\n    curl -X POST http://localhost:8080 -d '{\"Hi\": \"world\"}'","source":"en/docs/faq/debug.md","raw":"title: Node.js调试\n---\n\n## 线下调试\n    \n### 需求\n\n- http请求断点调试\n- node-ral 向后请求查看\n- 启动调试\n\n\n## 版本\n\n    node v4.2.4\n    Node Inspector v0.12.5\n\n## node-inspector\n\n```\nnpm i -g node-inspector\n\nnpm run debug(node --debug app.js)\n\nnode-inspector --web-port=5006\n\n```\n\n> 建议配合 `supervisor` 使用,支持node 自动重启。\n    \n## devtool\n\n> 建议大家尝试，取代node-inspector\n\n    https://github.com/Jam3/devtool\n\n## 线上—日志\n\n    线上通过日志排查 access nodeui等\n    \n## 远程调试\n\n\n## 错误捕获\n\n```js\n'use strict';\n\nconst Http = require('http');\n\nconst server = Http.createServer((req, res) => {\n  const promise = new Promise((resolve, reject) => {\n    let result = '';\n    req.on('data', (data) => {\n      result += data;\n    });\n\n    req.once('end', () => {\n      const obj = JSON.parse(result);\n      resolve(obj);\n    });\n  });\n\n  promise.then((obj) => {\n    res.writeHead(200);\n    // 这里会报错\n    res.end(obj.foo.bar);\n  }).catch((reason) => {\n    res.writeHead(500);\n    res.end();\n    console.error(reason);\n    // 抛错后退出程序\n    process.abort()\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('listening at http://localhost:8080');\n});\n\n```\n    // post请求\n    curl -X POST http://localhost:8080 -d '{\"Hi\": \"world\"}'","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/faq/debug.html","comments":1,"layout":"page","_id":"cjyd4skip000p6lq1rnlxfdlp","content":"<h2 id=\"线下调试\"><a class=\"markdown-anchor\" href=\"#线下调试\">#</a> 线下调试</h2>\n<h3 id=\"需求\"><a class=\"markdown-anchor\" href=\"#需求\">#</a> 需求</h3>\n<ul>\n<li>http请求断点调试</li>\n<li>node-ral 向后请求查看</li>\n<li>启动调试</li>\n</ul>\n<h2 id=\"版本\"><a class=\"markdown-anchor\" href=\"#版本\">#</a> 版本</h2>\n<pre><code>node v4.2.4\nNode Inspector v0.12.5\n</code></pre>\n<h2 id=\"node-inspector\"><a class=\"markdown-anchor\" href=\"#node-inspector\">#</a> node-inspector</h2>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i -g node-inspector</span><br><span class=\"line\"></span><br><span class=\"line\">npm run debug(node --debug app.js)</span><br><span class=\"line\"></span><br><span class=\"line\">node-inspector --web-port=5006</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>建议配合 <code>supervisor</code> 使用,支持node 自动重启。</p>\n</blockquote>\n<h2 id=\"devtool\"><a class=\"markdown-anchor\" href=\"#devtool\">#</a> devtool</h2>\n<blockquote>\n<p>建议大家尝试，取代node-inspector</p>\n</blockquote>\n<pre><code>https://github.com/Jam3/devtool\n</code></pre>\n<h2 id=\"线上日志\"><a class=\"markdown-anchor\" href=\"#线上日志\">#</a> 线上—日志</h2>\n<pre><code>线上通过日志排查 access nodeui等\n</code></pre>\n<h2 id=\"远程调试\"><a class=\"markdown-anchor\" href=\"#远程调试\">#</a> 远程调试</h2>\n<h2 id=\"错误捕获\"><a class=\"markdown-anchor\" href=\"#错误捕获\">#</a> 错误捕获</h2>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = Http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</span><br><span class=\"line\">    req.on(<span class=\"string\">'data'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">      result += data;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    req.once(<span class=\"string\">'end'</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> obj = <span class=\"built_in\">JSON</span>.parse(result);</span><br><span class=\"line\">      resolve(obj);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  promise.then(<span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">200</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 这里会报错</span></span><br><span class=\"line\">    res.end(obj.foo.bar);</span><br><span class=\"line\">  &#125;).catch(<span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">500</span>);</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(reason);</span><br><span class=\"line\">    <span class=\"comment\">// 抛错后退出程序</span></span><br><span class=\"line\">    process.abort()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening at http://localhost:8080'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<pre><code>// post请求\ncurl -X POST http://localhost:8080 -d '{&quot;Hi&quot;: &quot;world&quot;}'</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<h2 id=\"线下调试\"><a class=\"markdown-anchor\" href=\"#线下调试\">#</a> 线下调试</h2>\n<h3 id=\"需求\"><a class=\"markdown-anchor\" href=\"#需求\">#</a> 需求</h3>\n<ul>\n<li>http请求断点调试</li>\n<li>node-ral 向后请求查看</li>\n<li>启动调试</li>\n</ul>\n<h2 id=\"版本\"><a class=\"markdown-anchor\" href=\"#版本\">#</a> 版本</h2>\n<pre><code>node v4.2.4\nNode Inspector v0.12.5\n</code></pre>\n<h2 id=\"node-inspector\"><a class=\"markdown-anchor\" href=\"#node-inspector\">#</a> node-inspector</h2>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i -g node-inspector</span><br><span class=\"line\"></span><br><span class=\"line\">npm run debug(node --debug app.js)</span><br><span class=\"line\"></span><br><span class=\"line\">node-inspector --web-port=5006</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>建议配合 <code>supervisor</code> 使用,支持node 自动重启。</p>\n</blockquote>\n<h2 id=\"devtool\"><a class=\"markdown-anchor\" href=\"#devtool\">#</a> devtool</h2>\n<blockquote>\n<p>建议大家尝试，取代node-inspector</p>\n</blockquote>\n<pre><code>https://github.com/Jam3/devtool\n</code></pre>\n<h2 id=\"线上日志\"><a class=\"markdown-anchor\" href=\"#线上日志\">#</a> 线上—日志</h2>\n<pre><code>线上通过日志排查 access nodeui等\n</code></pre>\n<h2 id=\"远程调试\"><a class=\"markdown-anchor\" href=\"#远程调试\">#</a> 远程调试</h2>\n<h2 id=\"错误捕获\"><a class=\"markdown-anchor\" href=\"#错误捕获\">#</a> 错误捕获</h2>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = Http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</span><br><span class=\"line\">    req.on(<span class=\"string\">'data'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">      result += data;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    req.once(<span class=\"string\">'end'</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> obj = <span class=\"built_in\">JSON</span>.parse(result);</span><br><span class=\"line\">      resolve(obj);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  promise.then(<span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">200</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 这里会报错</span></span><br><span class=\"line\">    res.end(obj.foo.bar);</span><br><span class=\"line\">  &#125;).catch(<span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">500</span>);</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(reason);</span><br><span class=\"line\">    <span class=\"comment\">// 抛错后退出程序</span></span><br><span class=\"line\">    process.abort()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening at http://localhost:8080'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<pre><code>// post请求\ncurl -X POST http://localhost:8080 -d '{&quot;Hi&quot;: &quot;world&quot;}'</code></pre>\n"},{"title":"环境及部署问题汇总","_content":"\n","source":"en/docs/faq/deploy.md","raw":"title: 环境及部署问题汇总\n---\n\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/faq/deploy.html","comments":1,"layout":"page","_id":"cjyd4skir000q6lq19svn3dn4","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"启动失败","_content":"\n```\nFATAL: 17-03-27 15:45:52 [-:-] errno[0] logId[-] uri[-] user[-] refer[-] cookie[-]  [yog-ral] [cluster main][Config] config [/home/map/nodeui/conf/ral] load failed\n\nAssertionError: [online] config error => [server]: expected undefined to be an array\n    at validate (/home/map/nodeui/node_modules/node-ral/lib/config.js:122:45)\n    at /home/map/nodeui/node_modules/node-ral/lib/config.js:141:9\n    at Function._.map._.collect (/home/map/nodeui/node_modules/node-ral/node_modules/underscore/underscore.js:172:24)\n    at loadRawConf (/home/map/nodeui/node_modules/node-ral/lib/config.js:134:7)\n    at Object.load (/home/map/nodeui/node_modules/node-ral/lib/config.js:210:9)\n    at Function.RAL.init (/home/map/nodeui/node_modules/node-ral/lib/ral.js:477:16)\n    at module.exports (/home/map/nodeui/extension/tools/RAL.js:17:9)\n    at /home/map/nodeui/kernel/middlewares/dispatcher/index.js:40:23\n    at Array.forEach (native)\n    at initCommonTools (/home/map/nodeui/kernel/middlewares/dispatcher/index.js:35:15)\n```\n\n这种 `ral` 配置问题通常是因为向后请求模块引用错误。本地开发环境引用 `node-ral` ，生产环境必须用 `yog-ral`。\n\n### node-ral 与 yog-ral 的区别\n\n","source":"en/docs/faq/start.md","raw":"title: 启动失败\n---\n\n```\nFATAL: 17-03-27 15:45:52 [-:-] errno[0] logId[-] uri[-] user[-] refer[-] cookie[-]  [yog-ral] [cluster main][Config] config [/home/map/nodeui/conf/ral] load failed\n\nAssertionError: [online] config error => [server]: expected undefined to be an array\n    at validate (/home/map/nodeui/node_modules/node-ral/lib/config.js:122:45)\n    at /home/map/nodeui/node_modules/node-ral/lib/config.js:141:9\n    at Function._.map._.collect (/home/map/nodeui/node_modules/node-ral/node_modules/underscore/underscore.js:172:24)\n    at loadRawConf (/home/map/nodeui/node_modules/node-ral/lib/config.js:134:7)\n    at Object.load (/home/map/nodeui/node_modules/node-ral/lib/config.js:210:9)\n    at Function.RAL.init (/home/map/nodeui/node_modules/node-ral/lib/ral.js:477:16)\n    at module.exports (/home/map/nodeui/extension/tools/RAL.js:17:9)\n    at /home/map/nodeui/kernel/middlewares/dispatcher/index.js:40:23\n    at Array.forEach (native)\n    at initCommonTools (/home/map/nodeui/kernel/middlewares/dispatcher/index.js:35:15)\n```\n\n这种 `ral` 配置问题通常是因为向后请求模块引用错误。本地开发环境引用 `node-ral` ，生产环境必须用 `yog-ral`。\n\n### node-ral 与 yog-ral 的区别\n\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/faq/start.html","comments":1,"layout":"page","_id":"cjyd4skit000r6lq1s826z88x","content":"<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">FATAL: 17-03-27 15:45:52 [-:-] errno[0] logId[-] uri[-] user[-] refer[-] cookie[-]  [yog-ral] [cluster main][Config] config [/home/map/nodeui/conf/ral] load failed</span><br><span class=\"line\"></span><br><span class=\"line\">AssertionError: [online] config error =&gt; [server]: expected undefined to be an array</span><br><span class=\"line\">    at validate (/home/map/nodeui/node_modules/node-ral/lib/config.js:122:45)</span><br><span class=\"line\">    at /home/map/nodeui/node_modules/node-ral/lib/config.js:141:9</span><br><span class=\"line\">    at Function._.map._.collect (/home/map/nodeui/node_modules/node-ral/node_modules/underscore/underscore.js:172:24)</span><br><span class=\"line\">    at loadRawConf (/home/map/nodeui/node_modules/node-ral/lib/config.js:134:7)</span><br><span class=\"line\">    at Object.load (/home/map/nodeui/node_modules/node-ral/lib/config.js:210:9)</span><br><span class=\"line\">    at Function.RAL.init (/home/map/nodeui/node_modules/node-ral/lib/ral.js:477:16)</span><br><span class=\"line\">    at module.exports (/home/map/nodeui/extension/tools/RAL.js:17:9)</span><br><span class=\"line\">    at /home/map/nodeui/kernel/middlewares/dispatcher/index.js:40:23</span><br><span class=\"line\">    at Array.forEach (native)</span><br><span class=\"line\">    at initCommonTools (/home/map/nodeui/kernel/middlewares/dispatcher/index.js:35:15)</span><br></pre></td></tr></table></figure></p>\n<p>这种 <code>ral</code> 配置问题通常是因为向后请求模块引用错误。本地开发环境引用 <code>node-ral</code> ，生产环境必须用 <code>yog-ral</code>。</p>\n<h3 id=\"node-ral-与-yog-ral-的区别\"><a class=\"markdown-anchor\" href=\"#node-ral-与-yog-ral-的区别\">#</a> node-ral 与 yog-ral 的区别</h3>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">FATAL: 17-03-27 15:45:52 [-:-] errno[0] logId[-] uri[-] user[-] refer[-] cookie[-]  [yog-ral] [cluster main][Config] config [/home/map/nodeui/conf/ral] load failed</span><br><span class=\"line\"></span><br><span class=\"line\">AssertionError: [online] config error =&gt; [server]: expected undefined to be an array</span><br><span class=\"line\">    at validate (/home/map/nodeui/node_modules/node-ral/lib/config.js:122:45)</span><br><span class=\"line\">    at /home/map/nodeui/node_modules/node-ral/lib/config.js:141:9</span><br><span class=\"line\">    at Function._.map._.collect (/home/map/nodeui/node_modules/node-ral/node_modules/underscore/underscore.js:172:24)</span><br><span class=\"line\">    at loadRawConf (/home/map/nodeui/node_modules/node-ral/lib/config.js:134:7)</span><br><span class=\"line\">    at Object.load (/home/map/nodeui/node_modules/node-ral/lib/config.js:210:9)</span><br><span class=\"line\">    at Function.RAL.init (/home/map/nodeui/node_modules/node-ral/lib/ral.js:477:16)</span><br><span class=\"line\">    at module.exports (/home/map/nodeui/extension/tools/RAL.js:17:9)</span><br><span class=\"line\">    at /home/map/nodeui/kernel/middlewares/dispatcher/index.js:40:23</span><br><span class=\"line\">    at Array.forEach (native)</span><br><span class=\"line\">    at initCommonTools (/home/map/nodeui/kernel/middlewares/dispatcher/index.js:35:15)</span><br></pre></td></tr></table></figure></p>\n<p>这种 <code>ral</code> 配置问题通常是因为向后请求模块引用错误。本地开发环境引用 <code>node-ral</code> ，生产环境必须用 <code>yog-ral</code>。</p>\n<h3 id=\"node-ral-与-yog-ral-的区别\"><a class=\"markdown-anchor\" href=\"#node-ral-与-yog-ral-的区别\">#</a> node-ral 与 yog-ral 的区别</h3>\n"},{"title":"微信授权","_content":"\n后端服务通常对微信授权相关接口做了IP限制，我们联调测试时候需要关闭其限制。\n\n### 内网接口\n\n- /hongbao/getmobilebyopenid\n- /hongbao/addmobileopenid\n- /hongbao/updatemobilebyopenid\n\n### 关闭内网限制\n\n    /home/map/odp_cater/app/hongbao/actions/api\n    \n    注释：$this->checkIp = true;\n\n### 附微信授权原理流程图\n\n![wechat](http://younth.coding.me/static/wechat-auth.png)","source":"en/docs/faq/wechat.md","raw":"title: 微信授权\n---\n\n后端服务通常对微信授权相关接口做了IP限制，我们联调测试时候需要关闭其限制。\n\n### 内网接口\n\n- /hongbao/getmobilebyopenid\n- /hongbao/addmobileopenid\n- /hongbao/updatemobilebyopenid\n\n### 关闭内网限制\n\n    /home/map/odp_cater/app/hongbao/actions/api\n    \n    注释：$this->checkIp = true;\n\n### 附微信授权原理流程图\n\n![wechat](http://younth.coding.me/static/wechat-auth.png)","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/faq/wechat.html","comments":1,"layout":"page","_id":"cjyd4skiu000s6lq1k182jn65","content":"<p>后端服务通常对微信授权相关接口做了IP限制，我们联调测试时候需要关闭其限制。</p>\n<h3 id=\"内网接口\"><a class=\"markdown-anchor\" href=\"#内网接口\">#</a> 内网接口</h3>\n<ul>\n<li>/hongbao/getmobilebyopenid</li>\n<li>/hongbao/addmobileopenid</li>\n<li>/hongbao/updatemobilebyopenid</li>\n</ul>\n<h3 id=\"关闭内网限制\"><a class=\"markdown-anchor\" href=\"#关闭内网限制\">#</a> 关闭内网限制</h3>\n<pre><code>/home/map/odp_cater/app/hongbao/actions/api\n\n注释：$this-&gt;checkIp = true;\n</code></pre>\n<h3 id=\"附微信授权原理流程图\"><a class=\"markdown-anchor\" href=\"#附微信授权原理流程图\">#</a> 附微信授权原理流程图</h3>\n<p><img src=\"http://younth.coding.me/static/wechat-auth.png\" alt=\"wechat\"></p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>后端服务通常对微信授权相关接口做了IP限制，我们联调测试时候需要关闭其限制。</p>\n<h3 id=\"内网接口\"><a class=\"markdown-anchor\" href=\"#内网接口\">#</a> 内网接口</h3>\n<ul>\n<li>/hongbao/getmobilebyopenid</li>\n<li>/hongbao/addmobileopenid</li>\n<li>/hongbao/updatemobilebyopenid</li>\n</ul>\n<h3 id=\"关闭内网限制\"><a class=\"markdown-anchor\" href=\"#关闭内网限制\">#</a> 关闭内网限制</h3>\n<pre><code>/home/map/odp_cater/app/hongbao/actions/api\n\n注释：$this-&gt;checkIp = true;\n</code></pre>\n<h3 id=\"附微信授权原理流程图\"><a class=\"markdown-anchor\" href=\"#附微信授权原理流程图\">#</a> 附微信授权原理流程图</h3>\n<p><img src=\"http://younth.coding.me/static/wechat-auth.png\" alt=\"wechat\"></p>\n"},{"title":"维表join","_content":"维表join在大数据中非常常见,通常我们需要在入库时对数据进行过滤和join打宽.\nsylph sql现在已经支持简单的维表join,\n\n### demo\n下面将通过一个demo来演示sylph 的join功能.\n该例子模拟读取实时json数据进行解析取出user_id和ip字段,\n然后计算每个用户每5秒的`count(distinct key)`数,\n接下来和mysql中的users表 进行join取出 name和city。\n最后 Insert into 存储数据到外部\n```sql\ncreate function json_parser as 'ideal.sylph.runner.flink.udf.JsonParser';\ncreate function row_get as 'ideal.sylph.runner.flink.udf.RowGet';\n\ncreate source table topic1(\n    key varchar,\n    value varchar,     -- json\n    event_time bigint\n) with (\n    type = 'ideal.sylph.plugins.flink.source.TestSource'\n);\n\n-- 定义数据流输出位置\ncreate sink table print_table_sink(\n    uid varchar,\n    name varchar,\n    city varchar,\n    cnt long,\n    window_time varchar\n) with (\n    type = 'console',   -- print console\n    other = 'demo001'\n);\n\n-- 定义维表\ncreate batch table users(\n    id varchar,\n    name varchar,\n    city varchar\n) with (\n    type = 'mysql',   -- print console\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false'\n    -- query = 'select * from users where ...'  --可以下推谓词\n);\n\n-- 描述数据流计算过程\ninsert into print_table_sink\nwith tb1 as (\n    select key, row_get(rowline,0) as uid , row_get(rowline,1) as ip, event_time, proctime\n    from topic1 , LATERAL TABLE(json_parser(`value`,'user_id,ip')) as T(rowline) \n),tb2 as (\n    select uid,\n    count(distinct key) as cnt,\n    cast(TUMBLE_START(proctime,INTERVAL '5' SECOND) as varchar)|| '-->' \n    || cast(TUMBLE_END(proctime,INTERVAL '5' SECOND) as varchar) AS start_time\n    from tb1 where uid is not null\n    group by uid,TUMBLE(proctime,INTERVAL '5' SECOND)\n) \nselect tb2.uid, users.name ,users.city, tb2.cnt, tb2.start_time \nfrom tb2 left join users on tb2.uid = users.id\nhaving 1=1\n```\n    \n### 注意事项\n- 1, 维表join时 为了解析方便,请尽量将维表放到右边\n- 2, 只支持left join 和 Inner join(维表在右边时), 详细原因可以参考: [http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#support-matrix-for-joins-in-streaming-queries](join)\n- 3  `on` 只支持and(equals) 例如: `条件1 and 条件2 and 条件3`\n- 4  对于条件只支持equals(`=`) 例如: `on tb1.a1=tb2.id and ...`\n- 5  对于equals条件暂时不支持常量, 例如: `on tb1.a1 = 'sylph'` 目前是不支持的, 原因是涉及到谓词下推问题\n- 6  不支持join where 原因如上 因为涉及到谓词下推问题\n- 7  完整支持 having语句\n\n### 关于维表插件 目前只实现了mysql\n实现非常简单,请参考 sylph-mysql/ideal.sylph.plugins.mysql.MysqlAsyncFunction.java\n如果有用到redis或者别的 可参考这个进行简单实现,或参考`进阶`中开发指南\n\n### 关于缓存问题\nMysqlAsyncFunction 采用LRU缓存策略, 使用的本地缓存. 如果想使用分布式缓存,可以自行修改非常简单.\n\n\n### other\n- 关于json 解析采用的udtf来实现的,总体上因为calcite语法原因 对比hive显得不够优雅\n但在这种方案不影响性能 切非常灵活\n- 上面示例mysql 建表语句如下:\n```mysql\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` varchar(10) NOT NULL,\n  `name` varchar(20) NOT NULL,\n  `city` char(20) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'h123', '123');\nINSERT INTO `users` VALUES ('2', 'p123', '123');\nINSERT INTO `users` VALUES ('4', '小王', 'dikd3939');\nINSERT INTO `users` VALUES ('uid_1', 'test', 'test');\nINSERT INTO `users` VALUES ('uid_5', 'sylph', 'demo');\n``` ","source":"en/docs/intro/batch-join.md","raw":"title: 维表join\n---\n维表join在大数据中非常常见,通常我们需要在入库时对数据进行过滤和join打宽.\nsylph sql现在已经支持简单的维表join,\n\n### demo\n下面将通过一个demo来演示sylph 的join功能.\n该例子模拟读取实时json数据进行解析取出user_id和ip字段,\n然后计算每个用户每5秒的`count(distinct key)`数,\n接下来和mysql中的users表 进行join取出 name和city。\n最后 Insert into 存储数据到外部\n```sql\ncreate function json_parser as 'ideal.sylph.runner.flink.udf.JsonParser';\ncreate function row_get as 'ideal.sylph.runner.flink.udf.RowGet';\n\ncreate source table topic1(\n    key varchar,\n    value varchar,     -- json\n    event_time bigint\n) with (\n    type = 'ideal.sylph.plugins.flink.source.TestSource'\n);\n\n-- 定义数据流输出位置\ncreate sink table print_table_sink(\n    uid varchar,\n    name varchar,\n    city varchar,\n    cnt long,\n    window_time varchar\n) with (\n    type = 'console',   -- print console\n    other = 'demo001'\n);\n\n-- 定义维表\ncreate batch table users(\n    id varchar,\n    name varchar,\n    city varchar\n) with (\n    type = 'mysql',   -- print console\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false'\n    -- query = 'select * from users where ...'  --可以下推谓词\n);\n\n-- 描述数据流计算过程\ninsert into print_table_sink\nwith tb1 as (\n    select key, row_get(rowline,0) as uid , row_get(rowline,1) as ip, event_time, proctime\n    from topic1 , LATERAL TABLE(json_parser(`value`,'user_id,ip')) as T(rowline) \n),tb2 as (\n    select uid,\n    count(distinct key) as cnt,\n    cast(TUMBLE_START(proctime,INTERVAL '5' SECOND) as varchar)|| '-->' \n    || cast(TUMBLE_END(proctime,INTERVAL '5' SECOND) as varchar) AS start_time\n    from tb1 where uid is not null\n    group by uid,TUMBLE(proctime,INTERVAL '5' SECOND)\n) \nselect tb2.uid, users.name ,users.city, tb2.cnt, tb2.start_time \nfrom tb2 left join users on tb2.uid = users.id\nhaving 1=1\n```\n    \n### 注意事项\n- 1, 维表join时 为了解析方便,请尽量将维表放到右边\n- 2, 只支持left join 和 Inner join(维表在右边时), 详细原因可以参考: [http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#support-matrix-for-joins-in-streaming-queries](join)\n- 3  `on` 只支持and(equals) 例如: `条件1 and 条件2 and 条件3`\n- 4  对于条件只支持equals(`=`) 例如: `on tb1.a1=tb2.id and ...`\n- 5  对于equals条件暂时不支持常量, 例如: `on tb1.a1 = 'sylph'` 目前是不支持的, 原因是涉及到谓词下推问题\n- 6  不支持join where 原因如上 因为涉及到谓词下推问题\n- 7  完整支持 having语句\n\n### 关于维表插件 目前只实现了mysql\n实现非常简单,请参考 sylph-mysql/ideal.sylph.plugins.mysql.MysqlAsyncFunction.java\n如果有用到redis或者别的 可参考这个进行简单实现,或参考`进阶`中开发指南\n\n### 关于缓存问题\nMysqlAsyncFunction 采用LRU缓存策略, 使用的本地缓存. 如果想使用分布式缓存,可以自行修改非常简单.\n\n\n### other\n- 关于json 解析采用的udtf来实现的,总体上因为calcite语法原因 对比hive显得不够优雅\n但在这种方案不影响性能 切非常灵活\n- 上面示例mysql 建表语句如下:\n```mysql\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` varchar(10) NOT NULL,\n  `name` varchar(20) NOT NULL,\n  `city` char(20) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'h123', '123');\nINSERT INTO `users` VALUES ('2', 'p123', '123');\nINSERT INTO `users` VALUES ('4', '小王', 'dikd3939');\nINSERT INTO `users` VALUES ('uid_1', 'test', 'test');\nINSERT INTO `users` VALUES ('uid_5', 'sylph', 'demo');\n``` ","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/intro/batch-join.html","comments":1,"layout":"page","_id":"cjyd4skiw000t6lq1p9w00kwc","content":"<p>维表join在大数据中非常常见,通常我们需要在入库时对数据进行过滤和join打宽.\nsylph sql现在已经支持简单的维表join,</p>\n<h3 id=\"demo\"><a class=\"markdown-anchor\" href=\"#demo\">#</a> demo</h3>\n<p>下面将通过一个demo来演示sylph 的join功能.\n该例子模拟读取实时json数据进行解析取出user_id和ip字段,\n然后计算每个用户每5秒的<code>count(distinct key)</code>数,\n接下来和mysql中的users表 进行join取出 name和city。\n最后 Insert into 存储数据到外部\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> json_parser <span class=\"keyword\">as</span> <span class=\"string\">'ideal.sylph.runner.flink.udf.JsonParser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> row_get <span class=\"keyword\">as</span> <span class=\"string\">'ideal.sylph.runner.flink.udf.RowGet'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    <span class=\"keyword\">key</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">value</span> <span class=\"built_in\">varchar</span>,     <span class=\"comment\">-- json</span></span><br><span class=\"line\">    event_time <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'ideal.sylph.plugins.flink.source.TestSource'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 定义数据流输出位置</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> print_table_sink(</span><br><span class=\"line\">    uid <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    city <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    cnt <span class=\"keyword\">long</span>,</span><br><span class=\"line\">    window_time <span class=\"built_in\">varchar</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'console'</span>,   <span class=\"comment\">-- print console</span></span><br><span class=\"line\">    other = <span class=\"string\">'demo001'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 定义维表</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> batch <span class=\"keyword\">table</span> <span class=\"keyword\">users</span>(</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    city <span class=\"built_in\">varchar</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- print console</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span></span><br><span class=\"line\">    <span class=\"comment\">-- query = 'select * from users where ...'  --可以下推谓词</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 描述数据流计算过程</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> print_table_sink</span><br><span class=\"line\"><span class=\"keyword\">with</span> tb1 <span class=\"keyword\">as</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> <span class=\"keyword\">key</span>, row_get(rowline,<span class=\"number\">0</span>) <span class=\"keyword\">as</span> uid , row_get(rowline,<span class=\"number\">1</span>) <span class=\"keyword\">as</span> ip, event_time, proctime</span><br><span class=\"line\">    <span class=\"keyword\">from</span> topic1 , LATERAL <span class=\"keyword\">TABLE</span>(json_parser(<span class=\"string\">`value`</span>,<span class=\"string\">'user_id,ip'</span>)) <span class=\"keyword\">as</span> T(rowline) </span><br><span class=\"line\">),tb2 <span class=\"keyword\">as</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> uid,</span><br><span class=\"line\">    <span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> <span class=\"keyword\">key</span>) <span class=\"keyword\">as</span> cnt,</span><br><span class=\"line\">    <span class=\"keyword\">cast</span>(TUMBLE_START(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>)|| <span class=\"string\">'--&gt;'</span> </span><br><span class=\"line\">    || <span class=\"keyword\">cast</span>(TUMBLE_END(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>) <span class=\"keyword\">AS</span> start_time</span><br><span class=\"line\">    <span class=\"keyword\">from</span> tb1 <span class=\"keyword\">where</span> uid <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> uid,TUMBLE(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>)</span><br><span class=\"line\">) </span><br><span class=\"line\"><span class=\"keyword\">select</span> tb2.uid, users.name ,users.city, tb2.cnt, tb2.start_time </span><br><span class=\"line\"><span class=\"keyword\">from</span> tb2 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> <span class=\"keyword\">users</span> <span class=\"keyword\">on</span> tb2.uid = users.id</span><br><span class=\"line\"><span class=\"keyword\">having</span> <span class=\"number\">1</span>=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意事项\"><a class=\"markdown-anchor\" href=\"#注意事项\">#</a> 注意事项</h3>\n<ul>\n<li>1, 维表join时 为了解析方便,请尽量将维表放到右边</li>\n<li>2, 只支持left join 和 Inner join(维表在右边时), 详细原因可以参考: <a href=\"join\">http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#support-matrix-for-joins-in-streaming-queries</a></li>\n<li>3  <code>on</code> 只支持and(equals) 例如: <code>条件1 and 条件2 and 条件3</code></li>\n<li>4  对于条件只支持equals(<code>=</code>) 例如: <code>on tb1.a1=tb2.id and ...</code></li>\n<li>5  对于equals条件暂时不支持常量, 例如: <code>on tb1.a1 = 'sylph'</code> 目前是不支持的, 原因是涉及到谓词下推问题</li>\n<li>6  不支持join where 原因如上 因为涉及到谓词下推问题</li>\n<li>7  完整支持 having语句</li>\n</ul>\n<h3 id=\"关于维表插件-目前只实现了mysql\"><a class=\"markdown-anchor\" href=\"#关于维表插件-目前只实现了mysql\">#</a> 关于维表插件 目前只实现了mysql</h3>\n<p>实现非常简单,请参考 sylph-mysql/ideal.sylph.plugins.mysql.MysqlAsyncFunction.java\n如果有用到redis或者别的 可参考这个进行简单实现,或参考<code>进阶</code>中开发指南</p>\n<h3 id=\"关于缓存问题\"><a class=\"markdown-anchor\" href=\"#关于缓存问题\">#</a> 关于缓存问题</h3>\n<p>MysqlAsyncFunction 采用LRU缓存策略, 使用的本地缓存. 如果想使用分布式缓存,可以自行修改非常简单.</p>\n<h3 id=\"other\"><a class=\"markdown-anchor\" href=\"#other\">#</a> other</h3>\n<ul>\n<li>关于json 解析采用的udtf来实现的,总体上因为calcite语法原因 对比hive显得不够优雅\n但在这种方案不影响性能 切非常灵活</li>\n<li>上面示例mysql 建表语句如下:</li>\n</ul>\n<pre><code class=\"language-mysql\">-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` varchar(10) NOT NULL,\n  `name` varchar(20) NOT NULL,\n  `city` char(20) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'h123', '123');\nINSERT INTO `users` VALUES ('2', 'p123', '123');\nINSERT INTO `users` VALUES ('4', '小王', 'dikd3939');\nINSERT INTO `users` VALUES ('uid_1', 'test', 'test');\nINSERT INTO `users` VALUES ('uid_5', 'sylph', 'demo');\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>维表join在大数据中非常常见,通常我们需要在入库时对数据进行过滤和join打宽.\nsylph sql现在已经支持简单的维表join,</p>\n<h3 id=\"demo\"><a class=\"markdown-anchor\" href=\"#demo\">#</a> demo</h3>\n<p>下面将通过一个demo来演示sylph 的join功能.\n该例子模拟读取实时json数据进行解析取出user_id和ip字段,\n然后计算每个用户每5秒的<code>count(distinct key)</code>数,\n接下来和mysql中的users表 进行join取出 name和city。\n最后 Insert into 存储数据到外部\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> json_parser <span class=\"keyword\">as</span> <span class=\"string\">'ideal.sylph.runner.flink.udf.JsonParser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> row_get <span class=\"keyword\">as</span> <span class=\"string\">'ideal.sylph.runner.flink.udf.RowGet'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    <span class=\"keyword\">key</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">value</span> <span class=\"built_in\">varchar</span>,     <span class=\"comment\">-- json</span></span><br><span class=\"line\">    event_time <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'ideal.sylph.plugins.flink.source.TestSource'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 定义数据流输出位置</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> print_table_sink(</span><br><span class=\"line\">    uid <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    city <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    cnt <span class=\"keyword\">long</span>,</span><br><span class=\"line\">    window_time <span class=\"built_in\">varchar</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'console'</span>,   <span class=\"comment\">-- print console</span></span><br><span class=\"line\">    other = <span class=\"string\">'demo001'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 定义维表</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> batch <span class=\"keyword\">table</span> <span class=\"keyword\">users</span>(</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    city <span class=\"built_in\">varchar</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- print console</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span></span><br><span class=\"line\">    <span class=\"comment\">-- query = 'select * from users where ...'  --可以下推谓词</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 描述数据流计算过程</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> print_table_sink</span><br><span class=\"line\"><span class=\"keyword\">with</span> tb1 <span class=\"keyword\">as</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> <span class=\"keyword\">key</span>, row_get(rowline,<span class=\"number\">0</span>) <span class=\"keyword\">as</span> uid , row_get(rowline,<span class=\"number\">1</span>) <span class=\"keyword\">as</span> ip, event_time, proctime</span><br><span class=\"line\">    <span class=\"keyword\">from</span> topic1 , LATERAL <span class=\"keyword\">TABLE</span>(json_parser(<span class=\"string\">`value`</span>,<span class=\"string\">'user_id,ip'</span>)) <span class=\"keyword\">as</span> T(rowline) </span><br><span class=\"line\">),tb2 <span class=\"keyword\">as</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> uid,</span><br><span class=\"line\">    <span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> <span class=\"keyword\">key</span>) <span class=\"keyword\">as</span> cnt,</span><br><span class=\"line\">    <span class=\"keyword\">cast</span>(TUMBLE_START(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>)|| <span class=\"string\">'--&gt;'</span> </span><br><span class=\"line\">    || <span class=\"keyword\">cast</span>(TUMBLE_END(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>) <span class=\"keyword\">AS</span> start_time</span><br><span class=\"line\">    <span class=\"keyword\">from</span> tb1 <span class=\"keyword\">where</span> uid <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> uid,TUMBLE(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>)</span><br><span class=\"line\">) </span><br><span class=\"line\"><span class=\"keyword\">select</span> tb2.uid, users.name ,users.city, tb2.cnt, tb2.start_time </span><br><span class=\"line\"><span class=\"keyword\">from</span> tb2 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> <span class=\"keyword\">users</span> <span class=\"keyword\">on</span> tb2.uid = users.id</span><br><span class=\"line\"><span class=\"keyword\">having</span> <span class=\"number\">1</span>=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意事项\"><a class=\"markdown-anchor\" href=\"#注意事项\">#</a> 注意事项</h3>\n<ul>\n<li>1, 维表join时 为了解析方便,请尽量将维表放到右边</li>\n<li>2, 只支持left join 和 Inner join(维表在右边时), 详细原因可以参考: <a href=\"join\">http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#support-matrix-for-joins-in-streaming-queries</a></li>\n<li>3  <code>on</code> 只支持and(equals) 例如: <code>条件1 and 条件2 and 条件3</code></li>\n<li>4  对于条件只支持equals(<code>=</code>) 例如: <code>on tb1.a1=tb2.id and ...</code></li>\n<li>5  对于equals条件暂时不支持常量, 例如: <code>on tb1.a1 = 'sylph'</code> 目前是不支持的, 原因是涉及到谓词下推问题</li>\n<li>6  不支持join where 原因如上 因为涉及到谓词下推问题</li>\n<li>7  完整支持 having语句</li>\n</ul>\n<h3 id=\"关于维表插件-目前只实现了mysql\"><a class=\"markdown-anchor\" href=\"#关于维表插件-目前只实现了mysql\">#</a> 关于维表插件 目前只实现了mysql</h3>\n<p>实现非常简单,请参考 sylph-mysql/ideal.sylph.plugins.mysql.MysqlAsyncFunction.java\n如果有用到redis或者别的 可参考这个进行简单实现,或参考<code>进阶</code>中开发指南</p>\n<h3 id=\"关于缓存问题\"><a class=\"markdown-anchor\" href=\"#关于缓存问题\">#</a> 关于缓存问题</h3>\n<p>MysqlAsyncFunction 采用LRU缓存策略, 使用的本地缓存. 如果想使用分布式缓存,可以自行修改非常简单.</p>\n<h3 id=\"other\"><a class=\"markdown-anchor\" href=\"#other\">#</a> other</h3>\n<ul>\n<li>关于json 解析采用的udtf来实现的,总体上因为calcite语法原因 对比hive显得不够优雅\n但在这种方案不影响性能 切非常灵活</li>\n<li>上面示例mysql 建表语句如下:</li>\n</ul>\n<pre><code class=\"language-mysql\">-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` varchar(10) NOT NULL,\n  `name` varchar(20) NOT NULL,\n  `city` char(20) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'h123', '123');\nINSERT INTO `users` VALUES ('2', 'p123', '123');\nINSERT INTO `users` VALUES ('4', '小王', 'dikd3939');\nINSERT INTO `users` VALUES ('uid_1', 'test', 'test');\nINSERT INTO `users` VALUES ('uid_5', 'sylph', 'demo');\n</code></pre>\n"},{"title":"ETL 任务介绍","_content":"\nstreamSql描述流计算非常简单快捷,但是某些时候有些业务逻辑不便于sql化, 也不需要用到window等复杂机制\n需要通过代码实现更复杂的数据数据处理,但希望整个数据流处理变的简单。那么这时使用流式ETL是非常合适的\n\n### node\nsylph对etl过程进行如下三个环节(node)抽象,将一切数据流活动都用如下三个环节表示,并通过`箭头`表示数据流向\n通过一个flow来描述整个流计算过程\n- source\n    (该算子实现如何将数据流接入系统)\n- transform\n    (该算子实现如何将数据流进行转换)\n- sink\n    (该算子实现如何将数据流输到外部系统中)\n    \n### flow\n![job_flow]\n\n如上图通过 flow描述了一个实时etl过程,实例为: kafka->业务处理->hdfs\n\n[job_flow]: ../../../images/sylph/job_flow.png","source":"en/docs/intro/etl.md","raw":"title: ETL 任务介绍\n---\n\nstreamSql描述流计算非常简单快捷,但是某些时候有些业务逻辑不便于sql化, 也不需要用到window等复杂机制\n需要通过代码实现更复杂的数据数据处理,但希望整个数据流处理变的简单。那么这时使用流式ETL是非常合适的\n\n### node\nsylph对etl过程进行如下三个环节(node)抽象,将一切数据流活动都用如下三个环节表示,并通过`箭头`表示数据流向\n通过一个flow来描述整个流计算过程\n- source\n    (该算子实现如何将数据流接入系统)\n- transform\n    (该算子实现如何将数据流进行转换)\n- sink\n    (该算子实现如何将数据流输到外部系统中)\n    \n### flow\n![job_flow]\n\n如上图通过 flow描述了一个实时etl过程,实例为: kafka->业务处理->hdfs\n\n[job_flow]: ../../../images/sylph/job_flow.png","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/intro/etl.html","comments":1,"layout":"page","_id":"cjyd4skix000u6lq1sgz5cxni","content":"<p>streamSql描述流计算非常简单快捷,但是某些时候有些业务逻辑不便于sql化, 也不需要用到window等复杂机制\n需要通过代码实现更复杂的数据数据处理,但希望整个数据流处理变的简单。那么这时使用流式ETL是非常合适的</p>\n<h3 id=\"node\"><a class=\"markdown-anchor\" href=\"#node\">#</a> node</h3>\n<p>sylph对etl过程进行如下三个环节(node)抽象,将一切数据流活动都用如下三个环节表示,并通过<code>箭头</code>表示数据流向\n通过一个flow来描述整个流计算过程</p>\n<ul>\n<li>source\n(该算子实现如何将数据流接入系统)</li>\n<li>transform\n(该算子实现如何将数据流进行转换)</li>\n<li>sink\n(该算子实现如何将数据流输到外部系统中)</li>\n</ul>\n<h3 id=\"flow\"><a class=\"markdown-anchor\" href=\"#flow\">#</a> flow</h3>\n<p><img src=\"../../../images/sylph/job_flow.png\" alt=\"job_flow\"></p>\n<p>如上图通过 flow描述了一个实时etl过程,实例为: kafka-&gt;业务处理-&gt;hdfs</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>streamSql描述流计算非常简单快捷,但是某些时候有些业务逻辑不便于sql化, 也不需要用到window等复杂机制\n需要通过代码实现更复杂的数据数据处理,但希望整个数据流处理变的简单。那么这时使用流式ETL是非常合适的</p>\n<h3 id=\"node\"><a class=\"markdown-anchor\" href=\"#node\">#</a> node</h3>\n<p>sylph对etl过程进行如下三个环节(node)抽象,将一切数据流活动都用如下三个环节表示,并通过<code>箭头</code>表示数据流向\n通过一个flow来描述整个流计算过程</p>\n<ul>\n<li>source\n(该算子实现如何将数据流接入系统)</li>\n<li>transform\n(该算子实现如何将数据流进行转换)</li>\n<li>sink\n(该算子实现如何将数据流输到外部系统中)</li>\n</ul>\n<h3 id=\"flow\"><a class=\"markdown-anchor\" href=\"#flow\">#</a> flow</h3>\n<p><img src=\"../../../images/sylph/job_flow.png\" alt=\"job_flow\"></p>\n<p>如上图通过 flow描述了一个实时etl过程,实例为: kafka-&gt;业务处理-&gt;hdfs</p>\n"},{"title":"SYLPH 是什么?","_content":"\n**SYLPH 是一个用于实时流计算的平台,核心是通过工作流描述构建分布式流计算应用程序。**,SYLPH是一套完整的解决方案，主要包括：\n\n- 开发工具：`webUI`, 定义streamSql或streamETl任务\n- 运行时：基于`spark2.x`及`flink1.5+` , 依赖`hdfs`和`yarn`\n- pipline插件扩展: `java8`, 按需实现`source`,`transform`,`sink`\n- 基础运维：在`webUI`完成任务创建后一键部署上线,无需人工部署,整个分布式程序由sylph进行管理\n- 运行分析: 在sylph`webUI` 上面即可看到任务运行情况,不再需要打隧道查看yarn任务\n\n\n## 设计原则\n\n- 利用插件系统分离**配置与实现**\n- 奉行『**约定优于配置**』，按照[一套统一的约定]进行应用开发，从开发工具，到目录结构。\n\n## 特性\n\n- 快速完成实时计算任务：StreamSql\n- 灵活性: 可以简单自主定制 pipeline节点插件\n- 便捷的部署：自动重启，一键上线到yarn\n- 简单的运维：日志 监控\n\n## 什么样的场景适合用SYLPH\n\n目前SYLPH的定位主要是`实时etl数据处理能力`及`实时流计算`。基于这两大能力，SYLPH有自己的特定应用场景。主要如下：\n\n- 快速实验流计算\n- 管理流计算任务\n","source":"en/docs/intro/index.md","raw":"title: SYLPH 是什么?\n---\n\n**SYLPH 是一个用于实时流计算的平台,核心是通过工作流描述构建分布式流计算应用程序。**,SYLPH是一套完整的解决方案，主要包括：\n\n- 开发工具：`webUI`, 定义streamSql或streamETl任务\n- 运行时：基于`spark2.x`及`flink1.5+` , 依赖`hdfs`和`yarn`\n- pipline插件扩展: `java8`, 按需实现`source`,`transform`,`sink`\n- 基础运维：在`webUI`完成任务创建后一键部署上线,无需人工部署,整个分布式程序由sylph进行管理\n- 运行分析: 在sylph`webUI` 上面即可看到任务运行情况,不再需要打隧道查看yarn任务\n\n\n## 设计原则\n\n- 利用插件系统分离**配置与实现**\n- 奉行『**约定优于配置**』，按照[一套统一的约定]进行应用开发，从开发工具，到目录结构。\n\n## 特性\n\n- 快速完成实时计算任务：StreamSql\n- 灵活性: 可以简单自主定制 pipeline节点插件\n- 便捷的部署：自动重启，一键上线到yarn\n- 简单的运维：日志 监控\n\n## 什么样的场景适合用SYLPH\n\n目前SYLPH的定位主要是`实时etl数据处理能力`及`实时流计算`。基于这两大能力，SYLPH有自己的特定应用场景。主要如下：\n\n- 快速实验流计算\n- 管理流计算任务\n","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/intro/index.html","comments":1,"layout":"page","_id":"cjyd4skiy000v6lq116wr5fca","content":"<p><strong>SYLPH 是一个用于实时流计算的平台,核心是通过工作流描述构建分布式流计算应用程序。</strong>,SYLPH是一套完整的解决方案，主要包括：</p>\n<ul>\n<li>开发工具：<code>webUI</code>, 定义streamSql或streamETl任务</li>\n<li>运行时：基于<code>spark2.x</code>及<code>flink1.5+</code> , 依赖<code>hdfs</code>和<code>yarn</code></li>\n<li>pipline插件扩展: <code>java8</code>, 按需实现<code>source</code>,<code>transform</code>,<code>sink</code></li>\n<li>基础运维：在<code>webUI</code>完成任务创建后一键部署上线,无需人工部署,整个分布式程序由sylph进行管理</li>\n<li>运行分析: 在sylph<code>webUI</code> 上面即可看到任务运行情况,不再需要打隧道查看yarn任务</li>\n</ul>\n<h2 id=\"设计原则\"><a class=\"markdown-anchor\" href=\"#设计原则\">#</a> 设计原则</h2>\n<ul>\n<li>利用插件系统分离<strong>配置与实现</strong></li>\n<li>奉行『<strong>约定优于配置</strong>』，按照[一套统一的约定]进行应用开发，从开发工具，到目录结构。</li>\n</ul>\n<h2 id=\"特性\"><a class=\"markdown-anchor\" href=\"#特性\">#</a> 特性</h2>\n<ul>\n<li>快速完成实时计算任务：StreamSql</li>\n<li>灵活性: 可以简单自主定制 pipeline节点插件</li>\n<li>便捷的部署：自动重启，一键上线到yarn</li>\n<li>简单的运维：日志 监控</li>\n</ul>\n<h2 id=\"什么样的场景适合用sylph\"><a class=\"markdown-anchor\" href=\"#什么样的场景适合用sylph\">#</a> 什么样的场景适合用SYLPH</h2>\n<p>目前SYLPH的定位主要是<code>实时etl数据处理能力</code>及<code>实时流计算</code>。基于这两大能力，SYLPH有自己的特定应用场景。主要如下：</p>\n<ul>\n<li>快速实验流计算</li>\n<li>管理流计算任务</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p><strong>SYLPH 是一个用于实时流计算的平台,核心是通过工作流描述构建分布式流计算应用程序。</strong>,SYLPH是一套完整的解决方案，主要包括：</p>\n<ul>\n<li>开发工具：<code>webUI</code>, 定义streamSql或streamETl任务</li>\n<li>运行时：基于<code>spark2.x</code>及<code>flink1.5+</code> , 依赖<code>hdfs</code>和<code>yarn</code></li>\n<li>pipline插件扩展: <code>java8</code>, 按需实现<code>source</code>,<code>transform</code>,<code>sink</code></li>\n<li>基础运维：在<code>webUI</code>完成任务创建后一键部署上线,无需人工部署,整个分布式程序由sylph进行管理</li>\n<li>运行分析: 在sylph<code>webUI</code> 上面即可看到任务运行情况,不再需要打隧道查看yarn任务</li>\n</ul>\n<h2 id=\"设计原则\"><a class=\"markdown-anchor\" href=\"#设计原则\">#</a> 设计原则</h2>\n<ul>\n<li>利用插件系统分离<strong>配置与实现</strong></li>\n<li>奉行『<strong>约定优于配置</strong>』，按照[一套统一的约定]进行应用开发，从开发工具，到目录结构。</li>\n</ul>\n<h2 id=\"特性\"><a class=\"markdown-anchor\" href=\"#特性\">#</a> 特性</h2>\n<ul>\n<li>快速完成实时计算任务：StreamSql</li>\n<li>灵活性: 可以简单自主定制 pipeline节点插件</li>\n<li>便捷的部署：自动重启，一键上线到yarn</li>\n<li>简单的运维：日志 监控</li>\n</ul>\n<h2 id=\"什么样的场景适合用sylph\"><a class=\"markdown-anchor\" href=\"#什么样的场景适合用sylph\">#</a> 什么样的场景适合用SYLPH</h2>\n<p>目前SYLPH的定位主要是<code>实时etl数据处理能力</code>及<code>实时流计算</code>。基于这两大能力，SYLPH有自己的特定应用场景。主要如下：</p>\n<ul>\n<li>快速实验流计算</li>\n<li>管理流计算任务</li>\n</ul>\n"},{"title":"快速入门","_content":"\n下面将以StreamSql为实例，一步步地搭建出一个 分布式流计算应用，让你能快速的入门 SYLPH。\n\n> StreamSql是完全通过类sql来描述整个流计算的过程。主要需要描述: 数据源如何接入、如何计算、如何输出到外部存储; \n例如计算每分钟的pv; 每5秒更新一次最近一分钟的uv。\n\n### demo1\n下面例子演示将kafka topic `TP_A_1,TP_A_2`的数据实时写入mysql表`mysql_table_sink`中\n\n**注意: mysql中表`mysql_table_sink`需要提前自行创建好,并且字段类型要和实际兼容**\n```sql\n-- 定义数据流接入 \ncreate source table topic1(\n    _topic varchar,\n    _key varchar,\n    _message varchar,\n    _partition integer,\n    _offset bigint\n) with (\n    type = 'kafka',\n    kafka_topic = 'TP_A_1,TP_A_2',\n    \"auto.offset.reset\" = latest,\n    kafka_broker = 'localhost:9092',\n    kafka_group_id = 'streamSql_test1'\n);\n-- 定义数据流输出位置\ncreate sink table mysql_table_sink(\n    a1 varchar,\n    a2 varchar,\n    event_time bigint\n) with (\n    type = 'mysql',   -- ideal.sylph.plugins.flink.sink.MysqlSink.java\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false',\n    query = 'insert into mysql_table_sink values(${0},${1},${2})'\n);\n-- 描述数据流计算过程\ninsert into mysql_table_sink\nselect _topic,`_message`,cast(_offset as bigint) from topic1 where _key is not null\n```\n\n### demo2\n下面的例子 演示如何计算topic `TP_A_1`每分钟的uv\n```sql\ncreate source table topic1(\n    _topic varchar,\n    _key varchar,\n    _message varchar,\n    _partition integer,\n    _offset bigint\n) with (\n    type = 'kafka',\n    kafka_topic = 'TP_A_1',\n    \"auto.offset.reset\" = latest,\n    kafka_broker = 'localhost:9092',\n    kafka_group_id = 'streamSql_test1'\n);\n\ncreate sink table mysql_uv_table_sink(\n    user_id varchar,\n    uv bigint,\n    cnt_time date\n) with (\n    type = 'mysql',   -- ideal.sylph.plugins.flink.sink.MysqlSink.java\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false',\n    query = 'insert into mysql_uv_table_sink values(${0},${1},${2})'\n);\n\nwith tb13 as (SELECT proctime\n    ,row_get(rowline,0)as user_id\n    FROM topic1, LATERAL TABLE(json_parser(_message,'user_id')) as T(rowline) \n    where cast(row_get(rowline,0) as varchar) is not null\n)\ninsert into mysql_uv_table_sink\nselect \nuser_id,\ncount(distinct user_id) as uv\n,TUMBLE_START(proctime,INTERVAL '60' SECOND) AS window_start \nFROM tb13 GROUP BY user_id,TUMBLE(proctime,INTERVAL '60' SECOND)\n```\n\n### strteamSql设计器\n![strteamSql]\n\n[strteamSql]: ../../../images/sylph/strteam_sql.png","source":"en/docs/intro/quickstart.md","raw":"title: 快速入门 \n---\n\n下面将以StreamSql为实例，一步步地搭建出一个 分布式流计算应用，让你能快速的入门 SYLPH。\n\n> StreamSql是完全通过类sql来描述整个流计算的过程。主要需要描述: 数据源如何接入、如何计算、如何输出到外部存储; \n例如计算每分钟的pv; 每5秒更新一次最近一分钟的uv。\n\n### demo1\n下面例子演示将kafka topic `TP_A_1,TP_A_2`的数据实时写入mysql表`mysql_table_sink`中\n\n**注意: mysql中表`mysql_table_sink`需要提前自行创建好,并且字段类型要和实际兼容**\n```sql\n-- 定义数据流接入 \ncreate source table topic1(\n    _topic varchar,\n    _key varchar,\n    _message varchar,\n    _partition integer,\n    _offset bigint\n) with (\n    type = 'kafka',\n    kafka_topic = 'TP_A_1,TP_A_2',\n    \"auto.offset.reset\" = latest,\n    kafka_broker = 'localhost:9092',\n    kafka_group_id = 'streamSql_test1'\n);\n-- 定义数据流输出位置\ncreate sink table mysql_table_sink(\n    a1 varchar,\n    a2 varchar,\n    event_time bigint\n) with (\n    type = 'mysql',   -- ideal.sylph.plugins.flink.sink.MysqlSink.java\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false',\n    query = 'insert into mysql_table_sink values(${0},${1},${2})'\n);\n-- 描述数据流计算过程\ninsert into mysql_table_sink\nselect _topic,`_message`,cast(_offset as bigint) from topic1 where _key is not null\n```\n\n### demo2\n下面的例子 演示如何计算topic `TP_A_1`每分钟的uv\n```sql\ncreate source table topic1(\n    _topic varchar,\n    _key varchar,\n    _message varchar,\n    _partition integer,\n    _offset bigint\n) with (\n    type = 'kafka',\n    kafka_topic = 'TP_A_1',\n    \"auto.offset.reset\" = latest,\n    kafka_broker = 'localhost:9092',\n    kafka_group_id = 'streamSql_test1'\n);\n\ncreate sink table mysql_uv_table_sink(\n    user_id varchar,\n    uv bigint,\n    cnt_time date\n) with (\n    type = 'mysql',   -- ideal.sylph.plugins.flink.sink.MysqlSink.java\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false',\n    query = 'insert into mysql_uv_table_sink values(${0},${1},${2})'\n);\n\nwith tb13 as (SELECT proctime\n    ,row_get(rowline,0)as user_id\n    FROM topic1, LATERAL TABLE(json_parser(_message,'user_id')) as T(rowline) \n    where cast(row_get(rowline,0) as varchar) is not null\n)\ninsert into mysql_uv_table_sink\nselect \nuser_id,\ncount(distinct user_id) as uv\n,TUMBLE_START(proctime,INTERVAL '60' SECOND) AS window_start \nFROM tb13 GROUP BY user_id,TUMBLE(proctime,INTERVAL '60' SECOND)\n```\n\n### strteamSql设计器\n![strteamSql]\n\n[strteamSql]: ../../../images/sylph/strteam_sql.png","date":"2019-07-21T11:14:44.068Z","updated":"2019-07-06T12:37:40.000Z","path":"en/docs/intro/quickstart.html","comments":1,"layout":"page","_id":"cjyd4skj0000w6lq1srwr9vl5","content":"<p>下面将以StreamSql为实例，一步步地搭建出一个 分布式流计算应用，让你能快速的入门 SYLPH。</p>\n<blockquote>\n<p>StreamSql是完全通过类sql来描述整个流计算的过程。主要需要描述: 数据源如何接入、如何计算、如何输出到外部存储;\n例如计算每分钟的pv; 每5秒更新一次最近一分钟的uv。</p>\n</blockquote>\n<h3 id=\"demo1\"><a class=\"markdown-anchor\" href=\"#demo1\">#</a> demo1</h3>\n<p>下面例子演示将kafka topic <code>TP_A_1,TP_A_2</code>的数据实时写入mysql表<code>mysql_table_sink</code>中</p>\n<p><strong>注意: mysql中表<code>mysql_table_sink</code>需要提前自行创建好,并且字段类型要和实际兼容</strong>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 定义数据流接入 </span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    _topic <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _key <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _message <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _partition <span class=\"built_in\">integer</span>,</span><br><span class=\"line\">    _offset <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">    kafka_topic = <span class=\"string\">'TP_A_1,TP_A_2'</span>,</span><br><span class=\"line\">    <span class=\"string\">\"auto.offset.reset\"</span> = latest,</span><br><span class=\"line\">    kafka_broker = <span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">    kafka_group_id = <span class=\"string\">'streamSql_test1'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">-- 定义数据流输出位置</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> mysql_table_sink(</span><br><span class=\"line\">    a1 <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    a2 <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    event_time <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- ideal.sylph.plugins.flink.sink.MysqlSink.java</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">query</span> = <span class=\"string\">'insert into mysql_table_sink values($&#123;0&#125;,$&#123;1&#125;,$&#123;2&#125;)'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">-- 描述数据流计算过程</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> mysql_table_sink</span><br><span class=\"line\"><span class=\"keyword\">select</span> _topic,<span class=\"string\">`_message`</span>,<span class=\"keyword\">cast</span>(_offset <span class=\"keyword\">as</span> <span class=\"built_in\">bigint</span>) <span class=\"keyword\">from</span> topic1 <span class=\"keyword\">where</span> _key <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"demo2\"><a class=\"markdown-anchor\" href=\"#demo2\">#</a> demo2</h3>\n<p>下面的例子 演示如何计算topic <code>TP_A_1</code>每分钟的uv\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    _topic <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _key <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _message <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _partition <span class=\"built_in\">integer</span>,</span><br><span class=\"line\">    _offset <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">    kafka_topic = <span class=\"string\">'TP_A_1'</span>,</span><br><span class=\"line\">    <span class=\"string\">\"auto.offset.reset\"</span> = latest,</span><br><span class=\"line\">    kafka_broker = <span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">    kafka_group_id = <span class=\"string\">'streamSql_test1'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> mysql_uv_table_sink(</span><br><span class=\"line\">    user_id <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    uv <span class=\"built_in\">bigint</span>,</span><br><span class=\"line\">    cnt_time <span class=\"built_in\">date</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- ideal.sylph.plugins.flink.sink.MysqlSink.java</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">query</span> = <span class=\"string\">'insert into mysql_uv_table_sink values($&#123;0&#125;,$&#123;1&#125;,$&#123;2&#125;)'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">with tb13 as (<span class=\"keyword\">SELECT</span> proctime</span><br><span class=\"line\">    ,row_get(rowline,<span class=\"number\">0</span>)<span class=\"keyword\">as</span> user_id</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> topic1, LATERAL <span class=\"keyword\">TABLE</span>(json_parser(_message,<span class=\"string\">'user_id'</span>)) <span class=\"keyword\">as</span> T(rowline) </span><br><span class=\"line\">    <span class=\"keyword\">where</span> <span class=\"keyword\">cast</span>(row_get(rowline,<span class=\"number\">0</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>) <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> mysql_uv_table_sink</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">user_id,</span><br><span class=\"line\"><span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> user_id) <span class=\"keyword\">as</span> uv</span><br><span class=\"line\">,TUMBLE_START(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'60'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">AS</span> window_start </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> tb13 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> user_id,TUMBLE(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'60'</span> <span class=\"keyword\">SECOND</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"strteamsql设计器\"><a class=\"markdown-anchor\" href=\"#strteamsql设计器\">#</a> strteamSql设计器</h3>\n<p><img src=\"../../../images/sylph/strteam_sql.png\" alt=\"strteamSql\"></p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>下面将以StreamSql为实例，一步步地搭建出一个 分布式流计算应用，让你能快速的入门 SYLPH。</p>\n<blockquote>\n<p>StreamSql是完全通过类sql来描述整个流计算的过程。主要需要描述: 数据源如何接入、如何计算、如何输出到外部存储;\n例如计算每分钟的pv; 每5秒更新一次最近一分钟的uv。</p>\n</blockquote>\n<h3 id=\"demo1\"><a class=\"markdown-anchor\" href=\"#demo1\">#</a> demo1</h3>\n<p>下面例子演示将kafka topic <code>TP_A_1,TP_A_2</code>的数据实时写入mysql表<code>mysql_table_sink</code>中</p>\n<p><strong>注意: mysql中表<code>mysql_table_sink</code>需要提前自行创建好,并且字段类型要和实际兼容</strong>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 定义数据流接入 </span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    _topic <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _key <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _message <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _partition <span class=\"built_in\">integer</span>,</span><br><span class=\"line\">    _offset <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">    kafka_topic = <span class=\"string\">'TP_A_1,TP_A_2'</span>,</span><br><span class=\"line\">    <span class=\"string\">\"auto.offset.reset\"</span> = latest,</span><br><span class=\"line\">    kafka_broker = <span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">    kafka_group_id = <span class=\"string\">'streamSql_test1'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">-- 定义数据流输出位置</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> mysql_table_sink(</span><br><span class=\"line\">    a1 <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    a2 <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    event_time <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- ideal.sylph.plugins.flink.sink.MysqlSink.java</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">query</span> = <span class=\"string\">'insert into mysql_table_sink values($&#123;0&#125;,$&#123;1&#125;,$&#123;2&#125;)'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">-- 描述数据流计算过程</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> mysql_table_sink</span><br><span class=\"line\"><span class=\"keyword\">select</span> _topic,<span class=\"string\">`_message`</span>,<span class=\"keyword\">cast</span>(_offset <span class=\"keyword\">as</span> <span class=\"built_in\">bigint</span>) <span class=\"keyword\">from</span> topic1 <span class=\"keyword\">where</span> _key <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"demo2\"><a class=\"markdown-anchor\" href=\"#demo2\">#</a> demo2</h3>\n<p>下面的例子 演示如何计算topic <code>TP_A_1</code>每分钟的uv\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    _topic <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _key <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _message <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _partition <span class=\"built_in\">integer</span>,</span><br><span class=\"line\">    _offset <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">    kafka_topic = <span class=\"string\">'TP_A_1'</span>,</span><br><span class=\"line\">    <span class=\"string\">\"auto.offset.reset\"</span> = latest,</span><br><span class=\"line\">    kafka_broker = <span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">    kafka_group_id = <span class=\"string\">'streamSql_test1'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> mysql_uv_table_sink(</span><br><span class=\"line\">    user_id <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    uv <span class=\"built_in\">bigint</span>,</span><br><span class=\"line\">    cnt_time <span class=\"built_in\">date</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- ideal.sylph.plugins.flink.sink.MysqlSink.java</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">query</span> = <span class=\"string\">'insert into mysql_uv_table_sink values($&#123;0&#125;,$&#123;1&#125;,$&#123;2&#125;)'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">with tb13 as (<span class=\"keyword\">SELECT</span> proctime</span><br><span class=\"line\">    ,row_get(rowline,<span class=\"number\">0</span>)<span class=\"keyword\">as</span> user_id</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> topic1, LATERAL <span class=\"keyword\">TABLE</span>(json_parser(_message,<span class=\"string\">'user_id'</span>)) <span class=\"keyword\">as</span> T(rowline) </span><br><span class=\"line\">    <span class=\"keyword\">where</span> <span class=\"keyword\">cast</span>(row_get(rowline,<span class=\"number\">0</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>) <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> mysql_uv_table_sink</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">user_id,</span><br><span class=\"line\"><span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> user_id) <span class=\"keyword\">as</span> uv</span><br><span class=\"line\">,TUMBLE_START(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'60'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">AS</span> window_start </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> tb13 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> user_id,TUMBLE(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'60'</span> <span class=\"keyword\">SECOND</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"strteamsql设计器\"><a class=\"markdown-anchor\" href=\"#strteamsql设计器\">#</a> strteamSql设计器</h3>\n<p><img src=\"../../../images/sylph/strteam_sql.png\" alt=\"strteamSql\"></p>\n"},{"title":"插件api","_content":"","source":"zh-cn/docs/advanced/framework.md","raw":"\ntitle: 插件api\n---","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/advanced/framework.html","comments":1,"layout":"page","_id":"cjyd4skj1000x6lq1bjof0kwc","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"框架开发","_content":"","source":"zh-cn/docs/advanced/plugin_api.md","raw":"\ntitle: 框架开发\n---","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/advanced/plugin_api.html","comments":1,"layout":"page","_id":"cjyd4skj2000y6lq1444zrtyj","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"插件管理","_content":"","source":"zh-cn/docs/advanced/plugin_manager.md","raw":"\ntitle: 插件管理\n---","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/advanced/plugin_manager.html","comments":1,"layout":"page","_id":"cjyd4skj4000z6lq1pr464gfw","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"应用部署","_content":"\n","source":"zh-cn/docs/basics/deployment.md","raw":"title: 应用部署\n---\n\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/basics/deployment.html","comments":1,"layout":"page","_id":"cjyd4skj500106lq15359q0tt","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"NodeUI数据模拟中心","_content":"\n数据mock主要分为前端接口的mock（client request）及向后请求的数据mock(server request)。\n\n其中，前端接口mock表现为 ajax请求。向后请求Mock主要是指nodeui向后请求php接口的mock，这种数据一般用来渲染到模板或者直接接口输出。\n\n所有的mock均支持热重启，即修改代码不需要重启nodeui，立即生效。\n\n### 目录规范\n\n```\nmock\n  ├─ server.conf // 配置中心  \n  ├─ common   // 公共接口目录\n  │  ├─ dynamic.js  // 动态数据\n  │  ├─ sample.json  // 静态json数据\n  ├─ ral // nodeui向php请求接口模拟\n  │  ├─ hongbao-getmobilebyopenid.js // 微信授权根据openid获取用户信息接口  \n  │  ├─ hongbao-updatemobilebyopenid.js // 更新用户信息接口  \n  │  ├─ huodong-2016usergrowstoryindex.js // 业务php接口模拟  \n  ├─ dumall // 业务接口\n  │  ├─ center.js // 小度商城个人中心\n  │  ├─ del.json // 删除卡片接口\n  ...\n```\n\n### 前端接口的使用\n\n前端接口的mock主要在`server.conf`里面进行配置\n    \n#### server.conf 配置语法\n\n    指令名称 正则规则 目标文件\n    \n- `指令名称` 支持 rewrite 、 redirect 和 proxy。\n- `正则规则` 用来命中需要作假的请求路径\n- `目标文件` 设置转发的目标地址，需要配置一个可请求的 url 地址。\n\n#### mock 静态假数据\n\n\n```\nrewrite ^\\/api\\/user$ /mock/sample.json\n\n// sample.json内容\n\n{\n    \"error\": 0,\n    \"message\": \"ok\",\n    \"data\": {\n        \"username\": \"younth\",\n        \"uid\": 1,\n        \"age\": 25,\n        \"company\": \"waimai\"\n    }\n}\n```\n\n#### mock 动态假数据\n\n> node 服务器可以通过 js 的方式提供动态假数据。，动态数据本质是 express 的 route.\n\n`rewrite ^\\/api\\/dynamic\\/time$ /mock/dynamic.js`\n\n```js\n// dynamic.js内容\nmodule.exports = function(req, res, next) {\n\n  res.write('Hello world ');\n\n  // set custom header.\n  // res.setHeader('xxxx', 'xxx');\n\n  res.end('The time is ' + Date.now());\n};\n\n// 更复杂的，可以直接引用其他模块，发送请求\n\n\nvar http = require('http');\nvar url = require('url');\nvar util = require('util');\nvar querystring = require('querystring');\n\n// 通过nodejs来抓取线上的结果。这样就完成了动态获取线上数据的功能\n\nmodule.exports = function(request, response, next) {\n\n    var method = request.method;\n    ...\n\n};\n\n```\n\n#### proxy 到其他服务的 api 地址\n\n```bash\n    // 支持正则分组\n    proxy ^\\/wmall\\/privilege\\/(.*)$  http://10.19.161.92:8059/wmall/privilege/$1\n```\n\n### ral 请求的mock\n\n主要是Node向下游服务(PHP)请求的数据mock，基于ral请求的数据模拟。\n\n#### 如何使用\n\n##### 1. 根据path 建立mock文件\n\n文件命名规则是 *请求的path用-符号连接*\n\n    /huodong/gamebase ->  huodong-gamebase.js\n\npath与文件名的映射关系必须按照上面的要求，否则无法mock。\n\n##### 2. 开启mock\n\n比如我们有这样的一个请求：\n\n```js\ngetData: function(req, tools, params) {\n    var options = {\n        data: params || {},\n        path: '/huodong/gamebase',\n        reqType: 'promise'\n    };\n    return tools.commonBusiness.pierce(req, 'SHOPUI', options);\n}\n```\nmock文件夹下面建立一个 `huodong-gamebase.js`,在请求的参数里面增加 `enableMock: true`开启mock\n\n```js\ngetData: function(req, tools, params) {\n    var options = {\n        data: params || {},\n        path: '/huodong/gamebase',\n        reqType: 'promise',\n        enableMock: true,//开启Mock\n    };\n    return tools.commonBusiness.pierce(req, 'SHOPUI', options);\n}\n```\n这样就完成了nodeui向php请求的数据mock\n\n## 测试链接\n\n- ral请求mock: http://127.0.0.1:8197/fly/h5/demo\n- 普通请求mock(rewrite): http://127.0.0.1:8197/api/user\n- 动态数据mock(rewrite): http://127.0.0.1:8197/api/dynamic/time\n- api proxy mock: http://127.0.0.1:8197/wmall/privilege/center\n- 重定向(redirect): http://127.0.0.1:8197/api/redirect\n","source":"zh-cn/docs/basics/mock.md","raw":"title: NodeUI数据模拟中心\n---\n\n数据mock主要分为前端接口的mock（client request）及向后请求的数据mock(server request)。\n\n其中，前端接口mock表现为 ajax请求。向后请求Mock主要是指nodeui向后请求php接口的mock，这种数据一般用来渲染到模板或者直接接口输出。\n\n所有的mock均支持热重启，即修改代码不需要重启nodeui，立即生效。\n\n### 目录规范\n\n```\nmock\n  ├─ server.conf // 配置中心  \n  ├─ common   // 公共接口目录\n  │  ├─ dynamic.js  // 动态数据\n  │  ├─ sample.json  // 静态json数据\n  ├─ ral // nodeui向php请求接口模拟\n  │  ├─ hongbao-getmobilebyopenid.js // 微信授权根据openid获取用户信息接口  \n  │  ├─ hongbao-updatemobilebyopenid.js // 更新用户信息接口  \n  │  ├─ huodong-2016usergrowstoryindex.js // 业务php接口模拟  \n  ├─ dumall // 业务接口\n  │  ├─ center.js // 小度商城个人中心\n  │  ├─ del.json // 删除卡片接口\n  ...\n```\n\n### 前端接口的使用\n\n前端接口的mock主要在`server.conf`里面进行配置\n    \n#### server.conf 配置语法\n\n    指令名称 正则规则 目标文件\n    \n- `指令名称` 支持 rewrite 、 redirect 和 proxy。\n- `正则规则` 用来命中需要作假的请求路径\n- `目标文件` 设置转发的目标地址，需要配置一个可请求的 url 地址。\n\n#### mock 静态假数据\n\n\n```\nrewrite ^\\/api\\/user$ /mock/sample.json\n\n// sample.json内容\n\n{\n    \"error\": 0,\n    \"message\": \"ok\",\n    \"data\": {\n        \"username\": \"younth\",\n        \"uid\": 1,\n        \"age\": 25,\n        \"company\": \"waimai\"\n    }\n}\n```\n\n#### mock 动态假数据\n\n> node 服务器可以通过 js 的方式提供动态假数据。，动态数据本质是 express 的 route.\n\n`rewrite ^\\/api\\/dynamic\\/time$ /mock/dynamic.js`\n\n```js\n// dynamic.js内容\nmodule.exports = function(req, res, next) {\n\n  res.write('Hello world ');\n\n  // set custom header.\n  // res.setHeader('xxxx', 'xxx');\n\n  res.end('The time is ' + Date.now());\n};\n\n// 更复杂的，可以直接引用其他模块，发送请求\n\n\nvar http = require('http');\nvar url = require('url');\nvar util = require('util');\nvar querystring = require('querystring');\n\n// 通过nodejs来抓取线上的结果。这样就完成了动态获取线上数据的功能\n\nmodule.exports = function(request, response, next) {\n\n    var method = request.method;\n    ...\n\n};\n\n```\n\n#### proxy 到其他服务的 api 地址\n\n```bash\n    // 支持正则分组\n    proxy ^\\/wmall\\/privilege\\/(.*)$  http://10.19.161.92:8059/wmall/privilege/$1\n```\n\n### ral 请求的mock\n\n主要是Node向下游服务(PHP)请求的数据mock，基于ral请求的数据模拟。\n\n#### 如何使用\n\n##### 1. 根据path 建立mock文件\n\n文件命名规则是 *请求的path用-符号连接*\n\n    /huodong/gamebase ->  huodong-gamebase.js\n\npath与文件名的映射关系必须按照上面的要求，否则无法mock。\n\n##### 2. 开启mock\n\n比如我们有这样的一个请求：\n\n```js\ngetData: function(req, tools, params) {\n    var options = {\n        data: params || {},\n        path: '/huodong/gamebase',\n        reqType: 'promise'\n    };\n    return tools.commonBusiness.pierce(req, 'SHOPUI', options);\n}\n```\nmock文件夹下面建立一个 `huodong-gamebase.js`,在请求的参数里面增加 `enableMock: true`开启mock\n\n```js\ngetData: function(req, tools, params) {\n    var options = {\n        data: params || {},\n        path: '/huodong/gamebase',\n        reqType: 'promise',\n        enableMock: true,//开启Mock\n    };\n    return tools.commonBusiness.pierce(req, 'SHOPUI', options);\n}\n```\n这样就完成了nodeui向php请求的数据mock\n\n## 测试链接\n\n- ral请求mock: http://127.0.0.1:8197/fly/h5/demo\n- 普通请求mock(rewrite): http://127.0.0.1:8197/api/user\n- 动态数据mock(rewrite): http://127.0.0.1:8197/api/dynamic/time\n- api proxy mock: http://127.0.0.1:8197/wmall/privilege/center\n- 重定向(redirect): http://127.0.0.1:8197/api/redirect\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/basics/mock.html","comments":1,"layout":"page","_id":"cjyd4skj900116lq1mew4ine2","content":"<p>数据mock主要分为前端接口的mock（client request）及向后请求的数据mock(server request)。</p>\n<p>其中，前端接口mock表现为 ajax请求。向后请求Mock主要是指nodeui向后请求php接口的mock，这种数据一般用来渲染到模板或者直接接口输出。</p>\n<p>所有的mock均支持热重启，即修改代码不需要重启nodeui，立即生效。</p>\n<h3 id=\"目录规范\"><a class=\"markdown-anchor\" href=\"#目录规范\">#</a> 目录规范</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mock</span><br><span class=\"line\">  ├─ server.conf // 配置中心  </span><br><span class=\"line\">  ├─ common   // 公共接口目录</span><br><span class=\"line\">  │  ├─ dynamic.js  // 动态数据</span><br><span class=\"line\">  │  ├─ sample.json  // 静态json数据</span><br><span class=\"line\">  ├─ ral // nodeui向php请求接口模拟</span><br><span class=\"line\">  │  ├─ hongbao-getmobilebyopenid.js // 微信授权根据openid获取用户信息接口  </span><br><span class=\"line\">  │  ├─ hongbao-updatemobilebyopenid.js // 更新用户信息接口  </span><br><span class=\"line\">  │  ├─ huodong-2016usergrowstoryindex.js // 业务php接口模拟  </span><br><span class=\"line\">  ├─ dumall // 业务接口</span><br><span class=\"line\">  │  ├─ center.js // 小度商城个人中心</span><br><span class=\"line\">  │  ├─ del.json // 删除卡片接口</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"前端接口的使用\"><a class=\"markdown-anchor\" href=\"#前端接口的使用\">#</a> 前端接口的使用</h3>\n<p>前端接口的mock主要在<code>server.conf</code>里面进行配置</p>\n<h4 id=\"serverconf-配置语法\"><a class=\"markdown-anchor\" href=\"#serverconf-配置语法\">#</a> server.conf 配置语法</h4>\n<pre><code>指令名称 正则规则 目标文件\n</code></pre>\n<ul>\n<li><code>指令名称</code> 支持 rewrite 、 redirect 和 proxy。</li>\n<li><code>正则规则</code> 用来命中需要作假的请求路径</li>\n<li><code>目标文件</code> 设置转发的目标地址，需要配置一个可请求的 url 地址。</li>\n</ul>\n<h4 id=\"mock-静态假数据\"><a class=\"markdown-anchor\" href=\"#mock-静态假数据\">#</a> mock 静态假数据</h4>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rewrite ^\\/api\\/user$ /mock/sample.json</span><br><span class=\"line\"></span><br><span class=\"line\">// sample.json内容</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;error&quot;: 0,</span><br><span class=\"line\">    &quot;message&quot;: &quot;ok&quot;,</span><br><span class=\"line\">    &quot;data&quot;: &#123;</span><br><span class=\"line\">        &quot;username&quot;: &quot;younth&quot;,</span><br><span class=\"line\">        &quot;uid&quot;: 1,</span><br><span class=\"line\">        &quot;age&quot;: 25,</span><br><span class=\"line\">        &quot;company&quot;: &quot;waimai&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"mock-动态假数据\"><a class=\"markdown-anchor\" href=\"#mock-动态假数据\">#</a> mock 动态假数据</h4>\n<blockquote>\n<p>node 服务器可以通过 js 的方式提供动态假数据。，动态数据本质是 express 的 route.</p>\n</blockquote>\n<p><code>rewrite ^\\/api\\/dynamic\\/time$ /mock/dynamic.js</code></p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dynamic.js内容</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  res.write(<span class=\"string\">'Hello world '</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// set custom header.</span></span><br><span class=\"line\">  <span class=\"comment\">// res.setHeader('xxxx', 'xxx');</span></span><br><span class=\"line\"></span><br><span class=\"line\">  res.end(<span class=\"string\">'The time is '</span> + <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更复杂的，可以直接引用其他模块，发送请求</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过nodejs来抓取线上的结果。这样就完成了动态获取线上数据的功能</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, response, next</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = request.method;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"proxy-到其他服务的-api-地址\"><a class=\"markdown-anchor\" href=\"#proxy-到其他服务的-api-地址\">#</a> proxy 到其他服务的 api 地址</h4>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 支持正则分组</span><br><span class=\"line\">proxy ^\\/wmall\\/privilege\\/(.*)$  http://10.19.161.92:8059/wmall/privilege/<span class=\"variable\">$1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ral-请求的mock\"><a class=\"markdown-anchor\" href=\"#ral-请求的mock\">#</a> ral 请求的mock</h3>\n<p>主要是Node向下游服务(PHP)请求的数据mock，基于ral请求的数据模拟。</p>\n<h4 id=\"如何使用\"><a class=\"markdown-anchor\" href=\"#如何使用\">#</a> 如何使用</h4>\n<h5 id=\"1-根据path-建立mock文件\"><a class=\"markdown-anchor\" href=\"#1-根据path-建立mock文件\">#</a> 1. 根据path 建立mock文件</h5>\n<p>文件命名规则是 <em>请求的path用-符号连接</em></p>\n<pre><code>/huodong/gamebase -&gt;  huodong-gamebase.js\n</code></pre>\n<p>path与文件名的映射关系必须按照上面的要求，否则无法mock。</p>\n<h5 id=\"2-开启mock\"><a class=\"markdown-anchor\" href=\"#2-开启mock\">#</a> 2. 开启mock</h5>\n<p>比如我们有这样的一个请求：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, tools, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">        data: params || &#123;&#125;,</span><br><span class=\"line\">        path: <span class=\"string\">'/huodong/gamebase'</span>,</span><br><span class=\"line\">        reqType: <span class=\"string\">'promise'</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tools.commonBusiness.pierce(req, <span class=\"string\">'SHOPUI'</span>, options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mock文件夹下面建立一个 <code>huodong-gamebase.js</code>,在请求的参数里面增加 <code>enableMock: true</code>开启mock</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, tools, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">        data: params || &#123;&#125;,</span><br><span class=\"line\">        path: <span class=\"string\">'/huodong/gamebase'</span>,</span><br><span class=\"line\">        reqType: <span class=\"string\">'promise'</span>,</span><br><span class=\"line\">        enableMock: <span class=\"literal\">true</span>,<span class=\"comment\">//开启Mock</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tools.commonBusiness.pierce(req, <span class=\"string\">'SHOPUI'</span>, options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样就完成了nodeui向php请求的数据mock</p>\n<h2 id=\"测试链接\"><a class=\"markdown-anchor\" href=\"#测试链接\">#</a> 测试链接</h2>\n<ul>\n<li>ral请求mock: http://127.0.0.1:8197/fly/h5/demo</li>\n<li>普通请求mock(rewrite): http://127.0.0.1:8197/api/user</li>\n<li>动态数据mock(rewrite): http://127.0.0.1:8197/api/dynamic/time</li>\n<li>api proxy mock: http://127.0.0.1:8197/wmall/privilege/center</li>\n<li>重定向(redirect): http://127.0.0.1:8197/api/redirect</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>数据mock主要分为前端接口的mock（client request）及向后请求的数据mock(server request)。</p>\n<p>其中，前端接口mock表现为 ajax请求。向后请求Mock主要是指nodeui向后请求php接口的mock，这种数据一般用来渲染到模板或者直接接口输出。</p>\n<p>所有的mock均支持热重启，即修改代码不需要重启nodeui，立即生效。</p>\n<h3 id=\"目录规范\"><a class=\"markdown-anchor\" href=\"#目录规范\">#</a> 目录规范</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mock</span><br><span class=\"line\">  ├─ server.conf // 配置中心  </span><br><span class=\"line\">  ├─ common   // 公共接口目录</span><br><span class=\"line\">  │  ├─ dynamic.js  // 动态数据</span><br><span class=\"line\">  │  ├─ sample.json  // 静态json数据</span><br><span class=\"line\">  ├─ ral // nodeui向php请求接口模拟</span><br><span class=\"line\">  │  ├─ hongbao-getmobilebyopenid.js // 微信授权根据openid获取用户信息接口  </span><br><span class=\"line\">  │  ├─ hongbao-updatemobilebyopenid.js // 更新用户信息接口  </span><br><span class=\"line\">  │  ├─ huodong-2016usergrowstoryindex.js // 业务php接口模拟  </span><br><span class=\"line\">  ├─ dumall // 业务接口</span><br><span class=\"line\">  │  ├─ center.js // 小度商城个人中心</span><br><span class=\"line\">  │  ├─ del.json // 删除卡片接口</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"前端接口的使用\"><a class=\"markdown-anchor\" href=\"#前端接口的使用\">#</a> 前端接口的使用</h3>\n<p>前端接口的mock主要在<code>server.conf</code>里面进行配置</p>\n<h4 id=\"serverconf-配置语法\"><a class=\"markdown-anchor\" href=\"#serverconf-配置语法\">#</a> server.conf 配置语法</h4>\n<pre><code>指令名称 正则规则 目标文件\n</code></pre>\n<ul>\n<li><code>指令名称</code> 支持 rewrite 、 redirect 和 proxy。</li>\n<li><code>正则规则</code> 用来命中需要作假的请求路径</li>\n<li><code>目标文件</code> 设置转发的目标地址，需要配置一个可请求的 url 地址。</li>\n</ul>\n<h4 id=\"mock-静态假数据\"><a class=\"markdown-anchor\" href=\"#mock-静态假数据\">#</a> mock 静态假数据</h4>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rewrite ^\\/api\\/user$ /mock/sample.json</span><br><span class=\"line\"></span><br><span class=\"line\">// sample.json内容</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;error&quot;: 0,</span><br><span class=\"line\">    &quot;message&quot;: &quot;ok&quot;,</span><br><span class=\"line\">    &quot;data&quot;: &#123;</span><br><span class=\"line\">        &quot;username&quot;: &quot;younth&quot;,</span><br><span class=\"line\">        &quot;uid&quot;: 1,</span><br><span class=\"line\">        &quot;age&quot;: 25,</span><br><span class=\"line\">        &quot;company&quot;: &quot;waimai&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"mock-动态假数据\"><a class=\"markdown-anchor\" href=\"#mock-动态假数据\">#</a> mock 动态假数据</h4>\n<blockquote>\n<p>node 服务器可以通过 js 的方式提供动态假数据。，动态数据本质是 express 的 route.</p>\n</blockquote>\n<p><code>rewrite ^\\/api\\/dynamic\\/time$ /mock/dynamic.js</code></p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dynamic.js内容</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  res.write(<span class=\"string\">'Hello world '</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// set custom header.</span></span><br><span class=\"line\">  <span class=\"comment\">// res.setHeader('xxxx', 'xxx');</span></span><br><span class=\"line\"></span><br><span class=\"line\">  res.end(<span class=\"string\">'The time is '</span> + <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更复杂的，可以直接引用其他模块，发送请求</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过nodejs来抓取线上的结果。这样就完成了动态获取线上数据的功能</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, response, next</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = request.method;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"proxy-到其他服务的-api-地址\"><a class=\"markdown-anchor\" href=\"#proxy-到其他服务的-api-地址\">#</a> proxy 到其他服务的 api 地址</h4>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 支持正则分组</span><br><span class=\"line\">proxy ^\\/wmall\\/privilege\\/(.*)$  http://10.19.161.92:8059/wmall/privilege/<span class=\"variable\">$1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ral-请求的mock\"><a class=\"markdown-anchor\" href=\"#ral-请求的mock\">#</a> ral 请求的mock</h3>\n<p>主要是Node向下游服务(PHP)请求的数据mock，基于ral请求的数据模拟。</p>\n<h4 id=\"如何使用\"><a class=\"markdown-anchor\" href=\"#如何使用\">#</a> 如何使用</h4>\n<h5 id=\"1-根据path-建立mock文件\"><a class=\"markdown-anchor\" href=\"#1-根据path-建立mock文件\">#</a> 1. 根据path 建立mock文件</h5>\n<p>文件命名规则是 <em>请求的path用-符号连接</em></p>\n<pre><code>/huodong/gamebase -&gt;  huodong-gamebase.js\n</code></pre>\n<p>path与文件名的映射关系必须按照上面的要求，否则无法mock。</p>\n<h5 id=\"2-开启mock\"><a class=\"markdown-anchor\" href=\"#2-开启mock\">#</a> 2. 开启mock</h5>\n<p>比如我们有这样的一个请求：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, tools, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">        data: params || &#123;&#125;,</span><br><span class=\"line\">        path: <span class=\"string\">'/huodong/gamebase'</span>,</span><br><span class=\"line\">        reqType: <span class=\"string\">'promise'</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tools.commonBusiness.pierce(req, <span class=\"string\">'SHOPUI'</span>, options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mock文件夹下面建立一个 <code>huodong-gamebase.js</code>,在请求的参数里面增加 <code>enableMock: true</code>开启mock</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">getData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, tools, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">        data: params || &#123;&#125;,</span><br><span class=\"line\">        path: <span class=\"string\">'/huodong/gamebase'</span>,</span><br><span class=\"line\">        reqType: <span class=\"string\">'promise'</span>,</span><br><span class=\"line\">        enableMock: <span class=\"literal\">true</span>,<span class=\"comment\">//开启Mock</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tools.commonBusiness.pierce(req, <span class=\"string\">'SHOPUI'</span>, options);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样就完成了nodeui向php请求的数据mock</p>\n<h2 id=\"测试链接\"><a class=\"markdown-anchor\" href=\"#测试链接\">#</a> 测试链接</h2>\n<ul>\n<li>ral请求mock: http://127.0.0.1:8197/fly/h5/demo</li>\n<li>普通请求mock(rewrite): http://127.0.0.1:8197/api/user</li>\n<li>动态数据mock(rewrite): http://127.0.0.1:8197/api/dynamic/time</li>\n<li>api proxy mock: http://127.0.0.1:8197/wmall/privilege/center</li>\n<li>重定向(redirect): http://127.0.0.1:8197/api/redirect</li>\n</ul>\n"},{"title":"应用上线和路由","_content":"\n在任务管理页面可以点击上线可以一键上线任务到yarn上,上线成功后可以直接在webui查看任务无需登录到yarn上面\n\n\n### 注意\n\nspark execur在8042上面的节点无法进行代理,需手动\n\n## todo\n\n需要升级\n","source":"zh-cn/docs/basics/online.md","raw":"title: 应用上线和路由\n---\n\n在任务管理页面可以点击上线可以一键上线任务到yarn上,上线成功后可以直接在webui查看任务无需登录到yarn上面\n\n\n### 注意\n\nspark execur在8042上面的节点无法进行代理,需手动\n\n## todo\n\n需要升级\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/basics/online.html","comments":1,"layout":"page","_id":"cjyd4skjb00126lq1lfw34yo1","content":"<p>在任务管理页面可以点击上线可以一键上线任务到yarn上,上线成功后可以直接在webui查看任务无需登录到yarn上面</p>\n<h3 id=\"注意\"><a class=\"markdown-anchor\" href=\"#注意\">#</a> 注意</h3>\n<p>spark execur在8042上面的节点无法进行代理,需手动</p>\n<h2 id=\"todo\"><a class=\"markdown-anchor\" href=\"#todo\">#</a> todo</h2>\n<p>需要升级</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>在任务管理页面可以点击上线可以一键上线任务到yarn上,上线成功后可以直接在webui查看任务无需登录到yarn上面</p>\n<h3 id=\"注意\"><a class=\"markdown-anchor\" href=\"#注意\">#</a> 注意</h3>\n<p>spark execur在8042上面的节点无法进行代理,需手动</p>\n<h2 id=\"todo\"><a class=\"markdown-anchor\" href=\"#todo\">#</a> todo</h2>\n<p>需要升级</p>\n"},{"title":"REST Service","_content":"\nSYLPH 中，使用restful风格接口:\n\n- 后端服务配置统一管理\n- 封装异常处理、超时重试，提升系统稳定性\n- 封装日志，便于线上问题追查\n- 抽象请求协议、数据格式与数据编码，统一接口\n\n## 主要特征\n\n- compile\n- proxy\n\n## 使用 Service\n\n接口在`sylph-controller`模块中管理,主要分布在`ideal.sylph.controller.action`包下:\n\n```java\n    @javax.inject.Singleton\n    @Path(\"/stream_sql\")\n    public class StreamSqlResource\n    {\n    ...\n        \n        @POST\n        @Path(\"save\")\n        @Consumes({MediaType.MULTIPART_FORM_DATA, MediaType.APPLICATION_JSON})\n        @Produces({MediaType.APPLICATION_JSON})\n        public Map saveJob(@Context HttpServletRequest request){\n            ...\n        }\n```\n\n\n","source":"zh-cn/docs/basics/service.md","raw":"title: REST Service\n---\n\nSYLPH 中，使用restful风格接口:\n\n- 后端服务配置统一管理\n- 封装异常处理、超时重试，提升系统稳定性\n- 封装日志，便于线上问题追查\n- 抽象请求协议、数据格式与数据编码，统一接口\n\n## 主要特征\n\n- compile\n- proxy\n\n## 使用 Service\n\n接口在`sylph-controller`模块中管理,主要分布在`ideal.sylph.controller.action`包下:\n\n```java\n    @javax.inject.Singleton\n    @Path(\"/stream_sql\")\n    public class StreamSqlResource\n    {\n    ...\n        \n        @POST\n        @Path(\"save\")\n        @Consumes({MediaType.MULTIPART_FORM_DATA, MediaType.APPLICATION_JSON})\n        @Produces({MediaType.APPLICATION_JSON})\n        public Map saveJob(@Context HttpServletRequest request){\n            ...\n        }\n```\n\n\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/basics/service.html","comments":1,"layout":"page","_id":"cjyd4skjc00136lq19gpuxpmc","content":"<p>SYLPH 中，使用restful风格接口:</p>\n<ul>\n<li>后端服务配置统一管理</li>\n<li>封装异常处理、超时重试，提升系统稳定性</li>\n<li>封装日志，便于线上问题追查</li>\n<li>抽象请求协议、数据格式与数据编码，统一接口</li>\n</ul>\n<h2 id=\"主要特征\"><a class=\"markdown-anchor\" href=\"#主要特征\">#</a> 主要特征</h2>\n<ul>\n<li>compile</li>\n<li>proxy</li>\n</ul>\n<h2 id=\"使用-service\"><a class=\"markdown-anchor\" href=\"#使用-service\">#</a> 使用 Service</h2>\n<p>接口在<code>sylph-controller</code>模块中管理,主要分布在<code>ideal.sylph.controller.action</code>包下:</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@javax</span>.inject.Singleton</span><br><span class=\"line\"><span class=\"meta\">@Path</span>(<span class=\"string\">\"/stream_sql\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamSqlResource</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@POST</span></span><br><span class=\"line\">    <span class=\"meta\">@Path</span>(<span class=\"string\">\"save\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Consumes</span>(&#123;MediaType.MULTIPART_FORM_DATA, MediaType.APPLICATION_JSON&#125;)</span><br><span class=\"line\">    <span class=\"meta\">@Produces</span>(&#123;MediaType.APPLICATION_JSON&#125;)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">saveJob</span><span class=\"params\">(@Context HttpServletRequest request)</span></span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>SYLPH 中，使用restful风格接口:</p>\n<ul>\n<li>后端服务配置统一管理</li>\n<li>封装异常处理、超时重试，提升系统稳定性</li>\n<li>封装日志，便于线上问题追查</li>\n<li>抽象请求协议、数据格式与数据编码，统一接口</li>\n</ul>\n<h2 id=\"主要特征\"><a class=\"markdown-anchor\" href=\"#主要特征\">#</a> 主要特征</h2>\n<ul>\n<li>compile</li>\n<li>proxy</li>\n</ul>\n<h2 id=\"使用-service\"><a class=\"markdown-anchor\" href=\"#使用-service\">#</a> 使用 Service</h2>\n<p>接口在<code>sylph-controller</code>模块中管理,主要分布在<code>ideal.sylph.controller.action</code>包下:</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@javax</span>.inject.Singleton</span><br><span class=\"line\"><span class=\"meta\">@Path</span>(<span class=\"string\">\"/stream_sql\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamSqlResource</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@POST</span></span><br><span class=\"line\">    <span class=\"meta\">@Path</span>(<span class=\"string\">\"save\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Consumes</span>(&#123;MediaType.MULTIPART_FORM_DATA, MediaType.APPLICATION_JSON&#125;)</span><br><span class=\"line\">    <span class=\"meta\">@Produces</span>(&#123;MediaType.APPLICATION_JSON&#125;)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">saveJob</span><span class=\"params\">(@Context HttpServletRequest request)</span></span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Sylph安装","_content":"\n### 下载源码\nhttps://github.com/harbby/sylph/releases/\n\n### 编译\n**编译sylph需要使用Gradle并需要Java 8.请确保您的JAVA_HOME环境为java8**\n\n编译\n```bash\n./gradlew clean assemble install\n```","source":"zh-cn/docs/basics/setup.md","raw":"title: Sylph安装\n---\n\n### 下载源码\nhttps://github.com/harbby/sylph/releases/\n\n### 编译\n**编译sylph需要使用Gradle并需要Java 8.请确保您的JAVA_HOME环境为java8**\n\n编译\n```bash\n./gradlew clean assemble install\n```","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/basics/setup.html","comments":1,"layout":"page","_id":"cjyd4skje00146lq1bpkwrvmv","content":"<h3 id=\"下载源码\"><a class=\"markdown-anchor\" href=\"#下载源码\">#</a> 下载源码</h3>\n<p>https://github.com/harbby/sylph/releases/</p>\n<h3 id=\"编译\"><a class=\"markdown-anchor\" href=\"#编译\">#</a> 编译</h3>\n<p><strong>编译sylph需要使用Gradle并需要Java 8.请确保您的JAVA_HOME环境为java8</strong></p>\n<p>编译\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./gradlew clean assemble install</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<h3 id=\"下载源码\"><a class=\"markdown-anchor\" href=\"#下载源码\">#</a> 下载源码</h3>\n<p>https://github.com/harbby/sylph/releases/</p>\n<h3 id=\"编译\"><a class=\"markdown-anchor\" href=\"#编译\">#</a> 编译</h3>\n<p><strong>编译sylph需要使用Gradle并需要Java 8.请确保您的JAVA_HOME环境为java8</strong></p>\n<p>编译\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./gradlew clean assemble install</span><br></pre></td></tr></table></figure></p>\n"},{"title":"目录结构","_content":"\n在[快速入门](../intro/quickstart.md)中，对sylph有了初步的印象，接下来我们简单了解下安装目录约定规范。\n\n### 1. 框架目录结构\n![framework]\n\n### 2. 业务模块结构\n![business]\n\n[framework]: ../../../images/logo.png\n[business]: ../../../images/logo.png\n\n```bash\nsylph-bin-${version}\n├── bin (启动脚本)\n├── etc \n│   └── sylph (配置)\n├── etl-plugins (pipeline插件,如下有两个插件包)\n│   ├── flink-node-plugin\n│   └── spark-node-plugin\n├── jobs (job保存目录)\n│   ├── a2\n│   ├── spark_test1\n│   └── sql_test1\n├── lib (核心依赖)\n├── logs\n├── modules (执行器 如有flink,spark执行器)\n│   ├── sylph-runner-flink\n│   │   └── lib\n│   └── sylph-runner-spark\n│       └── lib\n└── webapps (webUI)\n    ├── css\n    ├── fonts\n    ├── img\n    ├── js\n    ├── ...\n```\n\n如上，整个sylph的安装目录：\n","source":"zh-cn/docs/basics/structure.md","raw":"title: 目录结构\n---\n\n在[快速入门](../intro/quickstart.md)中，对sylph有了初步的印象，接下来我们简单了解下安装目录约定规范。\n\n### 1. 框架目录结构\n![framework]\n\n### 2. 业务模块结构\n![business]\n\n[framework]: ../../../images/logo.png\n[business]: ../../../images/logo.png\n\n```bash\nsylph-bin-${version}\n├── bin (启动脚本)\n├── etc \n│   └── sylph (配置)\n├── etl-plugins (pipeline插件,如下有两个插件包)\n│   ├── flink-node-plugin\n│   └── spark-node-plugin\n├── jobs (job保存目录)\n│   ├── a2\n│   ├── spark_test1\n│   └── sql_test1\n├── lib (核心依赖)\n├── logs\n├── modules (执行器 如有flink,spark执行器)\n│   ├── sylph-runner-flink\n│   │   └── lib\n│   └── sylph-runner-spark\n│       └── lib\n└── webapps (webUI)\n    ├── css\n    ├── fonts\n    ├── img\n    ├── js\n    ├── ...\n```\n\n如上，整个sylph的安装目录：\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/basics/structure.html","comments":1,"layout":"page","_id":"cjyd4skjf00156lq1nr3zoa5e","content":"<p>在<a href=\"../intro/quickstart.html\">快速入门</a>中，对sylph有了初步的印象，接下来我们简单了解下安装目录约定规范。</p>\n<h3 id=\"1-框架目录结构\"><a class=\"markdown-anchor\" href=\"#1-框架目录结构\">#</a> 1. 框架目录结构</h3>\n<p><img src=\"../../../images/logo.png\" alt=\"framework\"></p>\n<h3 id=\"2-业务模块结构\"><a class=\"markdown-anchor\" href=\"#2-业务模块结构\">#</a> 2. 业务模块结构</h3>\n<p><img src=\"../../../images/logo.png\" alt=\"business\"></p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sylph-bin-<span class=\"variable\">$&#123;version&#125;</span></span><br><span class=\"line\">├── bin (启动脚本)</span><br><span class=\"line\">├── etc </span><br><span class=\"line\">│   └── sylph (配置)</span><br><span class=\"line\">├── etl-plugins (pipeline插件,如下有两个插件包)</span><br><span class=\"line\">│   ├── flink-node-plugin</span><br><span class=\"line\">│   └── spark-node-plugin</span><br><span class=\"line\">├── <span class=\"built_in\">jobs</span> (job保存目录)</span><br><span class=\"line\">│   ├── a2</span><br><span class=\"line\">│   ├── spark_test1</span><br><span class=\"line\">│   └── sql_test1</span><br><span class=\"line\">├── lib (核心依赖)</span><br><span class=\"line\">├── logs</span><br><span class=\"line\">├── modules (执行器 如有flink,spark执行器)</span><br><span class=\"line\">│   ├── sylph-runner-flink</span><br><span class=\"line\">│   │   └── lib</span><br><span class=\"line\">│   └── sylph-runner-spark</span><br><span class=\"line\">│       └── lib</span><br><span class=\"line\">└── webapps (webUI)</span><br><span class=\"line\">    ├── css</span><br><span class=\"line\">    ├── fonts</span><br><span class=\"line\">    ├── img</span><br><span class=\"line\">    ├── js</span><br><span class=\"line\">    ├── ...</span><br></pre></td></tr></table></figure></p>\n<p>如上，整个sylph的安装目录：</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>在<a href=\"../intro/quickstart.html\">快速入门</a>中，对sylph有了初步的印象，接下来我们简单了解下安装目录约定规范。</p>\n<h3 id=\"1-框架目录结构\"><a class=\"markdown-anchor\" href=\"#1-框架目录结构\">#</a> 1. 框架目录结构</h3>\n<p><img src=\"../../../images/logo.png\" alt=\"framework\"></p>\n<h3 id=\"2-业务模块结构\"><a class=\"markdown-anchor\" href=\"#2-业务模块结构\">#</a> 2. 业务模块结构</h3>\n<p><img src=\"../../../images/logo.png\" alt=\"business\"></p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sylph-bin-<span class=\"variable\">$&#123;version&#125;</span></span><br><span class=\"line\">├── bin (启动脚本)</span><br><span class=\"line\">├── etc </span><br><span class=\"line\">│   └── sylph (配置)</span><br><span class=\"line\">├── etl-plugins (pipeline插件,如下有两个插件包)</span><br><span class=\"line\">│   ├── flink-node-plugin</span><br><span class=\"line\">│   └── spark-node-plugin</span><br><span class=\"line\">├── <span class=\"built_in\">jobs</span> (job保存目录)</span><br><span class=\"line\">│   ├── a2</span><br><span class=\"line\">│   ├── spark_test1</span><br><span class=\"line\">│   └── sql_test1</span><br><span class=\"line\">├── lib (核心依赖)</span><br><span class=\"line\">├── logs</span><br><span class=\"line\">├── modules (执行器 如有flink,spark执行器)</span><br><span class=\"line\">│   ├── sylph-runner-flink</span><br><span class=\"line\">│   │   └── lib</span><br><span class=\"line\">│   └── sylph-runner-spark</span><br><span class=\"line\">│       └── lib</span><br><span class=\"line\">└── webapps (webUI)</span><br><span class=\"line\">    ├── css</span><br><span class=\"line\">    ├── fonts</span><br><span class=\"line\">    ├── img</span><br><span class=\"line\">    ├── js</span><br><span class=\"line\">    ├── ...</span><br></pre></td></tr></table></figure></p>\n<p>如上，整个sylph的安装目录：</p>\n"},{"title":"NodeUI与PHP服务通信负载均衡策略","_content":"\n### 1. roundrobin\n\n```\nRoundRobinBalance.prototype.fetchServer = function (balanceContext) {\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    balanceContext.lastRoundRobinID = balanceContext.lastRoundRobinID || 0;\n    balanceContext.lastRoundRobinID++;\n    if (balanceContext.lastRoundRobinID < 0 || balanceContext.lastRoundRobinID >= servers.length) {\n        balanceContext.lastRoundRobinID = 0;\n    }\n    logger.trace(\n        ['RoundRobinBalance fetchServer RoundRobinID=', balanceContext.lastRoundRobinID, ' ServiceID=',\n            balanceContext.serviceID\n        ].join('')\n    );\n    return servers[balanceContext.lastRoundRobinID];\n};\n```\n\n### 2. random\n\n\n```\nRandomBalance.prototype.fetchServer = function (balanceContext) {\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    // Math.random takes 250ms on first call\n    var index = Math.floor(Math.random() * servers.length);\n    logger.trace('RandomBalance fetchServer index=' + index + ' ServiceID=' + balanceContext.serviceID);\n    // TODO add server filter\n    return servers[index];\n};\n\n```\n\n### 3. hashring\n\n```\nHashringBalance.prototype.fetchServer = function (balanceContext, conf, prevBackend) {\n    if (conf.balanceKey === undefined || conf.balanceKey === null) {\n        throw new Error('balanceKey is needed when using consistent hashing');\n    }\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    if (!balanceContext.hashring) {\n        balanceContext.hashring = this.createHashring(balanceContext.reqIDCServers);\n    }\n    var ringIndex = bs(balanceContext.hashring, {\n        index: null,\n        value: this.generateHash(conf.balanceKey)\n    }, function (a, b) {\n        return a.value - b.value;\n    });\n    if (ringIndex < 0) {\n        ringIndex = -ringIndex - 1;\n    }\n    ringIndex = Math.min(ringIndex, balanceContext.hashring.length - 1);\n    var index = balanceContext.hashring[ringIndex].index;\n    logger.trace('RandomBalance fetchServer index=' + index + ' ServiceID=' + balanceContext.serviceID);\n    return servers[index];\n};\n\n```\n","source":"zh-cn/docs/core/fetch-server.md","raw":"title: NodeUI与PHP服务通信负载均衡策略\n---\n\n### 1. roundrobin\n\n```\nRoundRobinBalance.prototype.fetchServer = function (balanceContext) {\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    balanceContext.lastRoundRobinID = balanceContext.lastRoundRobinID || 0;\n    balanceContext.lastRoundRobinID++;\n    if (balanceContext.lastRoundRobinID < 0 || balanceContext.lastRoundRobinID >= servers.length) {\n        balanceContext.lastRoundRobinID = 0;\n    }\n    logger.trace(\n        ['RoundRobinBalance fetchServer RoundRobinID=', balanceContext.lastRoundRobinID, ' ServiceID=',\n            balanceContext.serviceID\n        ].join('')\n    );\n    return servers[balanceContext.lastRoundRobinID];\n};\n```\n\n### 2. random\n\n\n```\nRandomBalance.prototype.fetchServer = function (balanceContext) {\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    // Math.random takes 250ms on first call\n    var index = Math.floor(Math.random() * servers.length);\n    logger.trace('RandomBalance fetchServer index=' + index + ' ServiceID=' + balanceContext.serviceID);\n    // TODO add server filter\n    return servers[index];\n};\n\n```\n\n### 3. hashring\n\n```\nHashringBalance.prototype.fetchServer = function (balanceContext, conf, prevBackend) {\n    if (conf.balanceKey === undefined || conf.balanceKey === null) {\n        throw new Error('balanceKey is needed when using consistent hashing');\n    }\n    var servers = balanceContext.reqIDCServers;\n    if (servers.length === 1) {\n        return servers[0];\n    }\n    if (!balanceContext.hashring) {\n        balanceContext.hashring = this.createHashring(balanceContext.reqIDCServers);\n    }\n    var ringIndex = bs(balanceContext.hashring, {\n        index: null,\n        value: this.generateHash(conf.balanceKey)\n    }, function (a, b) {\n        return a.value - b.value;\n    });\n    if (ringIndex < 0) {\n        ringIndex = -ringIndex - 1;\n    }\n    ringIndex = Math.min(ringIndex, balanceContext.hashring.length - 1);\n    var index = balanceContext.hashring[ringIndex].index;\n    logger.trace('RandomBalance fetchServer index=' + index + ' ServiceID=' + balanceContext.serviceID);\n    return servers[index];\n};\n\n```\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/core/fetch-server.html","comments":1,"layout":"page","_id":"cjyd4skjg00166lq1r4mh9b8v","content":"<h3 id=\"1-roundrobin\"><a class=\"markdown-anchor\" href=\"#1-roundrobin\">#</a> 1. roundrobin</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">RoundRobinBalance.prototype.fetchServer = function (balanceContext) &#123;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    balanceContext.lastRoundRobinID = balanceContext.lastRoundRobinID || 0;</span><br><span class=\"line\">    balanceContext.lastRoundRobinID++;</span><br><span class=\"line\">    if (balanceContext.lastRoundRobinID &lt; 0 || balanceContext.lastRoundRobinID &gt;= servers.length) &#123;</span><br><span class=\"line\">        balanceContext.lastRoundRobinID = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.trace(</span><br><span class=\"line\">        [&apos;RoundRobinBalance fetchServer RoundRobinID=&apos;, balanceContext.lastRoundRobinID, &apos; ServiceID=&apos;,</span><br><span class=\"line\">            balanceContext.serviceID</span><br><span class=\"line\">        ].join(&apos;&apos;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    return servers[balanceContext.lastRoundRobinID];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-random\"><a class=\"markdown-anchor\" href=\"#2-random\">#</a> 2. random</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">RandomBalance.prototype.fetchServer = function (balanceContext) &#123;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // Math.random takes 250ms on first call</span><br><span class=\"line\">    var index = Math.floor(Math.random() * servers.length);</span><br><span class=\"line\">    logger.trace(&apos;RandomBalance fetchServer index=&apos; + index + &apos; ServiceID=&apos; + balanceContext.serviceID);</span><br><span class=\"line\">    // TODO add server filter</span><br><span class=\"line\">    return servers[index];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-hashring\"><a class=\"markdown-anchor\" href=\"#3-hashring\">#</a> 3. hashring</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HashringBalance.prototype.fetchServer = function (balanceContext, conf, prevBackend) &#123;</span><br><span class=\"line\">    if (conf.balanceKey === undefined || conf.balanceKey === null) &#123;</span><br><span class=\"line\">        throw new Error(&apos;balanceKey is needed when using consistent hashing&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!balanceContext.hashring) &#123;</span><br><span class=\"line\">        balanceContext.hashring = this.createHashring(balanceContext.reqIDCServers);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var ringIndex = bs(balanceContext.hashring, &#123;</span><br><span class=\"line\">        index: null,</span><br><span class=\"line\">        value: this.generateHash(conf.balanceKey)</span><br><span class=\"line\">    &#125;, function (a, b) &#123;</span><br><span class=\"line\">        return a.value - b.value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    if (ringIndex &lt; 0) &#123;</span><br><span class=\"line\">        ringIndex = -ringIndex - 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ringIndex = Math.min(ringIndex, balanceContext.hashring.length - 1);</span><br><span class=\"line\">    var index = balanceContext.hashring[ringIndex].index;</span><br><span class=\"line\">    logger.trace(&apos;RandomBalance fetchServer index=&apos; + index + &apos; ServiceID=&apos; + balanceContext.serviceID);</span><br><span class=\"line\">    return servers[index];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<h3 id=\"1-roundrobin\"><a class=\"markdown-anchor\" href=\"#1-roundrobin\">#</a> 1. roundrobin</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">RoundRobinBalance.prototype.fetchServer = function (balanceContext) &#123;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    balanceContext.lastRoundRobinID = balanceContext.lastRoundRobinID || 0;</span><br><span class=\"line\">    balanceContext.lastRoundRobinID++;</span><br><span class=\"line\">    if (balanceContext.lastRoundRobinID &lt; 0 || balanceContext.lastRoundRobinID &gt;= servers.length) &#123;</span><br><span class=\"line\">        balanceContext.lastRoundRobinID = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.trace(</span><br><span class=\"line\">        [&apos;RoundRobinBalance fetchServer RoundRobinID=&apos;, balanceContext.lastRoundRobinID, &apos; ServiceID=&apos;,</span><br><span class=\"line\">            balanceContext.serviceID</span><br><span class=\"line\">        ].join(&apos;&apos;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    return servers[balanceContext.lastRoundRobinID];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-random\"><a class=\"markdown-anchor\" href=\"#2-random\">#</a> 2. random</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">RandomBalance.prototype.fetchServer = function (balanceContext) &#123;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // Math.random takes 250ms on first call</span><br><span class=\"line\">    var index = Math.floor(Math.random() * servers.length);</span><br><span class=\"line\">    logger.trace(&apos;RandomBalance fetchServer index=&apos; + index + &apos; ServiceID=&apos; + balanceContext.serviceID);</span><br><span class=\"line\">    // TODO add server filter</span><br><span class=\"line\">    return servers[index];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-hashring\"><a class=\"markdown-anchor\" href=\"#3-hashring\">#</a> 3. hashring</h3>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HashringBalance.prototype.fetchServer = function (balanceContext, conf, prevBackend) &#123;</span><br><span class=\"line\">    if (conf.balanceKey === undefined || conf.balanceKey === null) &#123;</span><br><span class=\"line\">        throw new Error(&apos;balanceKey is needed when using consistent hashing&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var servers = balanceContext.reqIDCServers;</span><br><span class=\"line\">    if (servers.length === 1) &#123;</span><br><span class=\"line\">        return servers[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!balanceContext.hashring) &#123;</span><br><span class=\"line\">        balanceContext.hashring = this.createHashring(balanceContext.reqIDCServers);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var ringIndex = bs(balanceContext.hashring, &#123;</span><br><span class=\"line\">        index: null,</span><br><span class=\"line\">        value: this.generateHash(conf.balanceKey)</span><br><span class=\"line\">    &#125;, function (a, b) &#123;</span><br><span class=\"line\">        return a.value - b.value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    if (ringIndex &lt; 0) &#123;</span><br><span class=\"line\">        ringIndex = -ringIndex - 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ringIndex = Math.min(ringIndex, balanceContext.hashring.length - 1);</span><br><span class=\"line\">    var index = balanceContext.hashring[ringIndex].index;</span><br><span class=\"line\">    logger.trace(&apos;RandomBalance fetchServer index=&apos; + index + &apos; ServiceID=&apos; + balanceContext.serviceID);</span><br><span class=\"line\">    return servers[index];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"框架开发","_content":"\n\n","source":"zh-cn/docs/core/framework.md","raw":"title: 框架开发\n---\n\n\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/core/framework.html","comments":1,"layout":"page","_id":"cjyd4skjh00176lq1vkewzjcc","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"插件开发","_content":"\n插件机制是我们框架的一大特色。它不但可以保证框架核心的足够精简、稳定、高效，还可以促进业务逻辑的复用，生态圈的形成。有人可能会问了\n\n> Koa 已经有了中间件的机制，为啥还要插件呢？\n> 中间件、插件、应用它们之间是什么关系，有什么区别？\n> 我该怎么使用一个插件？\n> 如何编写一个插件？\n> ...\n\n接下来我们就来逐一讨论\n\n## 为什么要插件\n\n我们在使用 Koa 中间件过程中发现了下面一些问题：\n\n1. 中间件加载其实是有先后顺序的，但是中间件自身却无法管理这种顺序，只能交给使用者。这样其实非常不友好，一旦顺序不对，结果可能有天壤之别。\n2. 中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：定时任务、消息订阅、后台逻辑等等。\n3. 有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。\n\n综上所述，我们需要一套更加强大的机制，来管理、编排那些相对独立的业务逻辑。\n\n## 什么是插件\n\n一个插件其实就是一个『迷你的应用』，下面展示的是一个插件的目录结构，和应用（app）几乎一样。\n\n```js\n. hello-plugin\n├── package.json\n├── app.js (可选)\n├── agent.js (可选)\n├── app\n│   ├── extend (可选)\n│   |   ├── helper.js (可选)\n│   |   ├── request.js (可选)\n│   |   ├── response.js (可选)\n│   |   ├── context.js (可选)\n│   |   ├── application.js (可选)\n│   |   └── agent.js (可选)\n│   ├── service (可选)\n│   └── middleware (可选)\n│       └── mw.js\n├── config\n|   ├── config.default.js\n│   ├── config.prod.js\n|   ├── config.test.js (可选)\n|   ├── config.local.js (可选)\n|   └── config.unittest.js (可选)\n└── test\n    └── middleware\n        └── mw.test.js\n```\n\n那区别在哪儿呢？\n\n1. 插件没有独立的 router 和 controller。这主要出于几点考虑：\n\n    - 路由一般和应用强绑定的，不具备通用性。\n    - 一个应用可能依赖很多个插件，如果插件支持路由可能导致路由冲突。\n    - 如果确实有统一路由的需求，可以考虑在插件里通过中间件来实现。\n\n2. 插件需要在 `package.json` 中的 `eggPlugin` 节点指定插件特有的信息\n\n    - `{String} name` - 插件名（必须配置），具有唯一性，配置依赖关系时会指定依赖插件的 name。\n    - `{Array} dependencies` - 当前插件强依赖的插件列表（如果依赖的插件没找到，应用启动失败）。\n    - `{Array} optionalDependencies` - 当前插件的可选依赖插件列表（如果依赖的插件未开启，只会 warning，不会影响应用启动）。\n    - `{Array} env` - 只有在指定运行环境才能开启，具体有哪些环境可以参考[运行环境](../basics/env.md)。此配置是可选的，一般情况下都不需要配置。\n\n    ```json\n    {\n      \"name\": \"egg-rpc\",\n      \"eggPlugin\": {\n        \"name\": \"rpc\",\n        \"dependencies\": [ \"registry\" ],\n        \"optionalDependencies\": [ \"vip\" ],\n        \"env\": [ \"local\", \"test\", \"unittest\", \"prod\" ]\n      }\n    }\n    ```\n\n## 插件的依赖管理\n\n和中间件不同，插件是自己管理依赖的。应用在加载所有插件前会预先从它们的 `package.json` 中读取 `eggPlugin > dependencies` 和 `eggPlugin > optionalDependencies` 节点，然后根据依赖关系计算出加载顺序，举个例子，下面三个插件的加载顺序就应该是 `c => b => a`\n\n```json\n// plugin a\n{\n  \"name\": \"egg-plugin-a\",\n  \"eggPlugin\": {\n    \"name\": \"a\",\n    \"dependencies\": [ \"b\" ]\n  }\n}\n\n// plugin b\n{\n  \"name\": \"egg-plugin-b\",\n  \"egg-Plugin\": {\n    \"name\": \"b\",\n    \"optionalDependencies\": [ \"c\" ]\n  }\n}\n\n// plugin c\n{\n  \"name\": \"egg-plugin-c\",\n  \"egg-Plugin\": {\n    \"name\": \"c\"\n  }\n}\n```\n\n**注意：`dependencies` 和 `optionalDependencies` 的取值是另一个插件的 `eggPlugin.name`，而不是 `package name`。**\n\n`dependencies` 和 `optionalDependencies` 是从 `npm` 借鉴来的概念，大多数情况下我们都使用 `dependencies`，这也是我们最推荐的依赖方式。那什么时候可以用 `optionalDependencies` 呢？大致就两种：\n\n- 只在某些环境下才依赖，比如：一个鉴权插件，只在开发环境依赖一个 mock 数据的插件\n- 弱依赖，比如：A 依赖 B，但是如果没有 B，A 有相应的降级方案\n\n需要特别强调的是：如果采用 `optionalDependencies` 那么框架不会校验依赖的插件是否开启，它的作用仅仅是计算加载顺序。所以，这时候依赖方需要通过『接口探测』等方式来决定相应的处理逻辑。\n\n## 插件能做什么？\n\n上面给出了插件的定义，那插件到底能做什么？\n\n### 扩展内置对象的接口\n\n在插件相应的文件内对框架内置对象进行扩展，和应用一样\n\n- `app/extend/request.js` - 扩展 Koa#Request 类\n- `app/extend/response.js` - 扩展 Koa#Response 类\n- `app/extend/context.js` - 扩展 Koa#Context 类\n- `app/extend/helper.js ` - 扩展 Helper 类\n- `app/extend/application.js` - 扩展 Application 类\n- `app/extend/agent.js` - 扩展 Agent 类\n\n### 插入自定义中间件\n\n1. 首先在 `app/middleware` 目录下定义好中间件实现\n\n  ```js\n  'use strict';\n\n  const staticCache = require('koa-static-cache');\n  const assert = require('assert');\n  const mkdirp = require('mkdirp');\n\n  module.exports = (options, app) => {\n    assert.strictEqual(typeof options.dir, 'string', 'Must set `app.config.static.dir` when static plugin enable');\n\n    // ensure directory exists\n    mkdirp.sync(options.dir);\n\n    app.loggers.coreLogger.info('[egg-static] starting static serve %s -> %s', options.prefix, options.dir);\n\n    return staticCache(options);\n  };\n  ```\n\n2. 在 `app.js` 中将中间件插入到合适的位置（例如：下面将 static 中间件放到 bodyParser 之前）\n\n  ```js\n  const assert = require('assert');\n\n  module.exports = app => {\n    // 将 static 中间件放到 bodyParser 之前\n    const index = app.config.coreMiddleware.indexOf('bodyParser');\n    assert(index >= 0, 'bodyParser 中间件必须存在');\n\n    app.config.coreMiddleware.splice(index, 0, 'static');\n  };\n  ```\n\n### 在应用启动时做一些初始化工作\n\n- 我在启动前想读取一些本地配置\n\n  ```js\n  // ${plugin_root}/app.js\n  const fs = require('fs');\n  const path = require('path');\n\n  module.exports = app => {\n    app.customData = fs.readFileSync(path.join(app.config.baseDir, 'data.bin'));\n\n    app.coreLogger.info('read data ok');\n  };\n  ```\n\n- 如果有异步启动逻辑，可以使用 `app.beforeStart` API\n\n  ```js\n  // ${plugin_root}/app.js\n  const MyClient = require('my-client');\n\n  module.exports = app => {\n    app.myClient = new MyClient();\n    app.myClient.on('error', err => {\n      app.coreLogger.error(err);\n    });\n    app.beforeStart(function* () {\n      yield app.myClient.ready();\n      app.coreLogger.info('my client is ready');\n    });\n  };\n  ```\n\n- 也可以添加 agent 启动逻辑，使用 `agent.beforeStart` API\n\n  ```js\n  // ${plugin_root}/agent.js\n  const MyClient = require('my-client');\n\n  module.exports = agent => {\n    agent.myClient = new MyClient();\n    agent.myClient.on('error', err => {\n      agent.coreLogger.error(err);\n    });\n    agent.beforeStart(function* () {\n      yield agent.myClient.ready();\n      agent.coreLogger.info('my client is ready');\n    });\n  };\n  ```\n\n### 设置定时任务\n\n1. 在 `package.json` 里设置依赖 schedule 插件\n\n  ```json\n  {\n    \"name\": \"your-plugin\",\n    \"eggPlugin\": {\n      \"name\": \"your-plugin\",\n      \"dependencies\": [ \"schedule\" ]\n    }\n  }\n  ```\n\n2. 在 `${plugin_root}/app/schedule/` 目录下新建文件，编写你的定时任务\n\n  ```js\n  exports.schedule = {\n    type: 'worker',\n    cron: '0 0 3 * * *',\n    // interval: '1h',\n    // immediate: true,\n  };\n\n  exports.task = function* (ctx) {\n    // your logic code\n  };\n  ```\n\n### 全局实例插件的最佳实践\n\n许多插件的目的都是将一些已有的服务引入到框架中，如 [egg-mysql], [egg-oss]。他们都需要在 app 上创建对应的实例。而在开发这一类的插件时，我们发现存在一些普遍性的问题：\n\n- 在一个应用中同时使用同一个服务的不同实例（连接到两个不同的 MySQL 数据库）。\n- 从其他服务获取配置后动态初始化连接（从配置中心获取到 MySQL 服务地址后再建立连接）。\n\n如果让插件各自实现，可能会出现各种奇怪的配置方式和初始化方式，所以框架提供了 `app.addSingleton(name, creator)` 方法来统一这一类服务的创建。\n\n#### 插件写法\n\n我们将 [egg-mysql] 的实现简化之后来看看如何编写此类插件：\n\n```js\n// egg-mysql/app.js\nmodule.exports = app => {\n  // 第一个参数 mysql 指定了挂载到 app 上的字段，我们可以通过 `app.mysql` 访问到 MySQL singleton 实例\n  // 第二个参数 createMysql 接受两个参数(config, app)，并返回一个 MySQL 的实例\n  app.addSingleton('mysql', createMysql);\n}\n\n/**\n * @param  {Object} config   框架处理之后的配置项，如果应用配置了多个 MySQL 实例，会将每一个配置项分别传入并调用多次 createMysql\n * @param  {Application} app 当前的应用\n * @return {Object}          返回创建的 MySQL 实例\n */\nfunction createMysql(config, app) {\n  assert(config.host && config.port && config.user && config.database);\n  // 创建实例\n  const client = new Mysql(config);\n\n  // 做启动应用前的检查\n  app.beforeStart(function* () {\n    const rows = yield client.query('select now() as currentTime;');\n    const index = count++;\n    app.coreLogger.info(`[egg-mysql] instance[${index}] status OK, rds currentTime: ${rows[0].currentTime}`);\n  });\n\n  return client;\n}\n```\n\n可以看到，插件中我们只需要提供要挂载的字段以及对应服务的初始化方法，所有的配置管理、实例获取方式都由框架封装并统一提供了。\n\n#### 应用层使用方案\n\n##### 单实例\n\n1. 在配置文件中声明 MySQL 的配置。\n\n```js\n// config/config.default.js\nmodule.exports = {\n  mysql: {\n    client: {\n      host: 'mysql.com',\n      port: '3306',\n      user: 'test_user',\n      password: 'test_password',\n      database: 'test',\n    },\n  },\n};\n```\n\n2. 直接通过 `app.mysql` 访问数据库。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.mysql.query(sql, values);\n    },\n  };\n};\n```\n\n##### 多实例\n\n1. 同样需要在配置文件中声明 MySQL 的配置，不过和单实例时不同，配置项中需要有一个 `clients` 字段，分别申明不同实例的配置，同时可以通过 `default` 字段来配置多个实例中共享的配置（如 host 和 port）。\n\n```js\n// config/config.default.js\nexports.mysql = {\n  clients: {\n    // clientId, access the client instance by app.mysql.get('clientId')\n    db1: {\n      user: 'user1',\n      password: 'upassword1',\n      database: 'db1',\n    },\n    db2: {\n      user: 'user2',\n      password: 'upassword2',\n      database: 'db2',\n    },\n  },\n  // default configuration for all databases\n  default: {\n    host: 'mysql.com',\n    port: '3306',\n  },\n};\n```\n\n2. 通过 `app.mysql.get('db1')` 来获取对应的实例并使用。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.mysql.get('db1').query(sql, values);\n    },\n  };\n};\n```\n\n##### 动态创建实例\n\n我们可以不需要将配置提前申明在配置文件中，而是在应用运行时动态的初始化一个实例。\n\n```js\n// app.js\nmodule.exports = app => {\n  app.beforeStart(function* () {\n    // 从配置中心获取 MySQL 的配置 { host, post, password, ... }\n    const mysqlConfig = yield app.configCenter.fetch('mysql');\n    // 动态创建 MySQL 实例\n    app.database = app.mysql.createInstance(mysqlConfig);\n  });\n};\n```\n\n通过 `app.database` 来使用这个实例。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.databse.query(sql, values);\n    },\n  };\n};\n```\n\n**注意，在动态创建实例的时候，框架也会读取配置中 `default` 字段内的配置项作为默认配置。**\n\n## 插件使用指南\n\n### 安装\n\n和安装普通 `npm` 包一样\n\n```bash\n$ npm i egg-onerror --save\n```\n\n**注意：插件即使是只在 local 运行的，也需要配置为 dependencies 而不是 devDependencies，否则线上 `npm i --production` 时将无法找到插件。**\n\n### 开启和关闭\n\n在应用的 `${app_root}/config/plugin.js` 文件里配置\n\n```js\nmodule.exports = {\n  onerror: {\n    enable: true,\n    package: 'egg-onerror',\n  },\n};\n```\n\n每个配置项有一下配置参数：\n- `{Boolean} enable` - 是否开启此插件\n- `{String} package` - `npm` 模块名称，允许插件以 `npm` 模块形式引入\n- `{String} path` - 插件绝对路径，跟 package 配置互斥\n- `{Array} env` - 只有在指定运行环境才能开启，会覆盖插件自己的配置\n\n这里稍微讲下 package 和 path 的区别\n\n- package 是 `npm` 方式引入，也是最常见的引入方式\n- path 是绝对路径引入，一般是内置插件，比如：应用内部抽了一个插件，但还没来得及发布到 `npm`，或者是应用自己覆盖了框架的一些插件\n\n_说明：_ 框架内部内置了一些插件，而应用在使用这些插件的时候就不用配置 package 或者 path，只需要指定 enable 与否\n\n```js\n// 对于内置插件，可以用下面的简洁方式开启或关闭\nexports.onerror = false;\n```\n\n框架已内置插件列表：\n\n- [onerror](https://github.com/eggjs/egg-onerror) 统一异常处理\n- [Session](https://github.com/eggjs/egg-session) Session 实现\n- [i18n](https://github.com/eggjs/egg-i18n) 多语言\n- [watcher](https://github.com/eggjs/egg-watcher) 文件和文件夹监控\n- [multipart](https://github.com/eggjs/egg-multipart) 文件流式上传\n- [security](https://github.com/eggjs/egg-security) 安全\n- [development](https://github.com/eggjs/egg-development) 开发环境配置\n- [logrotator](https://github.com/eggjs/egg-logrotator) 日志切分\n- [schedule](https://github.com/eggjs/egg-schedule) 定时任务\n- [static](https://github.com/eggjs/egg-static) 静态服务器\n- [jsonp](https://github.com/eggjs/egg-jsonp) jsonp 支持\n- [view](https://github.com/eggjs/egg-view) 模板引擎\n\n### 根据环境配置\n\n插件还支持 `plugin.{env}.js` 这种模式，会根据[环境](../basics/env.md)加载插件配置。\n\n比如定义了一个开发环境使用的插件 `egg-dev`，只希望在本地环境加载，可以如下定义\n\n```js\n// package.json\n{\n  \"devDependencies\": {\n    \"egg-dev\": \"*\"\n  }\n}\n\n// config/plugin.local.js\nexports.dev = {\n  enable: true,\n  package: 'egg-dev',\n};\n```\n\n这样在生产环境可以不需要下载 `egg-dev` 的包了。\n\n### 插件的寻址规则\n\n框架在加载插件的时候，遵循下面的寻址规则：\n\n- 如果配置了 path，直接按照 path 加载\n- 没有 path 根据 package 名去查找，查找的顺序依次是\n\n  1. 应用根目录下的 `node_modules`\n  2. 应用依赖框架路径下的 `node_modules`\n  3. 当前路径下的 `node_modules` （主要是兼容单元测试场景）\n\n## 插件开发\n\n### 使用脚手架快速开发\n\n你可以直接通过 [egg-init] 选择 [plugin][egg-boilerplate-plugin] 脚手架来快速上手。\n\n```bash\n$ egg-init egg-xxx --type=plugin\n$ cd egg-xxx\n$ npm i\n$ npm test\n```\n\n### 插件规范\n\n我们非常欢迎您贡献新的插件，同时也希望您遵守下面一些规范：\n\n- 命名规范\n  - `npm` 包名以 `egg-` 开头，且为全小写，例如：`egg-xx`。比较长的词组用中划线：`egg-foo-bar`\n  - 对应的插件名使用小驼峰，小驼峰转换规则以 `npm` 包名的中划线为准 `egg-foo-bar` => `fooBar`\n  - 对于可以中划线也可以不用的情况，不做强制约定，例如：userservice(egg-userservice) 还是 user-service(egg-user-service) 都可以\n- `package.json` 书写规范\n  - 按照上面的文档添加 `eggPlugin` 节点\n  - 在 `keywords` 里加上 `egg`、`egg-plugin`、`eggPlugin` 等关键字，便于索引\n\n  ```json\n  {\n    \"name\": \"egg-view-nunjucks\",\n    \"version\": \"1.0.0\",\n    \"description\": \"view plugin for egg\",\n    \"eggPlugin\": {\n      \"name\": \"nunjucks\",\n      \"dep\": [\n        \"security\"\n      ]\n    },\n    \"keywords\": [\n      \"egg\",\n      \"egg-plugin\",\n      \"eggPlugin\",\n      \"egg-plugin-view\",\n      \"egg-view\",\n      \"nunjucks\"\n    ],\n  }\n  ```\n\n## 为何不使用 npm 包名来做插件名？\n\nEgg 是通过 `eggPlugin.name` 来定义插件名的，只在应用或框架具备唯一性，也就是说**多个 npm 包可能有相同的插件名**，为什么这么设计呢？\n\n首先 Egg 插件不仅仅支持 npm 包，还支持通过目录来找插件。在[渐进式开发](../tutorials/progressive.md)章节提到如何使用这两个配置来进行代码演进。目录对单元测试也比较友好。所以 Egg 无法通过 npm 的包名来做唯一性。\n\n更重要的是 Egg 可以使用这种特性来做适配器。比如[模板开发规范](./view-plugin.md#插件命名规范)定义的插件名为 view，而存在 `egg-view-nunjucks`，`egg-view-react` 等插件，使用者只需要更换插件和修改模板，不需要动 Controller， 因为所有的模板插件都实现了相同的 API。\n\n**将相同功能的插件赋予相同的插件名，具备相同的 API，可以快速切换**。这在模板、数据库等领域非常适用。\n\n[egg-init]: https://github.com/eggjs/egg-init\n[egg-boilerplate-plugin]: https://github.com/eggjs/egg-boilerplate-plugin\n[egg-mysql]: https://github.com/eggjs/egg-mysql\n[egg-oss]: https://github.com/eggjs/egg-oss\n","source":"zh-cn/docs/core/plugin.md","raw":"\ntitle: 插件开发\n---\n\n插件机制是我们框架的一大特色。它不但可以保证框架核心的足够精简、稳定、高效，还可以促进业务逻辑的复用，生态圈的形成。有人可能会问了\n\n> Koa 已经有了中间件的机制，为啥还要插件呢？\n> 中间件、插件、应用它们之间是什么关系，有什么区别？\n> 我该怎么使用一个插件？\n> 如何编写一个插件？\n> ...\n\n接下来我们就来逐一讨论\n\n## 为什么要插件\n\n我们在使用 Koa 中间件过程中发现了下面一些问题：\n\n1. 中间件加载其实是有先后顺序的，但是中间件自身却无法管理这种顺序，只能交给使用者。这样其实非常不友好，一旦顺序不对，结果可能有天壤之别。\n2. 中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：定时任务、消息订阅、后台逻辑等等。\n3. 有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。\n\n综上所述，我们需要一套更加强大的机制，来管理、编排那些相对独立的业务逻辑。\n\n## 什么是插件\n\n一个插件其实就是一个『迷你的应用』，下面展示的是一个插件的目录结构，和应用（app）几乎一样。\n\n```js\n. hello-plugin\n├── package.json\n├── app.js (可选)\n├── agent.js (可选)\n├── app\n│   ├── extend (可选)\n│   |   ├── helper.js (可选)\n│   |   ├── request.js (可选)\n│   |   ├── response.js (可选)\n│   |   ├── context.js (可选)\n│   |   ├── application.js (可选)\n│   |   └── agent.js (可选)\n│   ├── service (可选)\n│   └── middleware (可选)\n│       └── mw.js\n├── config\n|   ├── config.default.js\n│   ├── config.prod.js\n|   ├── config.test.js (可选)\n|   ├── config.local.js (可选)\n|   └── config.unittest.js (可选)\n└── test\n    └── middleware\n        └── mw.test.js\n```\n\n那区别在哪儿呢？\n\n1. 插件没有独立的 router 和 controller。这主要出于几点考虑：\n\n    - 路由一般和应用强绑定的，不具备通用性。\n    - 一个应用可能依赖很多个插件，如果插件支持路由可能导致路由冲突。\n    - 如果确实有统一路由的需求，可以考虑在插件里通过中间件来实现。\n\n2. 插件需要在 `package.json` 中的 `eggPlugin` 节点指定插件特有的信息\n\n    - `{String} name` - 插件名（必须配置），具有唯一性，配置依赖关系时会指定依赖插件的 name。\n    - `{Array} dependencies` - 当前插件强依赖的插件列表（如果依赖的插件没找到，应用启动失败）。\n    - `{Array} optionalDependencies` - 当前插件的可选依赖插件列表（如果依赖的插件未开启，只会 warning，不会影响应用启动）。\n    - `{Array} env` - 只有在指定运行环境才能开启，具体有哪些环境可以参考[运行环境](../basics/env.md)。此配置是可选的，一般情况下都不需要配置。\n\n    ```json\n    {\n      \"name\": \"egg-rpc\",\n      \"eggPlugin\": {\n        \"name\": \"rpc\",\n        \"dependencies\": [ \"registry\" ],\n        \"optionalDependencies\": [ \"vip\" ],\n        \"env\": [ \"local\", \"test\", \"unittest\", \"prod\" ]\n      }\n    }\n    ```\n\n## 插件的依赖管理\n\n和中间件不同，插件是自己管理依赖的。应用在加载所有插件前会预先从它们的 `package.json` 中读取 `eggPlugin > dependencies` 和 `eggPlugin > optionalDependencies` 节点，然后根据依赖关系计算出加载顺序，举个例子，下面三个插件的加载顺序就应该是 `c => b => a`\n\n```json\n// plugin a\n{\n  \"name\": \"egg-plugin-a\",\n  \"eggPlugin\": {\n    \"name\": \"a\",\n    \"dependencies\": [ \"b\" ]\n  }\n}\n\n// plugin b\n{\n  \"name\": \"egg-plugin-b\",\n  \"egg-Plugin\": {\n    \"name\": \"b\",\n    \"optionalDependencies\": [ \"c\" ]\n  }\n}\n\n// plugin c\n{\n  \"name\": \"egg-plugin-c\",\n  \"egg-Plugin\": {\n    \"name\": \"c\"\n  }\n}\n```\n\n**注意：`dependencies` 和 `optionalDependencies` 的取值是另一个插件的 `eggPlugin.name`，而不是 `package name`。**\n\n`dependencies` 和 `optionalDependencies` 是从 `npm` 借鉴来的概念，大多数情况下我们都使用 `dependencies`，这也是我们最推荐的依赖方式。那什么时候可以用 `optionalDependencies` 呢？大致就两种：\n\n- 只在某些环境下才依赖，比如：一个鉴权插件，只在开发环境依赖一个 mock 数据的插件\n- 弱依赖，比如：A 依赖 B，但是如果没有 B，A 有相应的降级方案\n\n需要特别强调的是：如果采用 `optionalDependencies` 那么框架不会校验依赖的插件是否开启，它的作用仅仅是计算加载顺序。所以，这时候依赖方需要通过『接口探测』等方式来决定相应的处理逻辑。\n\n## 插件能做什么？\n\n上面给出了插件的定义，那插件到底能做什么？\n\n### 扩展内置对象的接口\n\n在插件相应的文件内对框架内置对象进行扩展，和应用一样\n\n- `app/extend/request.js` - 扩展 Koa#Request 类\n- `app/extend/response.js` - 扩展 Koa#Response 类\n- `app/extend/context.js` - 扩展 Koa#Context 类\n- `app/extend/helper.js ` - 扩展 Helper 类\n- `app/extend/application.js` - 扩展 Application 类\n- `app/extend/agent.js` - 扩展 Agent 类\n\n### 插入自定义中间件\n\n1. 首先在 `app/middleware` 目录下定义好中间件实现\n\n  ```js\n  'use strict';\n\n  const staticCache = require('koa-static-cache');\n  const assert = require('assert');\n  const mkdirp = require('mkdirp');\n\n  module.exports = (options, app) => {\n    assert.strictEqual(typeof options.dir, 'string', 'Must set `app.config.static.dir` when static plugin enable');\n\n    // ensure directory exists\n    mkdirp.sync(options.dir);\n\n    app.loggers.coreLogger.info('[egg-static] starting static serve %s -> %s', options.prefix, options.dir);\n\n    return staticCache(options);\n  };\n  ```\n\n2. 在 `app.js` 中将中间件插入到合适的位置（例如：下面将 static 中间件放到 bodyParser 之前）\n\n  ```js\n  const assert = require('assert');\n\n  module.exports = app => {\n    // 将 static 中间件放到 bodyParser 之前\n    const index = app.config.coreMiddleware.indexOf('bodyParser');\n    assert(index >= 0, 'bodyParser 中间件必须存在');\n\n    app.config.coreMiddleware.splice(index, 0, 'static');\n  };\n  ```\n\n### 在应用启动时做一些初始化工作\n\n- 我在启动前想读取一些本地配置\n\n  ```js\n  // ${plugin_root}/app.js\n  const fs = require('fs');\n  const path = require('path');\n\n  module.exports = app => {\n    app.customData = fs.readFileSync(path.join(app.config.baseDir, 'data.bin'));\n\n    app.coreLogger.info('read data ok');\n  };\n  ```\n\n- 如果有异步启动逻辑，可以使用 `app.beforeStart` API\n\n  ```js\n  // ${plugin_root}/app.js\n  const MyClient = require('my-client');\n\n  module.exports = app => {\n    app.myClient = new MyClient();\n    app.myClient.on('error', err => {\n      app.coreLogger.error(err);\n    });\n    app.beforeStart(function* () {\n      yield app.myClient.ready();\n      app.coreLogger.info('my client is ready');\n    });\n  };\n  ```\n\n- 也可以添加 agent 启动逻辑，使用 `agent.beforeStart` API\n\n  ```js\n  // ${plugin_root}/agent.js\n  const MyClient = require('my-client');\n\n  module.exports = agent => {\n    agent.myClient = new MyClient();\n    agent.myClient.on('error', err => {\n      agent.coreLogger.error(err);\n    });\n    agent.beforeStart(function* () {\n      yield agent.myClient.ready();\n      agent.coreLogger.info('my client is ready');\n    });\n  };\n  ```\n\n### 设置定时任务\n\n1. 在 `package.json` 里设置依赖 schedule 插件\n\n  ```json\n  {\n    \"name\": \"your-plugin\",\n    \"eggPlugin\": {\n      \"name\": \"your-plugin\",\n      \"dependencies\": [ \"schedule\" ]\n    }\n  }\n  ```\n\n2. 在 `${plugin_root}/app/schedule/` 目录下新建文件，编写你的定时任务\n\n  ```js\n  exports.schedule = {\n    type: 'worker',\n    cron: '0 0 3 * * *',\n    // interval: '1h',\n    // immediate: true,\n  };\n\n  exports.task = function* (ctx) {\n    // your logic code\n  };\n  ```\n\n### 全局实例插件的最佳实践\n\n许多插件的目的都是将一些已有的服务引入到框架中，如 [egg-mysql], [egg-oss]。他们都需要在 app 上创建对应的实例。而在开发这一类的插件时，我们发现存在一些普遍性的问题：\n\n- 在一个应用中同时使用同一个服务的不同实例（连接到两个不同的 MySQL 数据库）。\n- 从其他服务获取配置后动态初始化连接（从配置中心获取到 MySQL 服务地址后再建立连接）。\n\n如果让插件各自实现，可能会出现各种奇怪的配置方式和初始化方式，所以框架提供了 `app.addSingleton(name, creator)` 方法来统一这一类服务的创建。\n\n#### 插件写法\n\n我们将 [egg-mysql] 的实现简化之后来看看如何编写此类插件：\n\n```js\n// egg-mysql/app.js\nmodule.exports = app => {\n  // 第一个参数 mysql 指定了挂载到 app 上的字段，我们可以通过 `app.mysql` 访问到 MySQL singleton 实例\n  // 第二个参数 createMysql 接受两个参数(config, app)，并返回一个 MySQL 的实例\n  app.addSingleton('mysql', createMysql);\n}\n\n/**\n * @param  {Object} config   框架处理之后的配置项，如果应用配置了多个 MySQL 实例，会将每一个配置项分别传入并调用多次 createMysql\n * @param  {Application} app 当前的应用\n * @return {Object}          返回创建的 MySQL 实例\n */\nfunction createMysql(config, app) {\n  assert(config.host && config.port && config.user && config.database);\n  // 创建实例\n  const client = new Mysql(config);\n\n  // 做启动应用前的检查\n  app.beforeStart(function* () {\n    const rows = yield client.query('select now() as currentTime;');\n    const index = count++;\n    app.coreLogger.info(`[egg-mysql] instance[${index}] status OK, rds currentTime: ${rows[0].currentTime}`);\n  });\n\n  return client;\n}\n```\n\n可以看到，插件中我们只需要提供要挂载的字段以及对应服务的初始化方法，所有的配置管理、实例获取方式都由框架封装并统一提供了。\n\n#### 应用层使用方案\n\n##### 单实例\n\n1. 在配置文件中声明 MySQL 的配置。\n\n```js\n// config/config.default.js\nmodule.exports = {\n  mysql: {\n    client: {\n      host: 'mysql.com',\n      port: '3306',\n      user: 'test_user',\n      password: 'test_password',\n      database: 'test',\n    },\n  },\n};\n```\n\n2. 直接通过 `app.mysql` 访问数据库。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.mysql.query(sql, values);\n    },\n  };\n};\n```\n\n##### 多实例\n\n1. 同样需要在配置文件中声明 MySQL 的配置，不过和单实例时不同，配置项中需要有一个 `clients` 字段，分别申明不同实例的配置，同时可以通过 `default` 字段来配置多个实例中共享的配置（如 host 和 port）。\n\n```js\n// config/config.default.js\nexports.mysql = {\n  clients: {\n    // clientId, access the client instance by app.mysql.get('clientId')\n    db1: {\n      user: 'user1',\n      password: 'upassword1',\n      database: 'db1',\n    },\n    db2: {\n      user: 'user2',\n      password: 'upassword2',\n      database: 'db2',\n    },\n  },\n  // default configuration for all databases\n  default: {\n    host: 'mysql.com',\n    port: '3306',\n  },\n};\n```\n\n2. 通过 `app.mysql.get('db1')` 来获取对应的实例并使用。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.mysql.get('db1').query(sql, values);\n    },\n  };\n};\n```\n\n##### 动态创建实例\n\n我们可以不需要将配置提前申明在配置文件中，而是在应用运行时动态的初始化一个实例。\n\n```js\n// app.js\nmodule.exports = app => {\n  app.beforeStart(function* () {\n    // 从配置中心获取 MySQL 的配置 { host, post, password, ... }\n    const mysqlConfig = yield app.configCenter.fetch('mysql');\n    // 动态创建 MySQL 实例\n    app.database = app.mysql.createInstance(mysqlConfig);\n  });\n};\n```\n\n通过 `app.database` 来使用这个实例。\n\n```js\n// app/controller/post.js\nmodule.exports = app => {\n  return class PostController extends app.Controller {\n    * list() {\n      const posts = yield this.app.databse.query(sql, values);\n    },\n  };\n};\n```\n\n**注意，在动态创建实例的时候，框架也会读取配置中 `default` 字段内的配置项作为默认配置。**\n\n## 插件使用指南\n\n### 安装\n\n和安装普通 `npm` 包一样\n\n```bash\n$ npm i egg-onerror --save\n```\n\n**注意：插件即使是只在 local 运行的，也需要配置为 dependencies 而不是 devDependencies，否则线上 `npm i --production` 时将无法找到插件。**\n\n### 开启和关闭\n\n在应用的 `${app_root}/config/plugin.js` 文件里配置\n\n```js\nmodule.exports = {\n  onerror: {\n    enable: true,\n    package: 'egg-onerror',\n  },\n};\n```\n\n每个配置项有一下配置参数：\n- `{Boolean} enable` - 是否开启此插件\n- `{String} package` - `npm` 模块名称，允许插件以 `npm` 模块形式引入\n- `{String} path` - 插件绝对路径，跟 package 配置互斥\n- `{Array} env` - 只有在指定运行环境才能开启，会覆盖插件自己的配置\n\n这里稍微讲下 package 和 path 的区别\n\n- package 是 `npm` 方式引入，也是最常见的引入方式\n- path 是绝对路径引入，一般是内置插件，比如：应用内部抽了一个插件，但还没来得及发布到 `npm`，或者是应用自己覆盖了框架的一些插件\n\n_说明：_ 框架内部内置了一些插件，而应用在使用这些插件的时候就不用配置 package 或者 path，只需要指定 enable 与否\n\n```js\n// 对于内置插件，可以用下面的简洁方式开启或关闭\nexports.onerror = false;\n```\n\n框架已内置插件列表：\n\n- [onerror](https://github.com/eggjs/egg-onerror) 统一异常处理\n- [Session](https://github.com/eggjs/egg-session) Session 实现\n- [i18n](https://github.com/eggjs/egg-i18n) 多语言\n- [watcher](https://github.com/eggjs/egg-watcher) 文件和文件夹监控\n- [multipart](https://github.com/eggjs/egg-multipart) 文件流式上传\n- [security](https://github.com/eggjs/egg-security) 安全\n- [development](https://github.com/eggjs/egg-development) 开发环境配置\n- [logrotator](https://github.com/eggjs/egg-logrotator) 日志切分\n- [schedule](https://github.com/eggjs/egg-schedule) 定时任务\n- [static](https://github.com/eggjs/egg-static) 静态服务器\n- [jsonp](https://github.com/eggjs/egg-jsonp) jsonp 支持\n- [view](https://github.com/eggjs/egg-view) 模板引擎\n\n### 根据环境配置\n\n插件还支持 `plugin.{env}.js` 这种模式，会根据[环境](../basics/env.md)加载插件配置。\n\n比如定义了一个开发环境使用的插件 `egg-dev`，只希望在本地环境加载，可以如下定义\n\n```js\n// package.json\n{\n  \"devDependencies\": {\n    \"egg-dev\": \"*\"\n  }\n}\n\n// config/plugin.local.js\nexports.dev = {\n  enable: true,\n  package: 'egg-dev',\n};\n```\n\n这样在生产环境可以不需要下载 `egg-dev` 的包了。\n\n### 插件的寻址规则\n\n框架在加载插件的时候，遵循下面的寻址规则：\n\n- 如果配置了 path，直接按照 path 加载\n- 没有 path 根据 package 名去查找，查找的顺序依次是\n\n  1. 应用根目录下的 `node_modules`\n  2. 应用依赖框架路径下的 `node_modules`\n  3. 当前路径下的 `node_modules` （主要是兼容单元测试场景）\n\n## 插件开发\n\n### 使用脚手架快速开发\n\n你可以直接通过 [egg-init] 选择 [plugin][egg-boilerplate-plugin] 脚手架来快速上手。\n\n```bash\n$ egg-init egg-xxx --type=plugin\n$ cd egg-xxx\n$ npm i\n$ npm test\n```\n\n### 插件规范\n\n我们非常欢迎您贡献新的插件，同时也希望您遵守下面一些规范：\n\n- 命名规范\n  - `npm` 包名以 `egg-` 开头，且为全小写，例如：`egg-xx`。比较长的词组用中划线：`egg-foo-bar`\n  - 对应的插件名使用小驼峰，小驼峰转换规则以 `npm` 包名的中划线为准 `egg-foo-bar` => `fooBar`\n  - 对于可以中划线也可以不用的情况，不做强制约定，例如：userservice(egg-userservice) 还是 user-service(egg-user-service) 都可以\n- `package.json` 书写规范\n  - 按照上面的文档添加 `eggPlugin` 节点\n  - 在 `keywords` 里加上 `egg`、`egg-plugin`、`eggPlugin` 等关键字，便于索引\n\n  ```json\n  {\n    \"name\": \"egg-view-nunjucks\",\n    \"version\": \"1.0.0\",\n    \"description\": \"view plugin for egg\",\n    \"eggPlugin\": {\n      \"name\": \"nunjucks\",\n      \"dep\": [\n        \"security\"\n      ]\n    },\n    \"keywords\": [\n      \"egg\",\n      \"egg-plugin\",\n      \"eggPlugin\",\n      \"egg-plugin-view\",\n      \"egg-view\",\n      \"nunjucks\"\n    ],\n  }\n  ```\n\n## 为何不使用 npm 包名来做插件名？\n\nEgg 是通过 `eggPlugin.name` 来定义插件名的，只在应用或框架具备唯一性，也就是说**多个 npm 包可能有相同的插件名**，为什么这么设计呢？\n\n首先 Egg 插件不仅仅支持 npm 包，还支持通过目录来找插件。在[渐进式开发](../tutorials/progressive.md)章节提到如何使用这两个配置来进行代码演进。目录对单元测试也比较友好。所以 Egg 无法通过 npm 的包名来做唯一性。\n\n更重要的是 Egg 可以使用这种特性来做适配器。比如[模板开发规范](./view-plugin.md#插件命名规范)定义的插件名为 view，而存在 `egg-view-nunjucks`，`egg-view-react` 等插件，使用者只需要更换插件和修改模板，不需要动 Controller， 因为所有的模板插件都实现了相同的 API。\n\n**将相同功能的插件赋予相同的插件名，具备相同的 API，可以快速切换**。这在模板、数据库等领域非常适用。\n\n[egg-init]: https://github.com/eggjs/egg-init\n[egg-boilerplate-plugin]: https://github.com/eggjs/egg-boilerplate-plugin\n[egg-mysql]: https://github.com/eggjs/egg-mysql\n[egg-oss]: https://github.com/eggjs/egg-oss\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/core/plugin.html","comments":1,"layout":"page","_id":"cjyd4skjj00186lq18l9mw5dy","content":"<p>插件机制是我们框架的一大特色。它不但可以保证框架核心的足够精简、稳定、高效，还可以促进业务逻辑的复用，生态圈的形成。有人可能会问了</p>\n<blockquote>\n<p>Koa 已经有了中间件的机制，为啥还要插件呢？\n中间件、插件、应用它们之间是什么关系，有什么区别？\n我该怎么使用一个插件？\n如何编写一个插件？\n...</p>\n</blockquote>\n<p>接下来我们就来逐一讨论</p>\n<h2 id=\"为什么要插件\"><a class=\"markdown-anchor\" href=\"#为什么要插件\">#</a> 为什么要插件</h2>\n<p>我们在使用 Koa 中间件过程中发现了下面一些问题：</p>\n<ol>\n<li>中间件加载其实是有先后顺序的，但是中间件自身却无法管理这种顺序，只能交给使用者。这样其实非常不友好，一旦顺序不对，结果可能有天壤之别。</li>\n<li>中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：定时任务、消息订阅、后台逻辑等等。</li>\n<li>有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。</li>\n</ol>\n<p>综上所述，我们需要一套更加强大的机制，来管理、编排那些相对独立的业务逻辑。</p>\n<h2 id=\"什么是插件\"><a class=\"markdown-anchor\" href=\"#什么是插件\">#</a> 什么是插件</h2>\n<p>一个插件其实就是一个『迷你的应用』，下面展示的是一个插件的目录结构，和应用（app）几乎一样。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">. hello-plugin</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── app.js (可选)</span><br><span class=\"line\">├── agent.js (可选)</span><br><span class=\"line\">├── app</span><br><span class=\"line\">│   ├── extend (可选)</span><br><span class=\"line\">│   |   ├── helper.js (可选)</span><br><span class=\"line\">│   |   ├── request.js (可选)</span><br><span class=\"line\">│   |   ├── response.js (可选)</span><br><span class=\"line\">│   |   ├── context.js (可选)</span><br><span class=\"line\">│   |   ├── application.js (可选)</span><br><span class=\"line\">│   |   └── agent.js (可选)</span><br><span class=\"line\">│   ├── service (可选)</span><br><span class=\"line\">│   └── middleware (可选)</span><br><span class=\"line\">│       └── mw.js</span><br><span class=\"line\">├── config</span><br><span class=\"line\">|   ├── config.default.js</span><br><span class=\"line\">│   ├── config.prod.js</span><br><span class=\"line\">|   ├── config.test.js (可选)</span><br><span class=\"line\">|   ├── config.local.js (可选)</span><br><span class=\"line\">|   └── config.unittest.js (可选)</span><br><span class=\"line\">└── test</span><br><span class=\"line\">    └── middleware</span><br><span class=\"line\">        └── mw.test.js</span><br></pre></td></tr></table></figure></p>\n<p>那区别在哪儿呢？</p>\n<ol>\n<li>\n<p>插件没有独立的 router 和 controller。这主要出于几点考虑：</p>\n<ul>\n<li>路由一般和应用强绑定的，不具备通用性。</li>\n<li>一个应用可能依赖很多个插件，如果插件支持路由可能导致路由冲突。</li>\n<li>如果确实有统一路由的需求，可以考虑在插件里通过中间件来实现。</li>\n</ul>\n</li>\n<li>\n<p>插件需要在 <code>package.json</code> 中的 <code>eggPlugin</code> 节点指定插件特有的信息</p>\n<ul>\n<li><code>{String} name</code> - 插件名（必须配置），具有唯一性，配置依赖关系时会指定依赖插件的 name。</li>\n<li><code>{Array} dependencies</code> - 当前插件强依赖的插件列表（如果依赖的插件没找到，应用启动失败）。</li>\n<li><code>{Array} optionalDependencies</code> - 当前插件的可选依赖插件列表（如果依赖的插件未开启，只会 warning，不会影响应用启动）。</li>\n<li><code>{Array} env</code> - 只有在指定运行环境才能开启，具体有哪些环境可以参考<a href=\"../basics/env.html\">运行环境</a>。此配置是可选的，一般情况下都不需要配置。</li>\n</ul>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-rpc\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"rpc\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"registry\"</span> ],</span><br><span class=\"line\">    <span class=\"attr\">\"optionalDependencies\"</span>: [ <span class=\"string\">\"vip\"</span> ],</span><br><span class=\"line\">    <span class=\"attr\">\"env\"</span>: [ <span class=\"string\">\"local\"</span>, <span class=\"string\">\"test\"</span>, <span class=\"string\">\"unittest\"</span>, <span class=\"string\">\"prod\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ol>\n<h2 id=\"插件的依赖管理\"><a class=\"markdown-anchor\" href=\"#插件的依赖管理\">#</a> 插件的依赖管理</h2>\n<p>和中间件不同，插件是自己管理依赖的。应用在加载所有插件前会预先从它们的 <code>package.json</code> 中读取 <code>eggPlugin &gt; dependencies</code> 和 <code>eggPlugin &gt; optionalDependencies</code> 节点，然后根据依赖关系计算出加载顺序，举个例子，下面三个插件的加载顺序就应该是 <code>c =&gt; b =&gt; a</code></p>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">// plugin a</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-a\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"a\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"b\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// plugin b</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-b\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"egg-Plugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"b\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"optionalDependencies\"</span>: [ <span class=\"string\">\"c\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// plugin c</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-c\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"egg-Plugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"c\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：<code>dependencies</code> 和 <code>optionalDependencies</code> 的取值是另一个插件的 <code>eggPlugin.name</code>，而不是 <code>package name</code>。</strong></p>\n<p><code>dependencies</code> 和 <code>optionalDependencies</code> 是从 <code>npm</code> 借鉴来的概念，大多数情况下我们都使用 <code>dependencies</code>，这也是我们最推荐的依赖方式。那什么时候可以用 <code>optionalDependencies</code> 呢？大致就两种：</p>\n<ul>\n<li>只在某些环境下才依赖，比如：一个鉴权插件，只在开发环境依赖一个 mock 数据的插件</li>\n<li>弱依赖，比如：A 依赖 B，但是如果没有 B，A 有相应的降级方案</li>\n</ul>\n<p>需要特别强调的是：如果采用 <code>optionalDependencies</code> 那么框架不会校验依赖的插件是否开启，它的作用仅仅是计算加载顺序。所以，这时候依赖方需要通过『接口探测』等方式来决定相应的处理逻辑。</p>\n<h2 id=\"插件能做什么\"><a class=\"markdown-anchor\" href=\"#插件能做什么\">#</a> 插件能做什么？</h2>\n<p>上面给出了插件的定义，那插件到底能做什么？</p>\n<h3 id=\"扩展内置对象的接口\"><a class=\"markdown-anchor\" href=\"#扩展内置对象的接口\">#</a> 扩展内置对象的接口</h3>\n<p>在插件相应的文件内对框架内置对象进行扩展，和应用一样</p>\n<ul>\n<li><code>app/extend/request.js</code> - 扩展 Koa#Request 类</li>\n<li><code>app/extend/response.js</code> - 扩展 Koa#Response 类</li>\n<li><code>app/extend/context.js</code> - 扩展 Koa#Context 类</li>\n<li><code>app/extend/helper.js</code> - 扩展 Helper 类</li>\n<li><code>app/extend/application.js</code> - 扩展 Application 类</li>\n<li><code>app/extend/agent.js</code> - 扩展 Agent 类</li>\n</ul>\n<h3 id=\"插入自定义中间件\"><a class=\"markdown-anchor\" href=\"#插入自定义中间件\">#</a> 插入自定义中间件</h3>\n<ol>\n<li>首先在 <code>app/middleware</code> 目录下定义好中间件实现</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> staticCache = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-static-cache'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">'assert'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mkdirp = <span class=\"built_in\">require</span>(<span class=\"string\">'mkdirp'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\">(<span class=\"params\">options, app</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  assert.strictEqual(<span class=\"keyword\">typeof</span> options.dir, <span class=\"string\">'string'</span>, <span class=\"string\">'Must set `app.config.static.dir` when static plugin enable'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ensure directory exists</span></span><br><span class=\"line\">  mkdirp.sync(options.dir);</span><br><span class=\"line\"></span><br><span class=\"line\">  app.loggers.coreLogger.info(<span class=\"string\">'[egg-static] starting static serve %s -&gt; %s'</span>, options.prefix, options.dir);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> staticCache(options);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>在 <code>app.js</code> 中将中间件插入到合适的位置（例如：下面将 static 中间件放到 bodyParser 之前）</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">'assert'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将 static 中间件放到 bodyParser 之前</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> index = app.config.coreMiddleware.indexOf(<span class=\"string\">'bodyParser'</span>);</span><br><span class=\"line\">  assert(index &gt;= <span class=\"number\">0</span>, <span class=\"string\">'bodyParser 中间件必须存在'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  app.config.coreMiddleware.splice(index, <span class=\"number\">0</span>, <span class=\"string\">'static'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"在应用启动时做一些初始化工作\"><a class=\"markdown-anchor\" href=\"#在应用启动时做一些初始化工作\">#</a> 在应用启动时做一些初始化工作</h3>\n<ul>\n<li>\n<p>我在启动前想读取一些本地配置</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.customData = fs.readFileSync(path.join(app.config.baseDir, <span class=\"string\">'data.bin'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  app.coreLogger.info(<span class=\"string\">'read data ok'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>如果有异步启动逻辑，可以使用 <code>app.beforeStart</code> API</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyClient = <span class=\"built_in\">require</span>(<span class=\"string\">'my-client'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.myClient = <span class=\"keyword\">new</span> MyClient();</span><br><span class=\"line\">  app.myClient.on(<span class=\"string\">'error'</span>, err =&gt; &#123;</span><br><span class=\"line\">    app.coreLogger.error(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> app.myClient.ready();</span><br><span class=\"line\">    app.coreLogger.info(<span class=\"string\">'my client is ready'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>也可以添加 agent 启动逻辑，使用 <code>agent.beforeStart</code> API</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/agent.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyClient = <span class=\"built_in\">require</span>(<span class=\"string\">'my-client'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">agent</span> =&gt;</span> &#123;</span><br><span class=\"line\">  agent.myClient = <span class=\"keyword\">new</span> MyClient();</span><br><span class=\"line\">  agent.myClient.on(<span class=\"string\">'error'</span>, err =&gt; &#123;</span><br><span class=\"line\">    agent.coreLogger.error(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  agent.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> agent.myClient.ready();</span><br><span class=\"line\">    agent.coreLogger.info(<span class=\"string\">'my client is ready'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h3 id=\"设置定时任务\"><a class=\"markdown-anchor\" href=\"#设置定时任务\">#</a> 设置定时任务</h3>\n<ol>\n<li>在 <code>package.json</code> 里设置依赖 schedule 插件</li>\n</ol>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"your-plugin\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"your-plugin\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"schedule\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>在 <code>${plugin_root}/app/schedule/</code> 目录下新建文件，编写你的定时任务</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">exports.schedule = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">'worker'</span>,</span><br><span class=\"line\">  cron: <span class=\"string\">'0 0 3 * * *'</span>,</span><br><span class=\"line\">  <span class=\"comment\">// interval: '1h',</span></span><br><span class=\"line\">  <span class=\"comment\">// immediate: true,</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.task = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\">ctx</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// your logic code</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"全局实例插件的最佳实践\"><a class=\"markdown-anchor\" href=\"#全局实例插件的最佳实践\">#</a> 全局实例插件的最佳实践</h3>\n<p>许多插件的目的都是将一些已有的服务引入到框架中，如 <a href=\"https://github.com/eggjs/egg-mysql\" target=\"_blank\" rel=\"noopener\">egg-mysql</a>, <a href=\"https://github.com/eggjs/egg-oss\" target=\"_blank\" rel=\"noopener\">egg-oss</a>。他们都需要在 app 上创建对应的实例。而在开发这一类的插件时，我们发现存在一些普遍性的问题：</p>\n<ul>\n<li>在一个应用中同时使用同一个服务的不同实例（连接到两个不同的 MySQL 数据库）。</li>\n<li>从其他服务获取配置后动态初始化连接（从配置中心获取到 MySQL 服务地址后再建立连接）。</li>\n</ul>\n<p>如果让插件各自实现，可能会出现各种奇怪的配置方式和初始化方式，所以框架提供了 <code>app.addSingleton(name, creator)</code> 方法来统一这一类服务的创建。</p>\n<h4 id=\"插件写法\"><a class=\"markdown-anchor\" href=\"#插件写法\">#</a> 插件写法</h4>\n<p>我们将 <a href=\"https://github.com/eggjs/egg-mysql\" target=\"_blank\" rel=\"noopener\">egg-mysql</a> 的实现简化之后来看看如何编写此类插件：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// egg-mysql/app.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 第一个参数 mysql 指定了挂载到 app 上的字段，我们可以通过 `app.mysql` 访问到 MySQL singleton 实例</span></span><br><span class=\"line\">  <span class=\"comment\">// 第二个参数 createMysql 接受两个参数(config, app)，并返回一个 MySQL 的实例</span></span><br><span class=\"line\">  app.addSingleton(<span class=\"string\">'mysql'</span>, createMysql);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;Object&#125; config   框架处理之后的配置项，如果应用配置了多个 MySQL 实例，会将每一个配置项分别传入并调用多次 createMysql</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;Application&#125; app 当前的应用</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;Object&#125;          返回创建的 MySQL 实例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createMysql</span>(<span class=\"params\">config, app</span>) </span>&#123;</span><br><span class=\"line\">  assert(config.host &amp;&amp; config.port &amp;&amp; config.user &amp;&amp; config.database);</span><br><span class=\"line\">  <span class=\"comment\">// 创建实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> Mysql(config);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 做启动应用前的检查</span></span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> rows = <span class=\"keyword\">yield</span> client.query(<span class=\"string\">'select now() as currentTime;'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = count++;</span><br><span class=\"line\">    app.coreLogger.info(<span class=\"string\">`[egg-mysql] instance[<span class=\"subst\">$&#123;index&#125;</span>] status OK, rds currentTime: <span class=\"subst\">$&#123;rows[<span class=\"number\">0</span>].currentTime&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，插件中我们只需要提供要挂载的字段以及对应服务的初始化方法，所有的配置管理、实例获取方式都由框架封装并统一提供了。</p>\n<h4 id=\"应用层使用方案\"><a class=\"markdown-anchor\" href=\"#应用层使用方案\">#</a> 应用层使用方案</h4>\n<h5 id=\"单实例\"><a class=\"markdown-anchor\" href=\"#单实例\">#</a> 单实例</h5>\n<ol>\n<li>在配置文件中声明 MySQL 的配置。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/config.default.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  mysql: &#123;</span><br><span class=\"line\">    client: &#123;</span><br><span class=\"line\">      host: <span class=\"string\">'mysql.com'</span>,</span><br><span class=\"line\">      port: <span class=\"string\">'3306'</span>,</span><br><span class=\"line\">      user: <span class=\"string\">'test_user'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'test_password'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>直接通过 <code>app.mysql</code> 访问数据库。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.mysql.query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"多实例\"><a class=\"markdown-anchor\" href=\"#多实例\">#</a> 多实例</h5>\n<ol>\n<li>同样需要在配置文件中声明 MySQL 的配置，不过和单实例时不同，配置项中需要有一个 <code>clients</code> 字段，分别申明不同实例的配置，同时可以通过 <code>default</code> 字段来配置多个实例中共享的配置（如 host 和 port）。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/config.default.js</span></span><br><span class=\"line\">exports.mysql = &#123;</span><br><span class=\"line\">  clients: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// clientId, access the client instance by app.mysql.get('clientId')</span></span><br><span class=\"line\">    db1: &#123;</span><br><span class=\"line\">      user: <span class=\"string\">'user1'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'upassword1'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'db1'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    db2: &#123;</span><br><span class=\"line\">      user: <span class=\"string\">'user2'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'upassword2'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'db2'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// default configuration for all databases</span></span><br><span class=\"line\">  <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'mysql.com'</span>,</span><br><span class=\"line\">    port: <span class=\"string\">'3306'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>通过 <code>app.mysql.get('db1')</code> 来获取对应的实例并使用。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.mysql.get(<span class=\"string\">'db1'</span>).query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"动态创建实例\"><a class=\"markdown-anchor\" href=\"#动态创建实例\">#</a> 动态创建实例</h5>\n<p>我们可以不需要将配置提前申明在配置文件中，而是在应用运行时动态的初始化一个实例。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从配置中心获取 MySQL 的配置 &#123; host, post, password, ... &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> mysqlConfig = <span class=\"keyword\">yield</span> app.configCenter.fetch(<span class=\"string\">'mysql'</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 动态创建 MySQL 实例</span></span><br><span class=\"line\">    app.database = app.mysql.createInstance(mysqlConfig);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>通过 <code>app.database</code> 来使用这个实例。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.databse.query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意，在动态创建实例的时候，框架也会读取配置中 <code>default</code> 字段内的配置项作为默认配置。</strong></p>\n<h2 id=\"插件使用指南\"><a class=\"markdown-anchor\" href=\"#插件使用指南\">#</a> 插件使用指南</h2>\n<h3 id=\"安装\"><a class=\"markdown-anchor\" href=\"#安装\">#</a> 安装</h3>\n<p>和安装普通 <code>npm</code> 包一样</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm i egg-onerror --save</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：插件即使是只在 local 运行的，也需要配置为 dependencies 而不是 devDependencies，否则线上 <code>npm i --production</code> 时将无法找到插件。</strong></p>\n<h3 id=\"开启和关闭\"><a class=\"markdown-anchor\" href=\"#开启和关闭\">#</a> 开启和关闭</h3>\n<p>在应用的 <code>${app_root}/config/plugin.js</code> 文件里配置</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  onerror: &#123;</span><br><span class=\"line\">    enable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    package: <span class=\"string\">'egg-onerror'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>每个配置项有一下配置参数：</p>\n<ul>\n<li><code>{Boolean} enable</code> - 是否开启此插件</li>\n<li><code>{String} package</code> - <code>npm</code> 模块名称，允许插件以 <code>npm</code> 模块形式引入</li>\n<li><code>{String} path</code> - 插件绝对路径，跟 package 配置互斥</li>\n<li><code>{Array} env</code> - 只有在指定运行环境才能开启，会覆盖插件自己的配置</li>\n</ul>\n<p>这里稍微讲下 package 和 path 的区别</p>\n<ul>\n<li>package 是 <code>npm</code> 方式引入，也是最常见的引入方式</li>\n<li>path 是绝对路径引入，一般是内置插件，比如：应用内部抽了一个插件，但还没来得及发布到 <code>npm</code>，或者是应用自己覆盖了框架的一些插件</li>\n</ul>\n<p><em>说明：</em> 框架内部内置了一些插件，而应用在使用这些插件的时候就不用配置 package 或者 path，只需要指定 enable 与否</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于内置插件，可以用下面的简洁方式开启或关闭</span></span><br><span class=\"line\">exports.onerror = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure></p>\n<p>框架已内置插件列表：</p>\n<ul>\n<li><a href=\"https://github.com/eggjs/egg-onerror\" target=\"_blank\" rel=\"noopener\">onerror</a> 统一异常处理</li>\n<li><a href=\"https://github.com/eggjs/egg-session\" target=\"_blank\" rel=\"noopener\">Session</a> Session 实现</li>\n<li><a href=\"https://github.com/eggjs/egg-i18n\" target=\"_blank\" rel=\"noopener\">i18n</a> 多语言</li>\n<li><a href=\"https://github.com/eggjs/egg-watcher\" target=\"_blank\" rel=\"noopener\">watcher</a> 文件和文件夹监控</li>\n<li><a href=\"https://github.com/eggjs/egg-multipart\" target=\"_blank\" rel=\"noopener\">multipart</a> 文件流式上传</li>\n<li><a href=\"https://github.com/eggjs/egg-security\" target=\"_blank\" rel=\"noopener\">security</a> 安全</li>\n<li><a href=\"https://github.com/eggjs/egg-development\" target=\"_blank\" rel=\"noopener\">development</a> 开发环境配置</li>\n<li><a href=\"https://github.com/eggjs/egg-logrotator\" target=\"_blank\" rel=\"noopener\">logrotator</a> 日志切分</li>\n<li><a href=\"https://github.com/eggjs/egg-schedule\" target=\"_blank\" rel=\"noopener\">schedule</a> 定时任务</li>\n<li><a href=\"https://github.com/eggjs/egg-static\" target=\"_blank\" rel=\"noopener\">static</a> 静态服务器</li>\n<li><a href=\"https://github.com/eggjs/egg-jsonp\" target=\"_blank\" rel=\"noopener\">jsonp</a> jsonp 支持</li>\n<li><a href=\"https://github.com/eggjs/egg-view\" target=\"_blank\" rel=\"noopener\">view</a> 模板引擎</li>\n</ul>\n<h3 id=\"根据环境配置\"><a class=\"markdown-anchor\" href=\"#根据环境配置\">#</a> 根据环境配置</h3>\n<p>插件还支持 <code>plugin.{env}.js</code> 这种模式，会根据<a href=\"../basics/env.html\">环境</a>加载插件配置。</p>\n<p>比如定义了一个开发环境使用的插件 <code>egg-dev</code>，只希望在本地环境加载，可以如下定义</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"egg-dev\"</span>: <span class=\"string\">\"*\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// config/plugin.local.js</span></span><br><span class=\"line\">exports.dev = &#123;</span><br><span class=\"line\">  enable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  package: <span class=\"string\">'egg-dev'</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样在生产环境可以不需要下载 <code>egg-dev</code> 的包了。</p>\n<h3 id=\"插件的寻址规则\"><a class=\"markdown-anchor\" href=\"#插件的寻址规则\">#</a> 插件的寻址规则</h3>\n<p>框架在加载插件的时候，遵循下面的寻址规则：</p>\n<ul>\n<li>\n<p>如果配置了 path，直接按照 path 加载</p>\n</li>\n<li>\n<p>没有 path 根据 package 名去查找，查找的顺序依次是</p>\n<ol>\n<li>应用根目录下的 <code>node_modules</code></li>\n<li>应用依赖框架路径下的 <code>node_modules</code></li>\n<li>当前路径下的 <code>node_modules</code> （主要是兼容单元测试场景）</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"插件开发\"><a class=\"markdown-anchor\" href=\"#插件开发\">#</a> 插件开发</h2>\n<h3 id=\"使用脚手架快速开发\"><a class=\"markdown-anchor\" href=\"#使用脚手架快速开发\">#</a> 使用脚手架快速开发</h3>\n<p>你可以直接通过 <a href=\"https://github.com/eggjs/egg-init\" target=\"_blank\" rel=\"noopener\">egg-init</a> 选择 <a href=\"https://github.com/eggjs/egg-boilerplate-plugin\" target=\"_blank\" rel=\"noopener\">plugin</a> 脚手架来快速上手。</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ egg-init egg-xxx --<span class=\"built_in\">type</span>=plugin</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> egg-xxx</span><br><span class=\"line\">$ npm i</span><br><span class=\"line\">$ npm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"插件规范\"><a class=\"markdown-anchor\" href=\"#插件规范\">#</a> 插件规范</h3>\n<p>我们非常欢迎您贡献新的插件，同时也希望您遵守下面一些规范：</p>\n<ul>\n<li>\n<p>命名规范</p>\n<ul>\n<li><code>npm</code> 包名以 <code>egg-</code> 开头，且为全小写，例如：<code>egg-xx</code>。比较长的词组用中划线：<code>egg-foo-bar</code></li>\n<li>对应的插件名使用小驼峰，小驼峰转换规则以 <code>npm</code> 包名的中划线为准 <code>egg-foo-bar</code> =&gt; <code>fooBar</code></li>\n<li>对于可以中划线也可以不用的情况，不做强制约定，例如：userservice(egg-userservice) 还是 user-service(egg-user-service) 都可以</li>\n</ul>\n</li>\n<li>\n<p><code>package.json</code> 书写规范</p>\n<ul>\n<li>按照上面的文档添加 <code>eggPlugin</code> 节点</li>\n<li>在 <code>keywords</code> 里加上 <code>egg</code>、<code>egg-plugin</code>、<code>eggPlugin</code> 等关键字，便于索引</li>\n</ul>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-view-nunjucks\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"view plugin for egg\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"nunjucks\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dep\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"security\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"keywords\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-plugin\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"eggPlugin\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-plugin-view\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-view\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"nunjucks\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h2 id=\"为何不使用-npm-包名来做插件名\"><a class=\"markdown-anchor\" href=\"#为何不使用-npm-包名来做插件名\">#</a> 为何不使用 npm 包名来做插件名？</h2>\n<p>Egg 是通过 <code>eggPlugin.name</code> 来定义插件名的，只在应用或框架具备唯一性，也就是说<strong>多个 npm 包可能有相同的插件名</strong>，为什么这么设计呢？</p>\n<p>首先 Egg 插件不仅仅支持 npm 包，还支持通过目录来找插件。在<a href=\"../tutorials/progressive.html\">渐进式开发</a>章节提到如何使用这两个配置来进行代码演进。目录对单元测试也比较友好。所以 Egg 无法通过 npm 的包名来做唯一性。</p>\n<p>更重要的是 Egg 可以使用这种特性来做适配器。比如<a href=\"./view-plugin.html#%E6%8F%92%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83\">模板开发规范</a>定义的插件名为 view，而存在 <code>egg-view-nunjucks</code>，<code>egg-view-react</code> 等插件，使用者只需要更换插件和修改模板，不需要动 Controller， 因为所有的模板插件都实现了相同的 API。</p>\n<p><strong>将相同功能的插件赋予相同的插件名，具备相同的 API，可以快速切换</strong>。这在模板、数据库等领域非常适用。</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>插件机制是我们框架的一大特色。它不但可以保证框架核心的足够精简、稳定、高效，还可以促进业务逻辑的复用，生态圈的形成。有人可能会问了</p>\n<blockquote>\n<p>Koa 已经有了中间件的机制，为啥还要插件呢？\n中间件、插件、应用它们之间是什么关系，有什么区别？\n我该怎么使用一个插件？\n如何编写一个插件？\n...</p>\n</blockquote>\n<p>接下来我们就来逐一讨论</p>\n<h2 id=\"为什么要插件\"><a class=\"markdown-anchor\" href=\"#为什么要插件\">#</a> 为什么要插件</h2>\n<p>我们在使用 Koa 中间件过程中发现了下面一些问题：</p>\n<ol>\n<li>中间件加载其实是有先后顺序的，但是中间件自身却无法管理这种顺序，只能交给使用者。这样其实非常不友好，一旦顺序不对，结果可能有天壤之别。</li>\n<li>中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：定时任务、消息订阅、后台逻辑等等。</li>\n<li>有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。</li>\n</ol>\n<p>综上所述，我们需要一套更加强大的机制，来管理、编排那些相对独立的业务逻辑。</p>\n<h2 id=\"什么是插件\"><a class=\"markdown-anchor\" href=\"#什么是插件\">#</a> 什么是插件</h2>\n<p>一个插件其实就是一个『迷你的应用』，下面展示的是一个插件的目录结构，和应用（app）几乎一样。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">. hello-plugin</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── app.js (可选)</span><br><span class=\"line\">├── agent.js (可选)</span><br><span class=\"line\">├── app</span><br><span class=\"line\">│   ├── extend (可选)</span><br><span class=\"line\">│   |   ├── helper.js (可选)</span><br><span class=\"line\">│   |   ├── request.js (可选)</span><br><span class=\"line\">│   |   ├── response.js (可选)</span><br><span class=\"line\">│   |   ├── context.js (可选)</span><br><span class=\"line\">│   |   ├── application.js (可选)</span><br><span class=\"line\">│   |   └── agent.js (可选)</span><br><span class=\"line\">│   ├── service (可选)</span><br><span class=\"line\">│   └── middleware (可选)</span><br><span class=\"line\">│       └── mw.js</span><br><span class=\"line\">├── config</span><br><span class=\"line\">|   ├── config.default.js</span><br><span class=\"line\">│   ├── config.prod.js</span><br><span class=\"line\">|   ├── config.test.js (可选)</span><br><span class=\"line\">|   ├── config.local.js (可选)</span><br><span class=\"line\">|   └── config.unittest.js (可选)</span><br><span class=\"line\">└── test</span><br><span class=\"line\">    └── middleware</span><br><span class=\"line\">        └── mw.test.js</span><br></pre></td></tr></table></figure></p>\n<p>那区别在哪儿呢？</p>\n<ol>\n<li>\n<p>插件没有独立的 router 和 controller。这主要出于几点考虑：</p>\n<ul>\n<li>路由一般和应用强绑定的，不具备通用性。</li>\n<li>一个应用可能依赖很多个插件，如果插件支持路由可能导致路由冲突。</li>\n<li>如果确实有统一路由的需求，可以考虑在插件里通过中间件来实现。</li>\n</ul>\n</li>\n<li>\n<p>插件需要在 <code>package.json</code> 中的 <code>eggPlugin</code> 节点指定插件特有的信息</p>\n<ul>\n<li><code>{String} name</code> - 插件名（必须配置），具有唯一性，配置依赖关系时会指定依赖插件的 name。</li>\n<li><code>{Array} dependencies</code> - 当前插件强依赖的插件列表（如果依赖的插件没找到，应用启动失败）。</li>\n<li><code>{Array} optionalDependencies</code> - 当前插件的可选依赖插件列表（如果依赖的插件未开启，只会 warning，不会影响应用启动）。</li>\n<li><code>{Array} env</code> - 只有在指定运行环境才能开启，具体有哪些环境可以参考<a href=\"../basics/env.html\">运行环境</a>。此配置是可选的，一般情况下都不需要配置。</li>\n</ul>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-rpc\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"rpc\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"registry\"</span> ],</span><br><span class=\"line\">    <span class=\"attr\">\"optionalDependencies\"</span>: [ <span class=\"string\">\"vip\"</span> ],</span><br><span class=\"line\">    <span class=\"attr\">\"env\"</span>: [ <span class=\"string\">\"local\"</span>, <span class=\"string\">\"test\"</span>, <span class=\"string\">\"unittest\"</span>, <span class=\"string\">\"prod\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ol>\n<h2 id=\"插件的依赖管理\"><a class=\"markdown-anchor\" href=\"#插件的依赖管理\">#</a> 插件的依赖管理</h2>\n<p>和中间件不同，插件是自己管理依赖的。应用在加载所有插件前会预先从它们的 <code>package.json</code> 中读取 <code>eggPlugin &gt; dependencies</code> 和 <code>eggPlugin &gt; optionalDependencies</code> 节点，然后根据依赖关系计算出加载顺序，举个例子，下面三个插件的加载顺序就应该是 <code>c =&gt; b =&gt; a</code></p>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">// plugin a</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-a\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"a\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"b\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// plugin b</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-b\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"egg-Plugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"b\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"optionalDependencies\"</span>: [ <span class=\"string\">\"c\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// plugin c</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-plugin-c\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"egg-Plugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"c\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：<code>dependencies</code> 和 <code>optionalDependencies</code> 的取值是另一个插件的 <code>eggPlugin.name</code>，而不是 <code>package name</code>。</strong></p>\n<p><code>dependencies</code> 和 <code>optionalDependencies</code> 是从 <code>npm</code> 借鉴来的概念，大多数情况下我们都使用 <code>dependencies</code>，这也是我们最推荐的依赖方式。那什么时候可以用 <code>optionalDependencies</code> 呢？大致就两种：</p>\n<ul>\n<li>只在某些环境下才依赖，比如：一个鉴权插件，只在开发环境依赖一个 mock 数据的插件</li>\n<li>弱依赖，比如：A 依赖 B，但是如果没有 B，A 有相应的降级方案</li>\n</ul>\n<p>需要特别强调的是：如果采用 <code>optionalDependencies</code> 那么框架不会校验依赖的插件是否开启，它的作用仅仅是计算加载顺序。所以，这时候依赖方需要通过『接口探测』等方式来决定相应的处理逻辑。</p>\n<h2 id=\"插件能做什么\"><a class=\"markdown-anchor\" href=\"#插件能做什么\">#</a> 插件能做什么？</h2>\n<p>上面给出了插件的定义，那插件到底能做什么？</p>\n<h3 id=\"扩展内置对象的接口\"><a class=\"markdown-anchor\" href=\"#扩展内置对象的接口\">#</a> 扩展内置对象的接口</h3>\n<p>在插件相应的文件内对框架内置对象进行扩展，和应用一样</p>\n<ul>\n<li><code>app/extend/request.js</code> - 扩展 Koa#Request 类</li>\n<li><code>app/extend/response.js</code> - 扩展 Koa#Response 类</li>\n<li><code>app/extend/context.js</code> - 扩展 Koa#Context 类</li>\n<li><code>app/extend/helper.js</code> - 扩展 Helper 类</li>\n<li><code>app/extend/application.js</code> - 扩展 Application 类</li>\n<li><code>app/extend/agent.js</code> - 扩展 Agent 类</li>\n</ul>\n<h3 id=\"插入自定义中间件\"><a class=\"markdown-anchor\" href=\"#插入自定义中间件\">#</a> 插入自定义中间件</h3>\n<ol>\n<li>首先在 <code>app/middleware</code> 目录下定义好中间件实现</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> staticCache = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-static-cache'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">'assert'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mkdirp = <span class=\"built_in\">require</span>(<span class=\"string\">'mkdirp'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\">(<span class=\"params\">options, app</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  assert.strictEqual(<span class=\"keyword\">typeof</span> options.dir, <span class=\"string\">'string'</span>, <span class=\"string\">'Must set `app.config.static.dir` when static plugin enable'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ensure directory exists</span></span><br><span class=\"line\">  mkdirp.sync(options.dir);</span><br><span class=\"line\"></span><br><span class=\"line\">  app.loggers.coreLogger.info(<span class=\"string\">'[egg-static] starting static serve %s -&gt; %s'</span>, options.prefix, options.dir);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> staticCache(options);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>在 <code>app.js</code> 中将中间件插入到合适的位置（例如：下面将 static 中间件放到 bodyParser 之前）</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">'assert'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将 static 中间件放到 bodyParser 之前</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> index = app.config.coreMiddleware.indexOf(<span class=\"string\">'bodyParser'</span>);</span><br><span class=\"line\">  assert(index &gt;= <span class=\"number\">0</span>, <span class=\"string\">'bodyParser 中间件必须存在'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  app.config.coreMiddleware.splice(index, <span class=\"number\">0</span>, <span class=\"string\">'static'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"在应用启动时做一些初始化工作\"><a class=\"markdown-anchor\" href=\"#在应用启动时做一些初始化工作\">#</a> 在应用启动时做一些初始化工作</h3>\n<ul>\n<li>\n<p>我在启动前想读取一些本地配置</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.customData = fs.readFileSync(path.join(app.config.baseDir, <span class=\"string\">'data.bin'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  app.coreLogger.info(<span class=\"string\">'read data ok'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>如果有异步启动逻辑，可以使用 <code>app.beforeStart</code> API</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyClient = <span class=\"built_in\">require</span>(<span class=\"string\">'my-client'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.myClient = <span class=\"keyword\">new</span> MyClient();</span><br><span class=\"line\">  app.myClient.on(<span class=\"string\">'error'</span>, err =&gt; &#123;</span><br><span class=\"line\">    app.coreLogger.error(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> app.myClient.ready();</span><br><span class=\"line\">    app.coreLogger.info(<span class=\"string\">'my client is ready'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>也可以添加 agent 启动逻辑，使用 <code>agent.beforeStart</code> API</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $&#123;plugin_root&#125;/agent.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MyClient = <span class=\"built_in\">require</span>(<span class=\"string\">'my-client'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">agent</span> =&gt;</span> &#123;</span><br><span class=\"line\">  agent.myClient = <span class=\"keyword\">new</span> MyClient();</span><br><span class=\"line\">  agent.myClient.on(<span class=\"string\">'error'</span>, err =&gt; &#123;</span><br><span class=\"line\">    agent.coreLogger.error(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  agent.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> agent.myClient.ready();</span><br><span class=\"line\">    agent.coreLogger.info(<span class=\"string\">'my client is ready'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h3 id=\"设置定时任务\"><a class=\"markdown-anchor\" href=\"#设置定时任务\">#</a> 设置定时任务</h3>\n<ol>\n<li>在 <code>package.json</code> 里设置依赖 schedule 插件</li>\n</ol>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"your-plugin\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"your-plugin\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dependencies\"</span>: [ <span class=\"string\">\"schedule\"</span> ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>在 <code>${plugin_root}/app/schedule/</code> 目录下新建文件，编写你的定时任务</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">exports.schedule = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">'worker'</span>,</span><br><span class=\"line\">  cron: <span class=\"string\">'0 0 3 * * *'</span>,</span><br><span class=\"line\">  <span class=\"comment\">// interval: '1h',</span></span><br><span class=\"line\">  <span class=\"comment\">// immediate: true,</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.task = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\">ctx</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// your logic code</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"全局实例插件的最佳实践\"><a class=\"markdown-anchor\" href=\"#全局实例插件的最佳实践\">#</a> 全局实例插件的最佳实践</h3>\n<p>许多插件的目的都是将一些已有的服务引入到框架中，如 <a href=\"https://github.com/eggjs/egg-mysql\" target=\"_blank\" rel=\"noopener\">egg-mysql</a>, <a href=\"https://github.com/eggjs/egg-oss\" target=\"_blank\" rel=\"noopener\">egg-oss</a>。他们都需要在 app 上创建对应的实例。而在开发这一类的插件时，我们发现存在一些普遍性的问题：</p>\n<ul>\n<li>在一个应用中同时使用同一个服务的不同实例（连接到两个不同的 MySQL 数据库）。</li>\n<li>从其他服务获取配置后动态初始化连接（从配置中心获取到 MySQL 服务地址后再建立连接）。</li>\n</ul>\n<p>如果让插件各自实现，可能会出现各种奇怪的配置方式和初始化方式，所以框架提供了 <code>app.addSingleton(name, creator)</code> 方法来统一这一类服务的创建。</p>\n<h4 id=\"插件写法\"><a class=\"markdown-anchor\" href=\"#插件写法\">#</a> 插件写法</h4>\n<p>我们将 <a href=\"https://github.com/eggjs/egg-mysql\" target=\"_blank\" rel=\"noopener\">egg-mysql</a> 的实现简化之后来看看如何编写此类插件：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// egg-mysql/app.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 第一个参数 mysql 指定了挂载到 app 上的字段，我们可以通过 `app.mysql` 访问到 MySQL singleton 实例</span></span><br><span class=\"line\">  <span class=\"comment\">// 第二个参数 createMysql 接受两个参数(config, app)，并返回一个 MySQL 的实例</span></span><br><span class=\"line\">  app.addSingleton(<span class=\"string\">'mysql'</span>, createMysql);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;Object&#125; config   框架处理之后的配置项，如果应用配置了多个 MySQL 实例，会将每一个配置项分别传入并调用多次 createMysql</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;Application&#125; app 当前的应用</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;Object&#125;          返回创建的 MySQL 实例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createMysql</span>(<span class=\"params\">config, app</span>) </span>&#123;</span><br><span class=\"line\">  assert(config.host &amp;&amp; config.port &amp;&amp; config.user &amp;&amp; config.database);</span><br><span class=\"line\">  <span class=\"comment\">// 创建实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> Mysql(config);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 做启动应用前的检查</span></span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> rows = <span class=\"keyword\">yield</span> client.query(<span class=\"string\">'select now() as currentTime;'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = count++;</span><br><span class=\"line\">    app.coreLogger.info(<span class=\"string\">`[egg-mysql] instance[<span class=\"subst\">$&#123;index&#125;</span>] status OK, rds currentTime: <span class=\"subst\">$&#123;rows[<span class=\"number\">0</span>].currentTime&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，插件中我们只需要提供要挂载的字段以及对应服务的初始化方法，所有的配置管理、实例获取方式都由框架封装并统一提供了。</p>\n<h4 id=\"应用层使用方案\"><a class=\"markdown-anchor\" href=\"#应用层使用方案\">#</a> 应用层使用方案</h4>\n<h5 id=\"单实例\"><a class=\"markdown-anchor\" href=\"#单实例\">#</a> 单实例</h5>\n<ol>\n<li>在配置文件中声明 MySQL 的配置。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/config.default.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  mysql: &#123;</span><br><span class=\"line\">    client: &#123;</span><br><span class=\"line\">      host: <span class=\"string\">'mysql.com'</span>,</span><br><span class=\"line\">      port: <span class=\"string\">'3306'</span>,</span><br><span class=\"line\">      user: <span class=\"string\">'test_user'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'test_password'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>直接通过 <code>app.mysql</code> 访问数据库。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.mysql.query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"多实例\"><a class=\"markdown-anchor\" href=\"#多实例\">#</a> 多实例</h5>\n<ol>\n<li>同样需要在配置文件中声明 MySQL 的配置，不过和单实例时不同，配置项中需要有一个 <code>clients</code> 字段，分别申明不同实例的配置，同时可以通过 <code>default</code> 字段来配置多个实例中共享的配置（如 host 和 port）。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config/config.default.js</span></span><br><span class=\"line\">exports.mysql = &#123;</span><br><span class=\"line\">  clients: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// clientId, access the client instance by app.mysql.get('clientId')</span></span><br><span class=\"line\">    db1: &#123;</span><br><span class=\"line\">      user: <span class=\"string\">'user1'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'upassword1'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'db1'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    db2: &#123;</span><br><span class=\"line\">      user: <span class=\"string\">'user2'</span>,</span><br><span class=\"line\">      password: <span class=\"string\">'upassword2'</span>,</span><br><span class=\"line\">      database: <span class=\"string\">'db2'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// default configuration for all databases</span></span><br><span class=\"line\">  <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'mysql.com'</span>,</span><br><span class=\"line\">    port: <span class=\"string\">'3306'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>通过 <code>app.mysql.get('db1')</code> 来获取对应的实例并使用。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.mysql.get(<span class=\"string\">'db1'</span>).query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"动态创建实例\"><a class=\"markdown-anchor\" href=\"#动态创建实例\">#</a> 动态创建实例</h5>\n<p>我们可以不需要将配置提前申明在配置文件中，而是在应用运行时动态的初始化一个实例。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  app.beforeStart(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从配置中心获取 MySQL 的配置 &#123; host, post, password, ... &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> mysqlConfig = <span class=\"keyword\">yield</span> app.configCenter.fetch(<span class=\"string\">'mysql'</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 动态创建 MySQL 实例</span></span><br><span class=\"line\">    app.database = app.mysql.createInstance(mysqlConfig);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>通过 <code>app.database</code> 来使用这个实例。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app/controller/post.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">app</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostController</span> <span class=\"keyword\">extends</span> <span class=\"title\">app</span>.<span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    * list() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> posts = <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>.app.databse.query(sql, values);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意，在动态创建实例的时候，框架也会读取配置中 <code>default</code> 字段内的配置项作为默认配置。</strong></p>\n<h2 id=\"插件使用指南\"><a class=\"markdown-anchor\" href=\"#插件使用指南\">#</a> 插件使用指南</h2>\n<h3 id=\"安装\"><a class=\"markdown-anchor\" href=\"#安装\">#</a> 安装</h3>\n<p>和安装普通 <code>npm</code> 包一样</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm i egg-onerror --save</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：插件即使是只在 local 运行的，也需要配置为 dependencies 而不是 devDependencies，否则线上 <code>npm i --production</code> 时将无法找到插件。</strong></p>\n<h3 id=\"开启和关闭\"><a class=\"markdown-anchor\" href=\"#开启和关闭\">#</a> 开启和关闭</h3>\n<p>在应用的 <code>${app_root}/config/plugin.js</code> 文件里配置</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  onerror: &#123;</span><br><span class=\"line\">    enable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    package: <span class=\"string\">'egg-onerror'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>每个配置项有一下配置参数：</p>\n<ul>\n<li><code>{Boolean} enable</code> - 是否开启此插件</li>\n<li><code>{String} package</code> - <code>npm</code> 模块名称，允许插件以 <code>npm</code> 模块形式引入</li>\n<li><code>{String} path</code> - 插件绝对路径，跟 package 配置互斥</li>\n<li><code>{Array} env</code> - 只有在指定运行环境才能开启，会覆盖插件自己的配置</li>\n</ul>\n<p>这里稍微讲下 package 和 path 的区别</p>\n<ul>\n<li>package 是 <code>npm</code> 方式引入，也是最常见的引入方式</li>\n<li>path 是绝对路径引入，一般是内置插件，比如：应用内部抽了一个插件，但还没来得及发布到 <code>npm</code>，或者是应用自己覆盖了框架的一些插件</li>\n</ul>\n<p><em>说明：</em> 框架内部内置了一些插件，而应用在使用这些插件的时候就不用配置 package 或者 path，只需要指定 enable 与否</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于内置插件，可以用下面的简洁方式开启或关闭</span></span><br><span class=\"line\">exports.onerror = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure></p>\n<p>框架已内置插件列表：</p>\n<ul>\n<li><a href=\"https://github.com/eggjs/egg-onerror\" target=\"_blank\" rel=\"noopener\">onerror</a> 统一异常处理</li>\n<li><a href=\"https://github.com/eggjs/egg-session\" target=\"_blank\" rel=\"noopener\">Session</a> Session 实现</li>\n<li><a href=\"https://github.com/eggjs/egg-i18n\" target=\"_blank\" rel=\"noopener\">i18n</a> 多语言</li>\n<li><a href=\"https://github.com/eggjs/egg-watcher\" target=\"_blank\" rel=\"noopener\">watcher</a> 文件和文件夹监控</li>\n<li><a href=\"https://github.com/eggjs/egg-multipart\" target=\"_blank\" rel=\"noopener\">multipart</a> 文件流式上传</li>\n<li><a href=\"https://github.com/eggjs/egg-security\" target=\"_blank\" rel=\"noopener\">security</a> 安全</li>\n<li><a href=\"https://github.com/eggjs/egg-development\" target=\"_blank\" rel=\"noopener\">development</a> 开发环境配置</li>\n<li><a href=\"https://github.com/eggjs/egg-logrotator\" target=\"_blank\" rel=\"noopener\">logrotator</a> 日志切分</li>\n<li><a href=\"https://github.com/eggjs/egg-schedule\" target=\"_blank\" rel=\"noopener\">schedule</a> 定时任务</li>\n<li><a href=\"https://github.com/eggjs/egg-static\" target=\"_blank\" rel=\"noopener\">static</a> 静态服务器</li>\n<li><a href=\"https://github.com/eggjs/egg-jsonp\" target=\"_blank\" rel=\"noopener\">jsonp</a> jsonp 支持</li>\n<li><a href=\"https://github.com/eggjs/egg-view\" target=\"_blank\" rel=\"noopener\">view</a> 模板引擎</li>\n</ul>\n<h3 id=\"根据环境配置\"><a class=\"markdown-anchor\" href=\"#根据环境配置\">#</a> 根据环境配置</h3>\n<p>插件还支持 <code>plugin.{env}.js</code> 这种模式，会根据<a href=\"../basics/env.html\">环境</a>加载插件配置。</p>\n<p>比如定义了一个开发环境使用的插件 <code>egg-dev</code>，只希望在本地环境加载，可以如下定义</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"egg-dev\"</span>: <span class=\"string\">\"*\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// config/plugin.local.js</span></span><br><span class=\"line\">exports.dev = &#123;</span><br><span class=\"line\">  enable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  package: <span class=\"string\">'egg-dev'</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样在生产环境可以不需要下载 <code>egg-dev</code> 的包了。</p>\n<h3 id=\"插件的寻址规则\"><a class=\"markdown-anchor\" href=\"#插件的寻址规则\">#</a> 插件的寻址规则</h3>\n<p>框架在加载插件的时候，遵循下面的寻址规则：</p>\n<ul>\n<li>\n<p>如果配置了 path，直接按照 path 加载</p>\n</li>\n<li>\n<p>没有 path 根据 package 名去查找，查找的顺序依次是</p>\n<ol>\n<li>应用根目录下的 <code>node_modules</code></li>\n<li>应用依赖框架路径下的 <code>node_modules</code></li>\n<li>当前路径下的 <code>node_modules</code> （主要是兼容单元测试场景）</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"插件开发\"><a class=\"markdown-anchor\" href=\"#插件开发\">#</a> 插件开发</h2>\n<h3 id=\"使用脚手架快速开发\"><a class=\"markdown-anchor\" href=\"#使用脚手架快速开发\">#</a> 使用脚手架快速开发</h3>\n<p>你可以直接通过 <a href=\"https://github.com/eggjs/egg-init\" target=\"_blank\" rel=\"noopener\">egg-init</a> 选择 <a href=\"https://github.com/eggjs/egg-boilerplate-plugin\" target=\"_blank\" rel=\"noopener\">plugin</a> 脚手架来快速上手。</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ egg-init egg-xxx --<span class=\"built_in\">type</span>=plugin</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> egg-xxx</span><br><span class=\"line\">$ npm i</span><br><span class=\"line\">$ npm <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"插件规范\"><a class=\"markdown-anchor\" href=\"#插件规范\">#</a> 插件规范</h3>\n<p>我们非常欢迎您贡献新的插件，同时也希望您遵守下面一些规范：</p>\n<ul>\n<li>\n<p>命名规范</p>\n<ul>\n<li><code>npm</code> 包名以 <code>egg-</code> 开头，且为全小写，例如：<code>egg-xx</code>。比较长的词组用中划线：<code>egg-foo-bar</code></li>\n<li>对应的插件名使用小驼峰，小驼峰转换规则以 <code>npm</code> 包名的中划线为准 <code>egg-foo-bar</code> =&gt; <code>fooBar</code></li>\n<li>对于可以中划线也可以不用的情况，不做强制约定，例如：userservice(egg-userservice) 还是 user-service(egg-user-service) 都可以</li>\n</ul>\n</li>\n<li>\n<p><code>package.json</code> 书写规范</p>\n<ul>\n<li>按照上面的文档添加 <code>eggPlugin</code> 节点</li>\n<li>在 <code>keywords</code> 里加上 <code>egg</code>、<code>egg-plugin</code>、<code>eggPlugin</code> 等关键字，便于索引</li>\n</ul>\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"egg-view-nunjucks\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"view plugin for egg\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"eggPlugin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"nunjucks\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"dep\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"security\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"keywords\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-plugin\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"eggPlugin\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-plugin-view\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg-view\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"nunjucks\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h2 id=\"为何不使用-npm-包名来做插件名\"><a class=\"markdown-anchor\" href=\"#为何不使用-npm-包名来做插件名\">#</a> 为何不使用 npm 包名来做插件名？</h2>\n<p>Egg 是通过 <code>eggPlugin.name</code> 来定义插件名的，只在应用或框架具备唯一性，也就是说<strong>多个 npm 包可能有相同的插件名</strong>，为什么这么设计呢？</p>\n<p>首先 Egg 插件不仅仅支持 npm 包，还支持通过目录来找插件。在<a href=\"../tutorials/progressive.html\">渐进式开发</a>章节提到如何使用这两个配置来进行代码演进。目录对单元测试也比较友好。所以 Egg 无法通过 npm 的包名来做唯一性。</p>\n<p>更重要的是 Egg 可以使用这种特性来做适配器。比如<a href=\"./view-plugin.html#%E6%8F%92%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83\">模板开发规范</a>定义的插件名为 view，而存在 <code>egg-view-nunjucks</code>，<code>egg-view-react</code> 等插件，使用者只需要更换插件和修改模板，不需要动 Controller， 因为所有的模板插件都实现了相同的 API。</p>\n<p><strong>将相同功能的插件赋予相同的插件名，具备相同的 API，可以快速切换</strong>。这在模板、数据库等领域非常适用。</p>\n"},{"title":"主要工作","_content":"\n通过PM2拆分服务，确保不同服务相互不受影响。\n\n### 1. 改造现有`pm2.json`，支持多app启动\n\n根据当前公有云Node集群现状（机器均为24核），拆分为两个独立服务：\n\n- `nuomi`: 承载糯米组件流量，端口为`8197`，实例数为14\n- `h5`: 承载所有h5模块渲染流量，端口为`8198`,实例数为10\n\n```\n{\n    \"apps\": [{\n        \"exec_interpreter\": \"node\",\n        \"name\": \"nuomi\",\n        \"exec_mode\": \"cluster_mode\",\n        \"instances\": \"14\",\n        \"max_memory_restart\": \"500M\",\n        \"merge_logs\": false,\n        \"script\": \"app.js\",\n        \"ignoreWatch\": [\"pm2\", \"log\", \"node_modules\"],\n        \"env\": {\n            \"NODE_ENV\": \"production\",\n            \"PM2_GRACEFUL_TIMEOUT\": 1000,\n            \"PORT\": 8197,\n            \"DEBUG\": true\n        },\n        \"env_dev\": {\n            \"NODE_ENV\": \"development\",\n            \"DEBUG\": true\n        },\n        \"env_test\": {\n            \"NODE_ENV\": \"qa\"\n        }\n    }, {\n        \"exec_interpreter\": \"node\",\n        \"name\": \"h5\",\n        \"exec_mode\": \"cluster_mode\",\n        \"instances\": \"10\",\n        \"max_memory_restart\": \"500M\",\n        \"merge_logs\": false,\n        \"script\": \"app.js\",\n        \"ignoreWatch\": [\"pm2\", \"log\", \"node_modules\"],\n        \"env\": {\n            \"NODE_ENV\": \"production\",\n            \"PM2_GRACEFUL_TIMEOUT\": 1000,\n            \"PORT\": 8198,\n            \"DEBUG\": true\n        },\n        \"env_dev\": {\n            \"NODE_ENV\": \"development\",\n            \"DEBUG\": true\n        },\n        \"env_test\": {\n            \"NODE_ENV\": \"qa\"\n        }\n    }]\n}\n\n```\n\n### 2. 改造启动脚本，支持业务APP独立重启\n\n    nuomi_restart.sh\n    h5_restart.sh\n\n命令改造：\n\n    bin/control start  // 开启所有服务\n    bin/control stop appname // 关闭某个服务（h5、nuomi）\n    bin/control delete appname // 删除某个服务（h5、nuomi）\n    bin/control restart appname // 重启某个服务\n    bin/control reload appname // 0宕机重启，后续上线重启采用reload方案\n    \n![reload](http://younth.coding.me/static/nodeui/reload.jpeg)\n\n## 上线步骤\n\n### 1. 上线NodeUI服务\n\n- 上线前先确定线上的服务进程名称\n\n- 涉及底层上线，上线前需要先stop/delete掉老的进程，为确保服务稳定，采用先stop，然后上线新的隔离方案，回归正常后，delete老的服务进程。\n\n- 需要review方案，或者直接OP操作删除老的进程。\n- 增加上线模块\n- 绑定上线重启脚本\n\n\n\n### 2. 上线ng rewrite 端口\n\n- 配置新的vip服务\n- 修改rewrite\n\n```\n/home/work/odp_cater/webserver/conf/vhost/\n```\n\n## 重点关注\n\n- 组件业务 \n- h5业务 \n- 日志（pm2+业务，关注日志是否会错乱）\n- 服务稳定（Node进程状态）\n\n## 回滚方案\n\n由于目前公有云回滚可能有坑，回滚过程进程应该不会被杀掉，可能有残留进程，需要杀掉。所以最佳回归方式是**覆盖上线**。涉及的模块：\n\n- fly\n- runtime\n","source":"zh-cn/docs/core/server-isoloton.md","raw":"title: 主要工作\n---\n\n通过PM2拆分服务，确保不同服务相互不受影响。\n\n### 1. 改造现有`pm2.json`，支持多app启动\n\n根据当前公有云Node集群现状（机器均为24核），拆分为两个独立服务：\n\n- `nuomi`: 承载糯米组件流量，端口为`8197`，实例数为14\n- `h5`: 承载所有h5模块渲染流量，端口为`8198`,实例数为10\n\n```\n{\n    \"apps\": [{\n        \"exec_interpreter\": \"node\",\n        \"name\": \"nuomi\",\n        \"exec_mode\": \"cluster_mode\",\n        \"instances\": \"14\",\n        \"max_memory_restart\": \"500M\",\n        \"merge_logs\": false,\n        \"script\": \"app.js\",\n        \"ignoreWatch\": [\"pm2\", \"log\", \"node_modules\"],\n        \"env\": {\n            \"NODE_ENV\": \"production\",\n            \"PM2_GRACEFUL_TIMEOUT\": 1000,\n            \"PORT\": 8197,\n            \"DEBUG\": true\n        },\n        \"env_dev\": {\n            \"NODE_ENV\": \"development\",\n            \"DEBUG\": true\n        },\n        \"env_test\": {\n            \"NODE_ENV\": \"qa\"\n        }\n    }, {\n        \"exec_interpreter\": \"node\",\n        \"name\": \"h5\",\n        \"exec_mode\": \"cluster_mode\",\n        \"instances\": \"10\",\n        \"max_memory_restart\": \"500M\",\n        \"merge_logs\": false,\n        \"script\": \"app.js\",\n        \"ignoreWatch\": [\"pm2\", \"log\", \"node_modules\"],\n        \"env\": {\n            \"NODE_ENV\": \"production\",\n            \"PM2_GRACEFUL_TIMEOUT\": 1000,\n            \"PORT\": 8198,\n            \"DEBUG\": true\n        },\n        \"env_dev\": {\n            \"NODE_ENV\": \"development\",\n            \"DEBUG\": true\n        },\n        \"env_test\": {\n            \"NODE_ENV\": \"qa\"\n        }\n    }]\n}\n\n```\n\n### 2. 改造启动脚本，支持业务APP独立重启\n\n    nuomi_restart.sh\n    h5_restart.sh\n\n命令改造：\n\n    bin/control start  // 开启所有服务\n    bin/control stop appname // 关闭某个服务（h5、nuomi）\n    bin/control delete appname // 删除某个服务（h5、nuomi）\n    bin/control restart appname // 重启某个服务\n    bin/control reload appname // 0宕机重启，后续上线重启采用reload方案\n    \n![reload](http://younth.coding.me/static/nodeui/reload.jpeg)\n\n## 上线步骤\n\n### 1. 上线NodeUI服务\n\n- 上线前先确定线上的服务进程名称\n\n- 涉及底层上线，上线前需要先stop/delete掉老的进程，为确保服务稳定，采用先stop，然后上线新的隔离方案，回归正常后，delete老的服务进程。\n\n- 需要review方案，或者直接OP操作删除老的进程。\n- 增加上线模块\n- 绑定上线重启脚本\n\n\n\n### 2. 上线ng rewrite 端口\n\n- 配置新的vip服务\n- 修改rewrite\n\n```\n/home/work/odp_cater/webserver/conf/vhost/\n```\n\n## 重点关注\n\n- 组件业务 \n- h5业务 \n- 日志（pm2+业务，关注日志是否会错乱）\n- 服务稳定（Node进程状态）\n\n## 回滚方案\n\n由于目前公有云回滚可能有坑，回滚过程进程应该不会被杀掉，可能有残留进程，需要杀掉。所以最佳回归方式是**覆盖上线**。涉及的模块：\n\n- fly\n- runtime\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/core/server-isoloton.html","comments":1,"layout":"page","_id":"cjyd4skjk00196lq1u64rb85h","content":"<p>通过PM2拆分服务，确保不同服务相互不受影响。</p>\n<h3 id=\"1-改造现有pm2json支持多app启动\"><a class=\"markdown-anchor\" href=\"#1-改造现有pm2json支持多app启动\">#</a> 1. 改造现有<code>pm2.json</code>，支持多app启动</h3>\n<p>根据当前公有云Node集群现状（机器均为24核），拆分为两个独立服务：</p>\n<ul>\n<li><code>nuomi</code>: 承载糯米组件流量，端口为<code>8197</code>，实例数为14</li>\n<li><code>h5</code>: 承载所有h5模块渲染流量，端口为<code>8198</code>,实例数为10</li>\n</ul>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;apps&quot;: [&#123;</span><br><span class=\"line\">        &quot;exec_interpreter&quot;: &quot;node&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;nuomi&quot;,</span><br><span class=\"line\">        &quot;exec_mode&quot;: &quot;cluster_mode&quot;,</span><br><span class=\"line\">        &quot;instances&quot;: &quot;14&quot;,</span><br><span class=\"line\">        &quot;max_memory_restart&quot;: &quot;500M&quot;,</span><br><span class=\"line\">        &quot;merge_logs&quot;: false,</span><br><span class=\"line\">        &quot;script&quot;: &quot;app.js&quot;,</span><br><span class=\"line\">        &quot;ignoreWatch&quot;: [&quot;pm2&quot;, &quot;log&quot;, &quot;node_modules&quot;],</span><br><span class=\"line\">        &quot;env&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class=\"line\">            &quot;PM2_GRACEFUL_TIMEOUT&quot;: 1000,</span><br><span class=\"line\">            &quot;PORT&quot;: 8197,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_dev&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_test&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;qa&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        &quot;exec_interpreter&quot;: &quot;node&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;h5&quot;,</span><br><span class=\"line\">        &quot;exec_mode&quot;: &quot;cluster_mode&quot;,</span><br><span class=\"line\">        &quot;instances&quot;: &quot;10&quot;,</span><br><span class=\"line\">        &quot;max_memory_restart&quot;: &quot;500M&quot;,</span><br><span class=\"line\">        &quot;merge_logs&quot;: false,</span><br><span class=\"line\">        &quot;script&quot;: &quot;app.js&quot;,</span><br><span class=\"line\">        &quot;ignoreWatch&quot;: [&quot;pm2&quot;, &quot;log&quot;, &quot;node_modules&quot;],</span><br><span class=\"line\">        &quot;env&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class=\"line\">            &quot;PM2_GRACEFUL_TIMEOUT&quot;: 1000,</span><br><span class=\"line\">            &quot;PORT&quot;: 8198,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_dev&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_test&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;qa&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-改造启动脚本支持业务app独立重启\"><a class=\"markdown-anchor\" href=\"#2-改造启动脚本支持业务app独立重启\">#</a> 2. 改造启动脚本，支持业务APP独立重启</h3>\n<pre><code>nuomi_restart.sh\nh5_restart.sh\n</code></pre>\n<p>命令改造：</p>\n<pre><code>bin/control start  // 开启所有服务\nbin/control stop appname // 关闭某个服务（h5、nuomi）\nbin/control delete appname // 删除某个服务（h5、nuomi）\nbin/control restart appname // 重启某个服务\nbin/control reload appname // 0宕机重启，后续上线重启采用reload方案\n</code></pre>\n<p><img src=\"http://younth.coding.me/static/nodeui/reload.jpeg\" alt=\"reload\"></p>\n<h2 id=\"上线步骤\"><a class=\"markdown-anchor\" href=\"#上线步骤\">#</a> 上线步骤</h2>\n<h3 id=\"1-上线nodeui服务\"><a class=\"markdown-anchor\" href=\"#1-上线nodeui服务\">#</a> 1. 上线NodeUI服务</h3>\n<ul>\n<li>\n<p>上线前先确定线上的服务进程名称</p>\n</li>\n<li>\n<p>涉及底层上线，上线前需要先stop/delete掉老的进程，为确保服务稳定，采用先stop，然后上线新的隔离方案，回归正常后，delete老的服务进程。</p>\n</li>\n<li>\n<p>需要review方案，或者直接OP操作删除老的进程。</p>\n</li>\n<li>\n<p>增加上线模块</p>\n</li>\n<li>\n<p>绑定上线重启脚本</p>\n</li>\n</ul>\n<h3 id=\"2-上线ng-rewrite-端口\"><a class=\"markdown-anchor\" href=\"#2-上线ng-rewrite-端口\">#</a> 2. 上线ng rewrite 端口</h3>\n<ul>\n<li>配置新的vip服务</li>\n<li>修改rewrite</li>\n</ul>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home/work/odp_cater/webserver/conf/vhost/</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"重点关注\"><a class=\"markdown-anchor\" href=\"#重点关注\">#</a> 重点关注</h2>\n<ul>\n<li>组件业务</li>\n<li>h5业务</li>\n<li>日志（pm2+业务，关注日志是否会错乱）</li>\n<li>服务稳定（Node进程状态）</li>\n</ul>\n<h2 id=\"回滚方案\"><a class=\"markdown-anchor\" href=\"#回滚方案\">#</a> 回滚方案</h2>\n<p>由于目前公有云回滚可能有坑，回滚过程进程应该不会被杀掉，可能有残留进程，需要杀掉。所以最佳回归方式是<strong>覆盖上线</strong>。涉及的模块：</p>\n<ul>\n<li>fly</li>\n<li>runtime</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>通过PM2拆分服务，确保不同服务相互不受影响。</p>\n<h3 id=\"1-改造现有pm2json支持多app启动\"><a class=\"markdown-anchor\" href=\"#1-改造现有pm2json支持多app启动\">#</a> 1. 改造现有<code>pm2.json</code>，支持多app启动</h3>\n<p>根据当前公有云Node集群现状（机器均为24核），拆分为两个独立服务：</p>\n<ul>\n<li><code>nuomi</code>: 承载糯米组件流量，端口为<code>8197</code>，实例数为14</li>\n<li><code>h5</code>: 承载所有h5模块渲染流量，端口为<code>8198</code>,实例数为10</li>\n</ul>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;apps&quot;: [&#123;</span><br><span class=\"line\">        &quot;exec_interpreter&quot;: &quot;node&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;nuomi&quot;,</span><br><span class=\"line\">        &quot;exec_mode&quot;: &quot;cluster_mode&quot;,</span><br><span class=\"line\">        &quot;instances&quot;: &quot;14&quot;,</span><br><span class=\"line\">        &quot;max_memory_restart&quot;: &quot;500M&quot;,</span><br><span class=\"line\">        &quot;merge_logs&quot;: false,</span><br><span class=\"line\">        &quot;script&quot;: &quot;app.js&quot;,</span><br><span class=\"line\">        &quot;ignoreWatch&quot;: [&quot;pm2&quot;, &quot;log&quot;, &quot;node_modules&quot;],</span><br><span class=\"line\">        &quot;env&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class=\"line\">            &quot;PM2_GRACEFUL_TIMEOUT&quot;: 1000,</span><br><span class=\"line\">            &quot;PORT&quot;: 8197,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_dev&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_test&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;qa&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        &quot;exec_interpreter&quot;: &quot;node&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;h5&quot;,</span><br><span class=\"line\">        &quot;exec_mode&quot;: &quot;cluster_mode&quot;,</span><br><span class=\"line\">        &quot;instances&quot;: &quot;10&quot;,</span><br><span class=\"line\">        &quot;max_memory_restart&quot;: &quot;500M&quot;,</span><br><span class=\"line\">        &quot;merge_logs&quot;: false,</span><br><span class=\"line\">        &quot;script&quot;: &quot;app.js&quot;,</span><br><span class=\"line\">        &quot;ignoreWatch&quot;: [&quot;pm2&quot;, &quot;log&quot;, &quot;node_modules&quot;],</span><br><span class=\"line\">        &quot;env&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class=\"line\">            &quot;PM2_GRACEFUL_TIMEOUT&quot;: 1000,</span><br><span class=\"line\">            &quot;PORT&quot;: 8198,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_dev&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class=\"line\">            &quot;DEBUG&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;env_test&quot;: &#123;</span><br><span class=\"line\">            &quot;NODE_ENV&quot;: &quot;qa&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-改造启动脚本支持业务app独立重启\"><a class=\"markdown-anchor\" href=\"#2-改造启动脚本支持业务app独立重启\">#</a> 2. 改造启动脚本，支持业务APP独立重启</h3>\n<pre><code>nuomi_restart.sh\nh5_restart.sh\n</code></pre>\n<p>命令改造：</p>\n<pre><code>bin/control start  // 开启所有服务\nbin/control stop appname // 关闭某个服务（h5、nuomi）\nbin/control delete appname // 删除某个服务（h5、nuomi）\nbin/control restart appname // 重启某个服务\nbin/control reload appname // 0宕机重启，后续上线重启采用reload方案\n</code></pre>\n<p><img src=\"http://younth.coding.me/static/nodeui/reload.jpeg\" alt=\"reload\"></p>\n<h2 id=\"上线步骤\"><a class=\"markdown-anchor\" href=\"#上线步骤\">#</a> 上线步骤</h2>\n<h3 id=\"1-上线nodeui服务\"><a class=\"markdown-anchor\" href=\"#1-上线nodeui服务\">#</a> 1. 上线NodeUI服务</h3>\n<ul>\n<li>\n<p>上线前先确定线上的服务进程名称</p>\n</li>\n<li>\n<p>涉及底层上线，上线前需要先stop/delete掉老的进程，为确保服务稳定，采用先stop，然后上线新的隔离方案，回归正常后，delete老的服务进程。</p>\n</li>\n<li>\n<p>需要review方案，或者直接OP操作删除老的进程。</p>\n</li>\n<li>\n<p>增加上线模块</p>\n</li>\n<li>\n<p>绑定上线重启脚本</p>\n</li>\n</ul>\n<h3 id=\"2-上线ng-rewrite-端口\"><a class=\"markdown-anchor\" href=\"#2-上线ng-rewrite-端口\">#</a> 2. 上线ng rewrite 端口</h3>\n<ul>\n<li>配置新的vip服务</li>\n<li>修改rewrite</li>\n</ul>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home/work/odp_cater/webserver/conf/vhost/</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"重点关注\"><a class=\"markdown-anchor\" href=\"#重点关注\">#</a> 重点关注</h2>\n<ul>\n<li>组件业务</li>\n<li>h5业务</li>\n<li>日志（pm2+业务，关注日志是否会错乱）</li>\n<li>服务稳定（Node进程状态）</li>\n</ul>\n<h2 id=\"回滚方案\"><a class=\"markdown-anchor\" href=\"#回滚方案\">#</a> 回滚方案</h2>\n<p>由于目前公有云回滚可能有坑，回滚过程进程应该不会被杀掉，可能有残留进程，需要杀掉。所以最佳回归方式是<strong>覆盖上线</strong>。涉及的模块：</p>\n<ul>\n<li>fly</li>\n<li>runtime</li>\n</ul>\n"},{"title":"NodeUI文档平台正式启动","_content":"\n各位同学，**NodeUI本季度将对外承接服务**，为保证其他业务部门同学顺利接入，同时也为其他对NodeUI感兴趣的同学提供学习平台，文档建设亟待完善。\n\n无论你是刚接触 Node 还是 Node 的老司机，都可以贡献出自己的文章（`仅限markdown文档格式`）。包括不局限：\n\n- NodeUI如何在业务中使用\n- NodeUI 服务通信原理\n- NodeUI 运维\n- fekey 开发工具在 NodeUI 中的使用\n- 微信授权的那些坑\n- Universal Link 流程\n- NodeUI 服务运行原理\n- 线上部署\n- 监控报警\n- 守护进程原理\n- ......\n\n大家平时使用过程中有任何建议也欢迎提出来，共同改进，建设 NodeUI 生态 ~~\n\n","source":"zh-cn/docs/faq/contributing.md","raw":"title: NodeUI文档平台正式启动\n---\n\n各位同学，**NodeUI本季度将对外承接服务**，为保证其他业务部门同学顺利接入，同时也为其他对NodeUI感兴趣的同学提供学习平台，文档建设亟待完善。\n\n无论你是刚接触 Node 还是 Node 的老司机，都可以贡献出自己的文章（`仅限markdown文档格式`）。包括不局限：\n\n- NodeUI如何在业务中使用\n- NodeUI 服务通信原理\n- NodeUI 运维\n- fekey 开发工具在 NodeUI 中的使用\n- 微信授权的那些坑\n- Universal Link 流程\n- NodeUI 服务运行原理\n- 线上部署\n- 监控报警\n- 守护进程原理\n- ......\n\n大家平时使用过程中有任何建议也欢迎提出来，共同改进，建设 NodeUI 生态 ~~\n\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/faq/contributing.html","comments":1,"layout":"page","_id":"cjyd4skjl001a6lq1iki68t2j","content":"<p>各位同学，<strong>NodeUI本季度将对外承接服务</strong>，为保证其他业务部门同学顺利接入，同时也为其他对NodeUI感兴趣的同学提供学习平台，文档建设亟待完善。</p>\n<p>无论你是刚接触 Node 还是 Node 的老司机，都可以贡献出自己的文章（<code>仅限markdown文档格式</code>）。包括不局限：</p>\n<ul>\n<li>NodeUI如何在业务中使用</li>\n<li>NodeUI 服务通信原理</li>\n<li>NodeUI 运维</li>\n<li>fekey 开发工具在 NodeUI 中的使用</li>\n<li>微信授权的那些坑</li>\n<li>Universal Link 流程</li>\n<li>NodeUI 服务运行原理</li>\n<li>线上部署</li>\n<li>监控报警</li>\n<li>守护进程原理</li>\n<li>......</li>\n</ul>\n<p>大家平时使用过程中有任何建议也欢迎提出来，共同改进，建设 NodeUI 生态 ~~</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>各位同学，<strong>NodeUI本季度将对外承接服务</strong>，为保证其他业务部门同学顺利接入，同时也为其他对NodeUI感兴趣的同学提供学习平台，文档建设亟待完善。</p>\n<p>无论你是刚接触 Node 还是 Node 的老司机，都可以贡献出自己的文章（<code>仅限markdown文档格式</code>）。包括不局限：</p>\n<ul>\n<li>NodeUI如何在业务中使用</li>\n<li>NodeUI 服务通信原理</li>\n<li>NodeUI 运维</li>\n<li>fekey 开发工具在 NodeUI 中的使用</li>\n<li>微信授权的那些坑</li>\n<li>Universal Link 流程</li>\n<li>NodeUI 服务运行原理</li>\n<li>线上部署</li>\n<li>监控报警</li>\n<li>守护进程原理</li>\n<li>......</li>\n</ul>\n<p>大家平时使用过程中有任何建议也欢迎提出来，共同改进，建设 NodeUI 生态 ~~</p>\n"},{"title":"Node.js调试","_content":"\n## 线下调试\n    \n### 需求\n\n- http请求断点调试\n- node-ral 向后请求查看\n- 启动调试\n\n\n## 版本\n\n    node v4.2.4\n    Node Inspector v0.12.5\n\n## node-inspector\n\n```\nnpm i -g node-inspector\n\nnpm run debug(node --debug app.js)\n\nnode-inspector --web-port=5006\n\n```\n\n> 建议配合 `supervisor` 使用,支持node 自动重启。\n    \n## devtool\n\n> 建议大家尝试，取代node-inspector\n\n    https://github.com/Jam3/devtool\n\n## 线上—日志\n\n    线上通过日志排查 access nodeui等\n    \n## 远程调试\n\n\n## 错误捕获\n\n```js\n'use strict';\n\nconst Http = require('http');\n\nconst server = Http.createServer((req, res) => {\n  const promise = new Promise((resolve, reject) => {\n    let result = '';\n    req.on('data', (data) => {\n      result += data;\n    });\n\n    req.once('end', () => {\n      const obj = JSON.parse(result);\n      resolve(obj);\n    });\n  });\n\n  promise.then((obj) => {\n    res.writeHead(200);\n    // 这里会报错\n    res.end(obj.foo.bar);\n  }).catch((reason) => {\n    res.writeHead(500);\n    res.end();\n    console.error(reason);\n    // 抛错后退出程序\n    process.abort()\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('listening at http://localhost:8080');\n});\n\n```\n    // post请求\n    curl -X POST http://localhost:8080 -d '{\"Hi\": \"world\"}'","source":"zh-cn/docs/faq/debug.md","raw":"title: Node.js调试\n---\n\n## 线下调试\n    \n### 需求\n\n- http请求断点调试\n- node-ral 向后请求查看\n- 启动调试\n\n\n## 版本\n\n    node v4.2.4\n    Node Inspector v0.12.5\n\n## node-inspector\n\n```\nnpm i -g node-inspector\n\nnpm run debug(node --debug app.js)\n\nnode-inspector --web-port=5006\n\n```\n\n> 建议配合 `supervisor` 使用,支持node 自动重启。\n    \n## devtool\n\n> 建议大家尝试，取代node-inspector\n\n    https://github.com/Jam3/devtool\n\n## 线上—日志\n\n    线上通过日志排查 access nodeui等\n    \n## 远程调试\n\n\n## 错误捕获\n\n```js\n'use strict';\n\nconst Http = require('http');\n\nconst server = Http.createServer((req, res) => {\n  const promise = new Promise((resolve, reject) => {\n    let result = '';\n    req.on('data', (data) => {\n      result += data;\n    });\n\n    req.once('end', () => {\n      const obj = JSON.parse(result);\n      resolve(obj);\n    });\n  });\n\n  promise.then((obj) => {\n    res.writeHead(200);\n    // 这里会报错\n    res.end(obj.foo.bar);\n  }).catch((reason) => {\n    res.writeHead(500);\n    res.end();\n    console.error(reason);\n    // 抛错后退出程序\n    process.abort()\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('listening at http://localhost:8080');\n});\n\n```\n    // post请求\n    curl -X POST http://localhost:8080 -d '{\"Hi\": \"world\"}'","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/faq/debug.html","comments":1,"layout":"page","_id":"cjyd4skjm001b6lq1xerdf5qp","content":"<h2 id=\"线下调试\"><a class=\"markdown-anchor\" href=\"#线下调试\">#</a> 线下调试</h2>\n<h3 id=\"需求\"><a class=\"markdown-anchor\" href=\"#需求\">#</a> 需求</h3>\n<ul>\n<li>http请求断点调试</li>\n<li>node-ral 向后请求查看</li>\n<li>启动调试</li>\n</ul>\n<h2 id=\"版本\"><a class=\"markdown-anchor\" href=\"#版本\">#</a> 版本</h2>\n<pre><code>node v4.2.4\nNode Inspector v0.12.5\n</code></pre>\n<h2 id=\"node-inspector\"><a class=\"markdown-anchor\" href=\"#node-inspector\">#</a> node-inspector</h2>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i -g node-inspector</span><br><span class=\"line\"></span><br><span class=\"line\">npm run debug(node --debug app.js)</span><br><span class=\"line\"></span><br><span class=\"line\">node-inspector --web-port=5006</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>建议配合 <code>supervisor</code> 使用,支持node 自动重启。</p>\n</blockquote>\n<h2 id=\"devtool\"><a class=\"markdown-anchor\" href=\"#devtool\">#</a> devtool</h2>\n<blockquote>\n<p>建议大家尝试，取代node-inspector</p>\n</blockquote>\n<pre><code>https://github.com/Jam3/devtool\n</code></pre>\n<h2 id=\"线上日志\"><a class=\"markdown-anchor\" href=\"#线上日志\">#</a> 线上—日志</h2>\n<pre><code>线上通过日志排查 access nodeui等\n</code></pre>\n<h2 id=\"远程调试\"><a class=\"markdown-anchor\" href=\"#远程调试\">#</a> 远程调试</h2>\n<h2 id=\"错误捕获\"><a class=\"markdown-anchor\" href=\"#错误捕获\">#</a> 错误捕获</h2>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = Http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</span><br><span class=\"line\">    req.on(<span class=\"string\">'data'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">      result += data;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    req.once(<span class=\"string\">'end'</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> obj = <span class=\"built_in\">JSON</span>.parse(result);</span><br><span class=\"line\">      resolve(obj);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  promise.then(<span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">200</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 这里会报错</span></span><br><span class=\"line\">    res.end(obj.foo.bar);</span><br><span class=\"line\">  &#125;).catch(<span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">500</span>);</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(reason);</span><br><span class=\"line\">    <span class=\"comment\">// 抛错后退出程序</span></span><br><span class=\"line\">    process.abort()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening at http://localhost:8080'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<pre><code>// post请求\ncurl -X POST http://localhost:8080 -d '{&quot;Hi&quot;: &quot;world&quot;}'</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<h2 id=\"线下调试\"><a class=\"markdown-anchor\" href=\"#线下调试\">#</a> 线下调试</h2>\n<h3 id=\"需求\"><a class=\"markdown-anchor\" href=\"#需求\">#</a> 需求</h3>\n<ul>\n<li>http请求断点调试</li>\n<li>node-ral 向后请求查看</li>\n<li>启动调试</li>\n</ul>\n<h2 id=\"版本\"><a class=\"markdown-anchor\" href=\"#版本\">#</a> 版本</h2>\n<pre><code>node v4.2.4\nNode Inspector v0.12.5\n</code></pre>\n<h2 id=\"node-inspector\"><a class=\"markdown-anchor\" href=\"#node-inspector\">#</a> node-inspector</h2>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i -g node-inspector</span><br><span class=\"line\"></span><br><span class=\"line\">npm run debug(node --debug app.js)</span><br><span class=\"line\"></span><br><span class=\"line\">node-inspector --web-port=5006</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>建议配合 <code>supervisor</code> 使用,支持node 自动重启。</p>\n</blockquote>\n<h2 id=\"devtool\"><a class=\"markdown-anchor\" href=\"#devtool\">#</a> devtool</h2>\n<blockquote>\n<p>建议大家尝试，取代node-inspector</p>\n</blockquote>\n<pre><code>https://github.com/Jam3/devtool\n</code></pre>\n<h2 id=\"线上日志\"><a class=\"markdown-anchor\" href=\"#线上日志\">#</a> 线上—日志</h2>\n<pre><code>线上通过日志排查 access nodeui等\n</code></pre>\n<h2 id=\"远程调试\"><a class=\"markdown-anchor\" href=\"#远程调试\">#</a> 远程调试</h2>\n<h2 id=\"错误捕获\"><a class=\"markdown-anchor\" href=\"#错误捕获\">#</a> 错误捕获</h2>\n<p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = Http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"string\">''</span>;</span><br><span class=\"line\">    req.on(<span class=\"string\">'data'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">      result += data;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    req.once(<span class=\"string\">'end'</span>, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> obj = <span class=\"built_in\">JSON</span>.parse(result);</span><br><span class=\"line\">      resolve(obj);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  promise.then(<span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">200</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 这里会报错</span></span><br><span class=\"line\">    res.end(obj.foo.bar);</span><br><span class=\"line\">  &#125;).catch(<span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">500</span>);</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(reason);</span><br><span class=\"line\">    <span class=\"comment\">// 抛错后退出程序</span></span><br><span class=\"line\">    process.abort()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening at http://localhost:8080'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<pre><code>// post请求\ncurl -X POST http://localhost:8080 -d '{&quot;Hi&quot;: &quot;world&quot;}'</code></pre>\n"},{"title":"环境及部署问题汇总","_content":"\n","source":"zh-cn/docs/faq/deploy.md","raw":"title: 环境及部署问题汇总\n---\n\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/faq/deploy.html","comments":1,"layout":"page","_id":"cjyd4skjo001c6lq1tl0ikuoa","content":"","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":""},{"title":"启动失败","_content":"\n```\nFATAL: 17-03-27 15:45:52 [-:-] errno[0] logId[-] uri[-] user[-] refer[-] cookie[-]  [yog-ral] [cluster main][Config] config [/home/map/nodeui/conf/ral] load failed\n\nAssertionError: [online] config error => [server]: expected undefined to be an array\n    at validate (/home/map/nodeui/node_modules/node-ral/lib/config.js:122:45)\n    at /home/map/nodeui/node_modules/node-ral/lib/config.js:141:9\n    at Function._.map._.collect (/home/map/nodeui/node_modules/node-ral/node_modules/underscore/underscore.js:172:24)\n    at loadRawConf (/home/map/nodeui/node_modules/node-ral/lib/config.js:134:7)\n    at Object.load (/home/map/nodeui/node_modules/node-ral/lib/config.js:210:9)\n    at Function.RAL.init (/home/map/nodeui/node_modules/node-ral/lib/ral.js:477:16)\n    at module.exports (/home/map/nodeui/extension/tools/RAL.js:17:9)\n    at /home/map/nodeui/kernel/middlewares/dispatcher/index.js:40:23\n    at Array.forEach (native)\n    at initCommonTools (/home/map/nodeui/kernel/middlewares/dispatcher/index.js:35:15)\n```\n\n这种 `ral` 配置问题通常是因为向后请求模块引用错误。本地开发环境引用 `node-ral` ，生产环境必须用 `yog-ral`。\n\n### node-ral 与 yog-ral 的区别\n\n","source":"zh-cn/docs/faq/start.md","raw":"title: 启动失败\n---\n\n```\nFATAL: 17-03-27 15:45:52 [-:-] errno[0] logId[-] uri[-] user[-] refer[-] cookie[-]  [yog-ral] [cluster main][Config] config [/home/map/nodeui/conf/ral] load failed\n\nAssertionError: [online] config error => [server]: expected undefined to be an array\n    at validate (/home/map/nodeui/node_modules/node-ral/lib/config.js:122:45)\n    at /home/map/nodeui/node_modules/node-ral/lib/config.js:141:9\n    at Function._.map._.collect (/home/map/nodeui/node_modules/node-ral/node_modules/underscore/underscore.js:172:24)\n    at loadRawConf (/home/map/nodeui/node_modules/node-ral/lib/config.js:134:7)\n    at Object.load (/home/map/nodeui/node_modules/node-ral/lib/config.js:210:9)\n    at Function.RAL.init (/home/map/nodeui/node_modules/node-ral/lib/ral.js:477:16)\n    at module.exports (/home/map/nodeui/extension/tools/RAL.js:17:9)\n    at /home/map/nodeui/kernel/middlewares/dispatcher/index.js:40:23\n    at Array.forEach (native)\n    at initCommonTools (/home/map/nodeui/kernel/middlewares/dispatcher/index.js:35:15)\n```\n\n这种 `ral` 配置问题通常是因为向后请求模块引用错误。本地开发环境引用 `node-ral` ，生产环境必须用 `yog-ral`。\n\n### node-ral 与 yog-ral 的区别\n\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/faq/start.html","comments":1,"layout":"page","_id":"cjyd4skjp001d6lq1lfu9abhl","content":"<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">FATAL: 17-03-27 15:45:52 [-:-] errno[0] logId[-] uri[-] user[-] refer[-] cookie[-]  [yog-ral] [cluster main][Config] config [/home/map/nodeui/conf/ral] load failed</span><br><span class=\"line\"></span><br><span class=\"line\">AssertionError: [online] config error =&gt; [server]: expected undefined to be an array</span><br><span class=\"line\">    at validate (/home/map/nodeui/node_modules/node-ral/lib/config.js:122:45)</span><br><span class=\"line\">    at /home/map/nodeui/node_modules/node-ral/lib/config.js:141:9</span><br><span class=\"line\">    at Function._.map._.collect (/home/map/nodeui/node_modules/node-ral/node_modules/underscore/underscore.js:172:24)</span><br><span class=\"line\">    at loadRawConf (/home/map/nodeui/node_modules/node-ral/lib/config.js:134:7)</span><br><span class=\"line\">    at Object.load (/home/map/nodeui/node_modules/node-ral/lib/config.js:210:9)</span><br><span class=\"line\">    at Function.RAL.init (/home/map/nodeui/node_modules/node-ral/lib/ral.js:477:16)</span><br><span class=\"line\">    at module.exports (/home/map/nodeui/extension/tools/RAL.js:17:9)</span><br><span class=\"line\">    at /home/map/nodeui/kernel/middlewares/dispatcher/index.js:40:23</span><br><span class=\"line\">    at Array.forEach (native)</span><br><span class=\"line\">    at initCommonTools (/home/map/nodeui/kernel/middlewares/dispatcher/index.js:35:15)</span><br></pre></td></tr></table></figure></p>\n<p>这种 <code>ral</code> 配置问题通常是因为向后请求模块引用错误。本地开发环境引用 <code>node-ral</code> ，生产环境必须用 <code>yog-ral</code>。</p>\n<h3 id=\"node-ral-与-yog-ral-的区别\"><a class=\"markdown-anchor\" href=\"#node-ral-与-yog-ral-的区别\">#</a> node-ral 与 yog-ral 的区别</h3>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">FATAL: 17-03-27 15:45:52 [-:-] errno[0] logId[-] uri[-] user[-] refer[-] cookie[-]  [yog-ral] [cluster main][Config] config [/home/map/nodeui/conf/ral] load failed</span><br><span class=\"line\"></span><br><span class=\"line\">AssertionError: [online] config error =&gt; [server]: expected undefined to be an array</span><br><span class=\"line\">    at validate (/home/map/nodeui/node_modules/node-ral/lib/config.js:122:45)</span><br><span class=\"line\">    at /home/map/nodeui/node_modules/node-ral/lib/config.js:141:9</span><br><span class=\"line\">    at Function._.map._.collect (/home/map/nodeui/node_modules/node-ral/node_modules/underscore/underscore.js:172:24)</span><br><span class=\"line\">    at loadRawConf (/home/map/nodeui/node_modules/node-ral/lib/config.js:134:7)</span><br><span class=\"line\">    at Object.load (/home/map/nodeui/node_modules/node-ral/lib/config.js:210:9)</span><br><span class=\"line\">    at Function.RAL.init (/home/map/nodeui/node_modules/node-ral/lib/ral.js:477:16)</span><br><span class=\"line\">    at module.exports (/home/map/nodeui/extension/tools/RAL.js:17:9)</span><br><span class=\"line\">    at /home/map/nodeui/kernel/middlewares/dispatcher/index.js:40:23</span><br><span class=\"line\">    at Array.forEach (native)</span><br><span class=\"line\">    at initCommonTools (/home/map/nodeui/kernel/middlewares/dispatcher/index.js:35:15)</span><br></pre></td></tr></table></figure></p>\n<p>这种 <code>ral</code> 配置问题通常是因为向后请求模块引用错误。本地开发环境引用 <code>node-ral</code> ，生产环境必须用 <code>yog-ral</code>。</p>\n<h3 id=\"node-ral-与-yog-ral-的区别\"><a class=\"markdown-anchor\" href=\"#node-ral-与-yog-ral-的区别\">#</a> node-ral 与 yog-ral 的区别</h3>\n"},{"title":"维表join","_content":"维表join在大数据中非常常见,通常我们需要在入库时对数据进行过滤和join打宽.\nsylph sql现在已经支持简单的维表join,\n\n### demo\n下面将通过一个demo来演示sylph 的join功能.\n该例子模拟读取实时json数据进行解析取出user_id和ip字段,\n然后计算每个用户每5秒的`count(distinct key)`数,\n接下来和mysql中的users表 进行join取出 name和city。\n最后 Insert into 存储数据到外部\n```sql\ncreate function json_parser as 'ideal.sylph.runner.flink.udf.JsonParser';\ncreate function row_get as 'ideal.sylph.runner.flink.udf.RowGet';\n\ncreate source table topic1(\n    key varchar,\n    value varchar,     -- json\n    event_time bigint\n) with (\n    type = 'ideal.sylph.plugins.flink.source.TestSource'\n);\n\n-- 定义数据流输出位置\ncreate sink table print_table_sink(\n    uid varchar,\n    name varchar,\n    city varchar,\n    cnt long,\n    window_time varchar\n) with (\n    type = 'console',   -- print console\n    other = 'demo001'\n);\n\n-- 定义维表\ncreate batch table users(\n    id varchar,\n    name varchar,\n    city varchar\n) with (\n    type = 'mysql',   -- print console\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false'\n    -- query = 'select * from users where ...'  --可以下推谓词\n);\n\n-- 描述数据流计算过程\ninsert into print_table_sink\nwith tb1 as (\n    select key, row_get(rowline,0) as uid , row_get(rowline,1) as ip, event_time, proctime\n    from topic1 , LATERAL TABLE(json_parser(`value`,'user_id,ip')) as T(rowline) \n),tb2 as (\n    select uid,\n    count(distinct key) as cnt,\n    cast(TUMBLE_START(proctime,INTERVAL '5' SECOND) as varchar)|| '-->' \n    || cast(TUMBLE_END(proctime,INTERVAL '5' SECOND) as varchar) AS start_time\n    from tb1 where uid is not null\n    group by uid,TUMBLE(proctime,INTERVAL '5' SECOND)\n) \nselect tb2.uid, users.name ,users.city, tb2.cnt, tb2.start_time \nfrom tb2 left join users on tb2.uid = users.id\nhaving 1=1\n```\n    \n### 注意事项\n- 1, 维表join时 为了解析方便,请尽量将维表放到右边\n- 2, 只支持left join 和 Inner join(维表在右边时), 详细原因可以参考: [http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#support-matrix-for-joins-in-streaming-queries](join)\n- 3  `on` 只支持and(equals) 例如: `条件1 and 条件2 and 条件3`\n- 4  对于条件只支持equals(`=`) 例如: `on tb1.a1=tb2.id and ...`\n- 5  对于equals条件暂时不支持常量, 例如: `on tb1.a1 = 'sylph'` 目前是不支持的, 原因是涉及到谓词下推问题\n- 6  不支持join where 原因如上 因为涉及到谓词下推问题\n- 7  完整支持 having语句\n\n### 关于维表插件 目前只实现了mysql\n实现非常简单,请参考 sylph-mysql/ideal.sylph.plugins.mysql.MysqlAsyncFunction.java\n如果有用到redis或者别的 可参考这个进行简单实现,或参考`进阶`中开发指南\n\n### 关于缓存问题\nMysqlAsyncFunction 采用LRU缓存策略, 使用的本地缓存. 如果想使用分布式缓存,可以自行修改非常简单.\n\n\n### other\n- 关于json 解析采用的udtf来实现的,总体上因为calcite语法原因 对比hive显得不够优雅\n但在这种方案不影响性能 切非常灵活\n- 上面示例mysql 建表语句如下:\n```mysql\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` varchar(10) NOT NULL,\n  `name` varchar(20) NOT NULL,\n  `city` char(20) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'h123', '123');\nINSERT INTO `users` VALUES ('2', 'p123', '123');\nINSERT INTO `users` VALUES ('4', '小王', 'dikd3939');\nINSERT INTO `users` VALUES ('uid_1', 'test', 'test');\nINSERT INTO `users` VALUES ('uid_5', 'sylph', 'demo');\n``` ","source":"zh-cn/docs/intro/batch-join.md","raw":"title: 维表join\n---\n维表join在大数据中非常常见,通常我们需要在入库时对数据进行过滤和join打宽.\nsylph sql现在已经支持简单的维表join,\n\n### demo\n下面将通过一个demo来演示sylph 的join功能.\n该例子模拟读取实时json数据进行解析取出user_id和ip字段,\n然后计算每个用户每5秒的`count(distinct key)`数,\n接下来和mysql中的users表 进行join取出 name和city。\n最后 Insert into 存储数据到外部\n```sql\ncreate function json_parser as 'ideal.sylph.runner.flink.udf.JsonParser';\ncreate function row_get as 'ideal.sylph.runner.flink.udf.RowGet';\n\ncreate source table topic1(\n    key varchar,\n    value varchar,     -- json\n    event_time bigint\n) with (\n    type = 'ideal.sylph.plugins.flink.source.TestSource'\n);\n\n-- 定义数据流输出位置\ncreate sink table print_table_sink(\n    uid varchar,\n    name varchar,\n    city varchar,\n    cnt long,\n    window_time varchar\n) with (\n    type = 'console',   -- print console\n    other = 'demo001'\n);\n\n-- 定义维表\ncreate batch table users(\n    id varchar,\n    name varchar,\n    city varchar\n) with (\n    type = 'mysql',   -- print console\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false'\n    -- query = 'select * from users where ...'  --可以下推谓词\n);\n\n-- 描述数据流计算过程\ninsert into print_table_sink\nwith tb1 as (\n    select key, row_get(rowline,0) as uid , row_get(rowline,1) as ip, event_time, proctime\n    from topic1 , LATERAL TABLE(json_parser(`value`,'user_id,ip')) as T(rowline) \n),tb2 as (\n    select uid,\n    count(distinct key) as cnt,\n    cast(TUMBLE_START(proctime,INTERVAL '5' SECOND) as varchar)|| '-->' \n    || cast(TUMBLE_END(proctime,INTERVAL '5' SECOND) as varchar) AS start_time\n    from tb1 where uid is not null\n    group by uid,TUMBLE(proctime,INTERVAL '5' SECOND)\n) \nselect tb2.uid, users.name ,users.city, tb2.cnt, tb2.start_time \nfrom tb2 left join users on tb2.uid = users.id\nhaving 1=1\n```\n    \n### 注意事项\n- 1, 维表join时 为了解析方便,请尽量将维表放到右边\n- 2, 只支持left join 和 Inner join(维表在右边时), 详细原因可以参考: [http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#support-matrix-for-joins-in-streaming-queries](join)\n- 3  `on` 只支持and(equals) 例如: `条件1 and 条件2 and 条件3`\n- 4  对于条件只支持equals(`=`) 例如: `on tb1.a1=tb2.id and ...`\n- 5  对于equals条件暂时不支持常量, 例如: `on tb1.a1 = 'sylph'` 目前是不支持的, 原因是涉及到谓词下推问题\n- 6  不支持join where 原因如上 因为涉及到谓词下推问题\n- 7  完整支持 having语句\n\n### 关于维表插件 目前只实现了mysql\n实现非常简单,请参考 sylph-mysql/ideal.sylph.plugins.mysql.MysqlAsyncFunction.java\n如果有用到redis或者别的 可参考这个进行简单实现,或参考`进阶`中开发指南\n\n### 关于缓存问题\nMysqlAsyncFunction 采用LRU缓存策略, 使用的本地缓存. 如果想使用分布式缓存,可以自行修改非常简单.\n\n\n### other\n- 关于json 解析采用的udtf来实现的,总体上因为calcite语法原因 对比hive显得不够优雅\n但在这种方案不影响性能 切非常灵活\n- 上面示例mysql 建表语句如下:\n```mysql\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` varchar(10) NOT NULL,\n  `name` varchar(20) NOT NULL,\n  `city` char(20) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'h123', '123');\nINSERT INTO `users` VALUES ('2', 'p123', '123');\nINSERT INTO `users` VALUES ('4', '小王', 'dikd3939');\nINSERT INTO `users` VALUES ('uid_1', 'test', 'test');\nINSERT INTO `users` VALUES ('uid_5', 'sylph', 'demo');\n``` ","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/intro/batch-join.html","comments":1,"layout":"page","_id":"cjyd4skjq001e6lq1fxzwiw8j","content":"<p>维表join在大数据中非常常见,通常我们需要在入库时对数据进行过滤和join打宽.\nsylph sql现在已经支持简单的维表join,</p>\n<h3 id=\"demo\"><a class=\"markdown-anchor\" href=\"#demo\">#</a> demo</h3>\n<p>下面将通过一个demo来演示sylph 的join功能.\n该例子模拟读取实时json数据进行解析取出user_id和ip字段,\n然后计算每个用户每5秒的<code>count(distinct key)</code>数,\n接下来和mysql中的users表 进行join取出 name和city。\n最后 Insert into 存储数据到外部\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> json_parser <span class=\"keyword\">as</span> <span class=\"string\">'ideal.sylph.runner.flink.udf.JsonParser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> row_get <span class=\"keyword\">as</span> <span class=\"string\">'ideal.sylph.runner.flink.udf.RowGet'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    <span class=\"keyword\">key</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">value</span> <span class=\"built_in\">varchar</span>,     <span class=\"comment\">-- json</span></span><br><span class=\"line\">    event_time <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'ideal.sylph.plugins.flink.source.TestSource'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 定义数据流输出位置</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> print_table_sink(</span><br><span class=\"line\">    uid <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    city <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    cnt <span class=\"keyword\">long</span>,</span><br><span class=\"line\">    window_time <span class=\"built_in\">varchar</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'console'</span>,   <span class=\"comment\">-- print console</span></span><br><span class=\"line\">    other = <span class=\"string\">'demo001'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 定义维表</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> batch <span class=\"keyword\">table</span> <span class=\"keyword\">users</span>(</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    city <span class=\"built_in\">varchar</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- print console</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span></span><br><span class=\"line\">    <span class=\"comment\">-- query = 'select * from users where ...'  --可以下推谓词</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 描述数据流计算过程</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> print_table_sink</span><br><span class=\"line\"><span class=\"keyword\">with</span> tb1 <span class=\"keyword\">as</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> <span class=\"keyword\">key</span>, row_get(rowline,<span class=\"number\">0</span>) <span class=\"keyword\">as</span> uid , row_get(rowline,<span class=\"number\">1</span>) <span class=\"keyword\">as</span> ip, event_time, proctime</span><br><span class=\"line\">    <span class=\"keyword\">from</span> topic1 , LATERAL <span class=\"keyword\">TABLE</span>(json_parser(<span class=\"string\">`value`</span>,<span class=\"string\">'user_id,ip'</span>)) <span class=\"keyword\">as</span> T(rowline) </span><br><span class=\"line\">),tb2 <span class=\"keyword\">as</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> uid,</span><br><span class=\"line\">    <span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> <span class=\"keyword\">key</span>) <span class=\"keyword\">as</span> cnt,</span><br><span class=\"line\">    <span class=\"keyword\">cast</span>(TUMBLE_START(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>)|| <span class=\"string\">'--&gt;'</span> </span><br><span class=\"line\">    || <span class=\"keyword\">cast</span>(TUMBLE_END(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>) <span class=\"keyword\">AS</span> start_time</span><br><span class=\"line\">    <span class=\"keyword\">from</span> tb1 <span class=\"keyword\">where</span> uid <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> uid,TUMBLE(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>)</span><br><span class=\"line\">) </span><br><span class=\"line\"><span class=\"keyword\">select</span> tb2.uid, users.name ,users.city, tb2.cnt, tb2.start_time </span><br><span class=\"line\"><span class=\"keyword\">from</span> tb2 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> <span class=\"keyword\">users</span> <span class=\"keyword\">on</span> tb2.uid = users.id</span><br><span class=\"line\"><span class=\"keyword\">having</span> <span class=\"number\">1</span>=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意事项\"><a class=\"markdown-anchor\" href=\"#注意事项\">#</a> 注意事项</h3>\n<ul>\n<li>1, 维表join时 为了解析方便,请尽量将维表放到右边</li>\n<li>2, 只支持left join 和 Inner join(维表在右边时), 详细原因可以参考: <a href=\"join\">http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#support-matrix-for-joins-in-streaming-queries</a></li>\n<li>3  <code>on</code> 只支持and(equals) 例如: <code>条件1 and 条件2 and 条件3</code></li>\n<li>4  对于条件只支持equals(<code>=</code>) 例如: <code>on tb1.a1=tb2.id and ...</code></li>\n<li>5  对于equals条件暂时不支持常量, 例如: <code>on tb1.a1 = 'sylph'</code> 目前是不支持的, 原因是涉及到谓词下推问题</li>\n<li>6  不支持join where 原因如上 因为涉及到谓词下推问题</li>\n<li>7  完整支持 having语句</li>\n</ul>\n<h3 id=\"关于维表插件-目前只实现了mysql\"><a class=\"markdown-anchor\" href=\"#关于维表插件-目前只实现了mysql\">#</a> 关于维表插件 目前只实现了mysql</h3>\n<p>实现非常简单,请参考 sylph-mysql/ideal.sylph.plugins.mysql.MysqlAsyncFunction.java\n如果有用到redis或者别的 可参考这个进行简单实现,或参考<code>进阶</code>中开发指南</p>\n<h3 id=\"关于缓存问题\"><a class=\"markdown-anchor\" href=\"#关于缓存问题\">#</a> 关于缓存问题</h3>\n<p>MysqlAsyncFunction 采用LRU缓存策略, 使用的本地缓存. 如果想使用分布式缓存,可以自行修改非常简单.</p>\n<h3 id=\"other\"><a class=\"markdown-anchor\" href=\"#other\">#</a> other</h3>\n<ul>\n<li>关于json 解析采用的udtf来实现的,总体上因为calcite语法原因 对比hive显得不够优雅\n但在这种方案不影响性能 切非常灵活</li>\n<li>上面示例mysql 建表语句如下:</li>\n</ul>\n<pre><code class=\"language-mysql\">-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` varchar(10) NOT NULL,\n  `name` varchar(20) NOT NULL,\n  `city` char(20) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'h123', '123');\nINSERT INTO `users` VALUES ('2', 'p123', '123');\nINSERT INTO `users` VALUES ('4', '小王', 'dikd3939');\nINSERT INTO `users` VALUES ('uid_1', 'test', 'test');\nINSERT INTO `users` VALUES ('uid_5', 'sylph', 'demo');\n</code></pre>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>维表join在大数据中非常常见,通常我们需要在入库时对数据进行过滤和join打宽.\nsylph sql现在已经支持简单的维表join,</p>\n<h3 id=\"demo\"><a class=\"markdown-anchor\" href=\"#demo\">#</a> demo</h3>\n<p>下面将通过一个demo来演示sylph 的join功能.\n该例子模拟读取实时json数据进行解析取出user_id和ip字段,\n然后计算每个用户每5秒的<code>count(distinct key)</code>数,\n接下来和mysql中的users表 进行join取出 name和city。\n最后 Insert into 存储数据到外部\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> json_parser <span class=\"keyword\">as</span> <span class=\"string\">'ideal.sylph.runner.flink.udf.JsonParser'</span>;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> row_get <span class=\"keyword\">as</span> <span class=\"string\">'ideal.sylph.runner.flink.udf.RowGet'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    <span class=\"keyword\">key</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">value</span> <span class=\"built_in\">varchar</span>,     <span class=\"comment\">-- json</span></span><br><span class=\"line\">    event_time <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'ideal.sylph.plugins.flink.source.TestSource'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 定义数据流输出位置</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> print_table_sink(</span><br><span class=\"line\">    uid <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    city <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    cnt <span class=\"keyword\">long</span>,</span><br><span class=\"line\">    window_time <span class=\"built_in\">varchar</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'console'</span>,   <span class=\"comment\">-- print console</span></span><br><span class=\"line\">    other = <span class=\"string\">'demo001'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 定义维表</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> batch <span class=\"keyword\">table</span> <span class=\"keyword\">users</span>(</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    city <span class=\"built_in\">varchar</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- print console</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span></span><br><span class=\"line\">    <span class=\"comment\">-- query = 'select * from users where ...'  --可以下推谓词</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 描述数据流计算过程</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> print_table_sink</span><br><span class=\"line\"><span class=\"keyword\">with</span> tb1 <span class=\"keyword\">as</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> <span class=\"keyword\">key</span>, row_get(rowline,<span class=\"number\">0</span>) <span class=\"keyword\">as</span> uid , row_get(rowline,<span class=\"number\">1</span>) <span class=\"keyword\">as</span> ip, event_time, proctime</span><br><span class=\"line\">    <span class=\"keyword\">from</span> topic1 , LATERAL <span class=\"keyword\">TABLE</span>(json_parser(<span class=\"string\">`value`</span>,<span class=\"string\">'user_id,ip'</span>)) <span class=\"keyword\">as</span> T(rowline) </span><br><span class=\"line\">),tb2 <span class=\"keyword\">as</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> uid,</span><br><span class=\"line\">    <span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> <span class=\"keyword\">key</span>) <span class=\"keyword\">as</span> cnt,</span><br><span class=\"line\">    <span class=\"keyword\">cast</span>(TUMBLE_START(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>)|| <span class=\"string\">'--&gt;'</span> </span><br><span class=\"line\">    || <span class=\"keyword\">cast</span>(TUMBLE_END(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>) <span class=\"keyword\">AS</span> start_time</span><br><span class=\"line\">    <span class=\"keyword\">from</span> tb1 <span class=\"keyword\">where</span> uid <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> uid,TUMBLE(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'5'</span> <span class=\"keyword\">SECOND</span>)</span><br><span class=\"line\">) </span><br><span class=\"line\"><span class=\"keyword\">select</span> tb2.uid, users.name ,users.city, tb2.cnt, tb2.start_time </span><br><span class=\"line\"><span class=\"keyword\">from</span> tb2 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> <span class=\"keyword\">users</span> <span class=\"keyword\">on</span> tb2.uid = users.id</span><br><span class=\"line\"><span class=\"keyword\">having</span> <span class=\"number\">1</span>=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意事项\"><a class=\"markdown-anchor\" href=\"#注意事项\">#</a> 注意事项</h3>\n<ul>\n<li>1, 维表join时 为了解析方便,请尽量将维表放到右边</li>\n<li>2, 只支持left join 和 Inner join(维表在右边时), 详细原因可以参考: <a href=\"join\">http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#support-matrix-for-joins-in-streaming-queries</a></li>\n<li>3  <code>on</code> 只支持and(equals) 例如: <code>条件1 and 条件2 and 条件3</code></li>\n<li>4  对于条件只支持equals(<code>=</code>) 例如: <code>on tb1.a1=tb2.id and ...</code></li>\n<li>5  对于equals条件暂时不支持常量, 例如: <code>on tb1.a1 = 'sylph'</code> 目前是不支持的, 原因是涉及到谓词下推问题</li>\n<li>6  不支持join where 原因如上 因为涉及到谓词下推问题</li>\n<li>7  完整支持 having语句</li>\n</ul>\n<h3 id=\"关于维表插件-目前只实现了mysql\"><a class=\"markdown-anchor\" href=\"#关于维表插件-目前只实现了mysql\">#</a> 关于维表插件 目前只实现了mysql</h3>\n<p>实现非常简单,请参考 sylph-mysql/ideal.sylph.plugins.mysql.MysqlAsyncFunction.java\n如果有用到redis或者别的 可参考这个进行简单实现,或参考<code>进阶</code>中开发指南</p>\n<h3 id=\"关于缓存问题\"><a class=\"markdown-anchor\" href=\"#关于缓存问题\">#</a> 关于缓存问题</h3>\n<p>MysqlAsyncFunction 采用LRU缓存策略, 使用的本地缓存. 如果想使用分布式缓存,可以自行修改非常简单.</p>\n<h3 id=\"other\"><a class=\"markdown-anchor\" href=\"#other\">#</a> other</h3>\n<ul>\n<li>关于json 解析采用的udtf来实现的,总体上因为calcite语法原因 对比hive显得不够优雅\n但在这种方案不影响性能 切非常灵活</li>\n<li>上面示例mysql 建表语句如下:</li>\n</ul>\n<pre><code class=\"language-mysql\">-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` varchar(10) NOT NULL,\n  `name` varchar(20) NOT NULL,\n  `city` char(20) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'h123', '123');\nINSERT INTO `users` VALUES ('2', 'p123', '123');\nINSERT INTO `users` VALUES ('4', '小王', 'dikd3939');\nINSERT INTO `users` VALUES ('uid_1', 'test', 'test');\nINSERT INTO `users` VALUES ('uid_5', 'sylph', 'demo');\n</code></pre>\n"},{"title":"微信授权","_content":"\n后端服务通常对微信授权相关接口做了IP限制，我们联调测试时候需要关闭其限制。\n\n### 内网接口\n\n- /hongbao/getmobilebyopenid\n- /hongbao/addmobileopenid\n- /hongbao/updatemobilebyopenid\n\n### 关闭内网限制\n\n    /home/map/odp_cater/app/hongbao/actions/api\n    \n    注释：$this->checkIp = true;\n\n### 附微信授权原理流程图\n\n![wechat](http://younth.coding.me/static/wechat-auth.png)","source":"zh-cn/docs/faq/wechat.md","raw":"title: 微信授权\n---\n\n后端服务通常对微信授权相关接口做了IP限制，我们联调测试时候需要关闭其限制。\n\n### 内网接口\n\n- /hongbao/getmobilebyopenid\n- /hongbao/addmobileopenid\n- /hongbao/updatemobilebyopenid\n\n### 关闭内网限制\n\n    /home/map/odp_cater/app/hongbao/actions/api\n    \n    注释：$this->checkIp = true;\n\n### 附微信授权原理流程图\n\n![wechat](http://younth.coding.me/static/wechat-auth.png)","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/faq/wechat.html","comments":1,"layout":"page","_id":"cjyd4skjr001f6lq1s37uh2ip","content":"<p>后端服务通常对微信授权相关接口做了IP限制，我们联调测试时候需要关闭其限制。</p>\n<h3 id=\"内网接口\"><a class=\"markdown-anchor\" href=\"#内网接口\">#</a> 内网接口</h3>\n<ul>\n<li>/hongbao/getmobilebyopenid</li>\n<li>/hongbao/addmobileopenid</li>\n<li>/hongbao/updatemobilebyopenid</li>\n</ul>\n<h3 id=\"关闭内网限制\"><a class=\"markdown-anchor\" href=\"#关闭内网限制\">#</a> 关闭内网限制</h3>\n<pre><code>/home/map/odp_cater/app/hongbao/actions/api\n\n注释：$this-&gt;checkIp = true;\n</code></pre>\n<h3 id=\"附微信授权原理流程图\"><a class=\"markdown-anchor\" href=\"#附微信授权原理流程图\">#</a> 附微信授权原理流程图</h3>\n<p><img src=\"http://younth.coding.me/static/wechat-auth.png\" alt=\"wechat\"></p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>后端服务通常对微信授权相关接口做了IP限制，我们联调测试时候需要关闭其限制。</p>\n<h3 id=\"内网接口\"><a class=\"markdown-anchor\" href=\"#内网接口\">#</a> 内网接口</h3>\n<ul>\n<li>/hongbao/getmobilebyopenid</li>\n<li>/hongbao/addmobileopenid</li>\n<li>/hongbao/updatemobilebyopenid</li>\n</ul>\n<h3 id=\"关闭内网限制\"><a class=\"markdown-anchor\" href=\"#关闭内网限制\">#</a> 关闭内网限制</h3>\n<pre><code>/home/map/odp_cater/app/hongbao/actions/api\n\n注释：$this-&gt;checkIp = true;\n</code></pre>\n<h3 id=\"附微信授权原理流程图\"><a class=\"markdown-anchor\" href=\"#附微信授权原理流程图\">#</a> 附微信授权原理流程图</h3>\n<p><img src=\"http://younth.coding.me/static/wechat-auth.png\" alt=\"wechat\"></p>\n"},{"title":"ETL 任务介绍","_content":"\nstreamSql描述流计算非常简单快捷,但是某些时候有些业务逻辑不便于sql化, 也不需要用到window等复杂机制\n需要通过代码实现更复杂的数据数据处理,但希望整个数据流处理变的简单。那么这时使用流式ETL是非常合适的\n\n### node\nsylph对etl过程进行如下三个环节(node)抽象,将一切数据流活动都用如下三个环节表示,并通过`箭头`表示数据流向\n通过一个flow来描述整个流计算过程\n- source\n    (该算子实现如何将数据流接入系统)\n- transform\n    (该算子实现如何将数据流进行转换)\n- sink\n    (该算子实现如何将数据流输到外部系统中)\n    \n### flow\n![job_flow]\n\n如上图通过 flow描述了一个实时etl过程,实例为: kafka->业务处理->hdfs\n\n[job_flow]: ../../../images/sylph/job_flow.png","source":"zh-cn/docs/intro/etl.md","raw":"title: ETL 任务介绍\n---\n\nstreamSql描述流计算非常简单快捷,但是某些时候有些业务逻辑不便于sql化, 也不需要用到window等复杂机制\n需要通过代码实现更复杂的数据数据处理,但希望整个数据流处理变的简单。那么这时使用流式ETL是非常合适的\n\n### node\nsylph对etl过程进行如下三个环节(node)抽象,将一切数据流活动都用如下三个环节表示,并通过`箭头`表示数据流向\n通过一个flow来描述整个流计算过程\n- source\n    (该算子实现如何将数据流接入系统)\n- transform\n    (该算子实现如何将数据流进行转换)\n- sink\n    (该算子实现如何将数据流输到外部系统中)\n    \n### flow\n![job_flow]\n\n如上图通过 flow描述了一个实时etl过程,实例为: kafka->业务处理->hdfs\n\n[job_flow]: ../../../images/sylph/job_flow.png","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/intro/etl.html","comments":1,"layout":"page","_id":"cjyd4skjs001g6lq1r5rip5yb","content":"<p>streamSql描述流计算非常简单快捷,但是某些时候有些业务逻辑不便于sql化, 也不需要用到window等复杂机制\n需要通过代码实现更复杂的数据数据处理,但希望整个数据流处理变的简单。那么这时使用流式ETL是非常合适的</p>\n<h3 id=\"node\"><a class=\"markdown-anchor\" href=\"#node\">#</a> node</h3>\n<p>sylph对etl过程进行如下三个环节(node)抽象,将一切数据流活动都用如下三个环节表示,并通过<code>箭头</code>表示数据流向\n通过一个flow来描述整个流计算过程</p>\n<ul>\n<li>source\n(该算子实现如何将数据流接入系统)</li>\n<li>transform\n(该算子实现如何将数据流进行转换)</li>\n<li>sink\n(该算子实现如何将数据流输到外部系统中)</li>\n</ul>\n<h3 id=\"flow\"><a class=\"markdown-anchor\" href=\"#flow\">#</a> flow</h3>\n<p><img src=\"../../../images/sylph/job_flow.png\" alt=\"job_flow\"></p>\n<p>如上图通过 flow描述了一个实时etl过程,实例为: kafka-&gt;业务处理-&gt;hdfs</p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>streamSql描述流计算非常简单快捷,但是某些时候有些业务逻辑不便于sql化, 也不需要用到window等复杂机制\n需要通过代码实现更复杂的数据数据处理,但希望整个数据流处理变的简单。那么这时使用流式ETL是非常合适的</p>\n<h3 id=\"node\"><a class=\"markdown-anchor\" href=\"#node\">#</a> node</h3>\n<p>sylph对etl过程进行如下三个环节(node)抽象,将一切数据流活动都用如下三个环节表示,并通过<code>箭头</code>表示数据流向\n通过一个flow来描述整个流计算过程</p>\n<ul>\n<li>source\n(该算子实现如何将数据流接入系统)</li>\n<li>transform\n(该算子实现如何将数据流进行转换)</li>\n<li>sink\n(该算子实现如何将数据流输到外部系统中)</li>\n</ul>\n<h3 id=\"flow\"><a class=\"markdown-anchor\" href=\"#flow\">#</a> flow</h3>\n<p><img src=\"../../../images/sylph/job_flow.png\" alt=\"job_flow\"></p>\n<p>如上图通过 flow描述了一个实时etl过程,实例为: kafka-&gt;业务处理-&gt;hdfs</p>\n"},{"title":"SYLPH 是什么?","_content":"\n**SYLPH 是一个用于实时流计算的平台,核心是通过工作流描述构建分布式流计算应用程序。**,SYLPH是一套完整的解决方案，主要包括：\n\n- 开发工具：`webUI`, 定义streamSql或streamETl任务\n- 运行时：基于`spark2.x`及`flink1.5+` , 依赖`hdfs`和`yarn`\n- pipline插件扩展: `java8`, 按需实现`source`,`transform`,`sink`\n- 基础运维：在`webUI`完成任务创建后一键部署上线,无需人工部署,整个分布式程序由sylph进行管理\n- 运行分析: 在sylph`webUI` 上面即可看到任务运行情况,不再需要打隧道查看yarn任务\n\n\n## 设计原则\n\n- 利用插件系统分离**配置与实现**\n- 奉行『**约定优于配置**』，按照[一套统一的约定]进行应用开发，从开发工具，到目录结构。\n\n## 特性\n\n- 快速完成实时计算任务：StreamSql\n- 灵活性: 可以简单自主定制 pipeline节点插件\n- 便捷的部署：自动重启，一键上线到yarn\n- 简单的运维：日志 监控\n\n## 什么样的场景适合用SYLPH\n\n目前SYLPH的定位主要是`实时etl数据处理能力`及`实时流计算`。基于这两大能力，SYLPH有自己的特定应用场景。主要如下：\n\n- 快速实验流计算\n- 管理流计算任务\n","source":"zh-cn/docs/intro/index.md","raw":"title: SYLPH 是什么?\n---\n\n**SYLPH 是一个用于实时流计算的平台,核心是通过工作流描述构建分布式流计算应用程序。**,SYLPH是一套完整的解决方案，主要包括：\n\n- 开发工具：`webUI`, 定义streamSql或streamETl任务\n- 运行时：基于`spark2.x`及`flink1.5+` , 依赖`hdfs`和`yarn`\n- pipline插件扩展: `java8`, 按需实现`source`,`transform`,`sink`\n- 基础运维：在`webUI`完成任务创建后一键部署上线,无需人工部署,整个分布式程序由sylph进行管理\n- 运行分析: 在sylph`webUI` 上面即可看到任务运行情况,不再需要打隧道查看yarn任务\n\n\n## 设计原则\n\n- 利用插件系统分离**配置与实现**\n- 奉行『**约定优于配置**』，按照[一套统一的约定]进行应用开发，从开发工具，到目录结构。\n\n## 特性\n\n- 快速完成实时计算任务：StreamSql\n- 灵活性: 可以简单自主定制 pipeline节点插件\n- 便捷的部署：自动重启，一键上线到yarn\n- 简单的运维：日志 监控\n\n## 什么样的场景适合用SYLPH\n\n目前SYLPH的定位主要是`实时etl数据处理能力`及`实时流计算`。基于这两大能力，SYLPH有自己的特定应用场景。主要如下：\n\n- 快速实验流计算\n- 管理流计算任务\n","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/intro/index.html","comments":1,"layout":"page","_id":"cjyd4skjt001h6lq12inup7m0","content":"<p><strong>SYLPH 是一个用于实时流计算的平台,核心是通过工作流描述构建分布式流计算应用程序。</strong>,SYLPH是一套完整的解决方案，主要包括：</p>\n<ul>\n<li>开发工具：<code>webUI</code>, 定义streamSql或streamETl任务</li>\n<li>运行时：基于<code>spark2.x</code>及<code>flink1.5+</code> , 依赖<code>hdfs</code>和<code>yarn</code></li>\n<li>pipline插件扩展: <code>java8</code>, 按需实现<code>source</code>,<code>transform</code>,<code>sink</code></li>\n<li>基础运维：在<code>webUI</code>完成任务创建后一键部署上线,无需人工部署,整个分布式程序由sylph进行管理</li>\n<li>运行分析: 在sylph<code>webUI</code> 上面即可看到任务运行情况,不再需要打隧道查看yarn任务</li>\n</ul>\n<h2 id=\"设计原则\"><a class=\"markdown-anchor\" href=\"#设计原则\">#</a> 设计原则</h2>\n<ul>\n<li>利用插件系统分离<strong>配置与实现</strong></li>\n<li>奉行『<strong>约定优于配置</strong>』，按照[一套统一的约定]进行应用开发，从开发工具，到目录结构。</li>\n</ul>\n<h2 id=\"特性\"><a class=\"markdown-anchor\" href=\"#特性\">#</a> 特性</h2>\n<ul>\n<li>快速完成实时计算任务：StreamSql</li>\n<li>灵活性: 可以简单自主定制 pipeline节点插件</li>\n<li>便捷的部署：自动重启，一键上线到yarn</li>\n<li>简单的运维：日志 监控</li>\n</ul>\n<h2 id=\"什么样的场景适合用sylph\"><a class=\"markdown-anchor\" href=\"#什么样的场景适合用sylph\">#</a> 什么样的场景适合用SYLPH</h2>\n<p>目前SYLPH的定位主要是<code>实时etl数据处理能力</code>及<code>实时流计算</code>。基于这两大能力，SYLPH有自己的特定应用场景。主要如下：</p>\n<ul>\n<li>快速实验流计算</li>\n<li>管理流计算任务</li>\n</ul>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p><strong>SYLPH 是一个用于实时流计算的平台,核心是通过工作流描述构建分布式流计算应用程序。</strong>,SYLPH是一套完整的解决方案，主要包括：</p>\n<ul>\n<li>开发工具：<code>webUI</code>, 定义streamSql或streamETl任务</li>\n<li>运行时：基于<code>spark2.x</code>及<code>flink1.5+</code> , 依赖<code>hdfs</code>和<code>yarn</code></li>\n<li>pipline插件扩展: <code>java8</code>, 按需实现<code>source</code>,<code>transform</code>,<code>sink</code></li>\n<li>基础运维：在<code>webUI</code>完成任务创建后一键部署上线,无需人工部署,整个分布式程序由sylph进行管理</li>\n<li>运行分析: 在sylph<code>webUI</code> 上面即可看到任务运行情况,不再需要打隧道查看yarn任务</li>\n</ul>\n<h2 id=\"设计原则\"><a class=\"markdown-anchor\" href=\"#设计原则\">#</a> 设计原则</h2>\n<ul>\n<li>利用插件系统分离<strong>配置与实现</strong></li>\n<li>奉行『<strong>约定优于配置</strong>』，按照[一套统一的约定]进行应用开发，从开发工具，到目录结构。</li>\n</ul>\n<h2 id=\"特性\"><a class=\"markdown-anchor\" href=\"#特性\">#</a> 特性</h2>\n<ul>\n<li>快速完成实时计算任务：StreamSql</li>\n<li>灵活性: 可以简单自主定制 pipeline节点插件</li>\n<li>便捷的部署：自动重启，一键上线到yarn</li>\n<li>简单的运维：日志 监控</li>\n</ul>\n<h2 id=\"什么样的场景适合用sylph\"><a class=\"markdown-anchor\" href=\"#什么样的场景适合用sylph\">#</a> 什么样的场景适合用SYLPH</h2>\n<p>目前SYLPH的定位主要是<code>实时etl数据处理能力</code>及<code>实时流计算</code>。基于这两大能力，SYLPH有自己的特定应用场景。主要如下：</p>\n<ul>\n<li>快速实验流计算</li>\n<li>管理流计算任务</li>\n</ul>\n"},{"title":"快速入门","_content":"\n下面将以StreamSql为实例，一步步地搭建出一个 分布式流计算应用，让你能快速的入门 SYLPH。\n\n> StreamSql是完全通过类sql来描述整个流计算的过程。主要需要描述: 数据源如何接入、如何计算、如何输出到外部存储; \n例如计算每分钟的pv; 每5秒更新一次最近一分钟的uv。\n\n### demo1\n下面例子演示将kafka topic `TP_A_1,TP_A_2`的数据实时写入mysql表`mysql_table_sink`中\n\n**注意: mysql中表`mysql_table_sink`需要提前自行创建好,并且字段类型要和实际兼容**\n```sql\n-- 定义数据流接入 \ncreate source table topic1(\n    _topic varchar,\n    _key varchar,\n    _message varchar,\n    _partition integer,\n    _offset bigint\n) with (\n    type = 'kafka',\n    kafka_topic = 'TP_A_1,TP_A_2',\n    \"auto.offset.reset\" = latest,\n    kafka_broker = 'localhost:9092',\n    kafka_group_id = 'streamSql_test1'\n);\n-- 定义数据流输出位置\ncreate sink table mysql_table_sink(\n    a1 varchar,\n    a2 varchar,\n    event_time bigint\n) with (\n    type = 'mysql',   -- ideal.sylph.plugins.flink.sink.MysqlSink.java\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false',\n    query = 'insert into mysql_table_sink values(${0},${1},${2})'\n);\n-- 描述数据流计算过程\ninsert into mysql_table_sink\nselect _topic,`_message`,cast(_offset as bigint) from topic1 where _key is not null\n```\n\n### demo2\n下面的例子 演示如何计算topic `TP_A_1`每分钟的uv\n```sql\ncreate source table topic1(\n    _topic varchar,\n    _key varchar,\n    _message varchar,\n    _partition integer,\n    _offset bigint\n) with (\n    type = 'kafka',\n    kafka_topic = 'TP_A_1',\n    \"auto.offset.reset\" = latest,\n    kafka_broker = 'localhost:9092',\n    kafka_group_id = 'streamSql_test1'\n);\n\ncreate sink table mysql_uv_table_sink(\n    user_id varchar,\n    uv bigint,\n    cnt_time date\n) with (\n    type = 'mysql',   -- ideal.sylph.plugins.flink.sink.MysqlSink.java\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false',\n    query = 'insert into mysql_uv_table_sink values(${0},${1},${2})'\n);\n\nwith tb13 as (SELECT proctime\n    ,row_get(rowline,0)as user_id\n    FROM topic1, LATERAL TABLE(json_parser(_message,'user_id')) as T(rowline) \n    where cast(row_get(rowline,0) as varchar) is not null\n)\ninsert into mysql_uv_table_sink\nselect \nuser_id,\ncount(distinct user_id) as uv\n,TUMBLE_START(proctime,INTERVAL '60' SECOND) AS window_start \nFROM tb13 GROUP BY user_id,TUMBLE(proctime,INTERVAL '60' SECOND)\n```\n\n### strteamSql设计器\n![strteamSql]\n\n[strteamSql]: ../../../images/sylph/strteam_sql.png","source":"zh-cn/docs/intro/quickstart.md","raw":"title: 快速入门 \n---\n\n下面将以StreamSql为实例，一步步地搭建出一个 分布式流计算应用，让你能快速的入门 SYLPH。\n\n> StreamSql是完全通过类sql来描述整个流计算的过程。主要需要描述: 数据源如何接入、如何计算、如何输出到外部存储; \n例如计算每分钟的pv; 每5秒更新一次最近一分钟的uv。\n\n### demo1\n下面例子演示将kafka topic `TP_A_1,TP_A_2`的数据实时写入mysql表`mysql_table_sink`中\n\n**注意: mysql中表`mysql_table_sink`需要提前自行创建好,并且字段类型要和实际兼容**\n```sql\n-- 定义数据流接入 \ncreate source table topic1(\n    _topic varchar,\n    _key varchar,\n    _message varchar,\n    _partition integer,\n    _offset bigint\n) with (\n    type = 'kafka',\n    kafka_topic = 'TP_A_1,TP_A_2',\n    \"auto.offset.reset\" = latest,\n    kafka_broker = 'localhost:9092',\n    kafka_group_id = 'streamSql_test1'\n);\n-- 定义数据流输出位置\ncreate sink table mysql_table_sink(\n    a1 varchar,\n    a2 varchar,\n    event_time bigint\n) with (\n    type = 'mysql',   -- ideal.sylph.plugins.flink.sink.MysqlSink.java\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false',\n    query = 'insert into mysql_table_sink values(${0},${1},${2})'\n);\n-- 描述数据流计算过程\ninsert into mysql_table_sink\nselect _topic,`_message`,cast(_offset as bigint) from topic1 where _key is not null\n```\n\n### demo2\n下面的例子 演示如何计算topic `TP_A_1`每分钟的uv\n```sql\ncreate source table topic1(\n    _topic varchar,\n    _key varchar,\n    _message varchar,\n    _partition integer,\n    _offset bigint\n) with (\n    type = 'kafka',\n    kafka_topic = 'TP_A_1',\n    \"auto.offset.reset\" = latest,\n    kafka_broker = 'localhost:9092',\n    kafka_group_id = 'streamSql_test1'\n);\n\ncreate sink table mysql_uv_table_sink(\n    user_id varchar,\n    uv bigint,\n    cnt_time date\n) with (\n    type = 'mysql',   -- ideal.sylph.plugins.flink.sink.MysqlSink.java\n    userName = 'demo',\n    password = 'demo',\n    url = 'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&useSSL=false',\n    query = 'insert into mysql_uv_table_sink values(${0},${1},${2})'\n);\n\nwith tb13 as (SELECT proctime\n    ,row_get(rowline,0)as user_id\n    FROM topic1, LATERAL TABLE(json_parser(_message,'user_id')) as T(rowline) \n    where cast(row_get(rowline,0) as varchar) is not null\n)\ninsert into mysql_uv_table_sink\nselect \nuser_id,\ncount(distinct user_id) as uv\n,TUMBLE_START(proctime,INTERVAL '60' SECOND) AS window_start \nFROM tb13 GROUP BY user_id,TUMBLE(proctime,INTERVAL '60' SECOND)\n```\n\n### strteamSql设计器\n![strteamSql]\n\n[strteamSql]: ../../../images/sylph/strteam_sql.png","date":"2019-07-21T11:14:44.066Z","updated":"2019-07-06T12:37:40.000Z","path":"zh-cn/docs/intro/quickstart.html","comments":1,"layout":"page","_id":"cjyd4skju001i6lq19lltsztp","content":"<p>下面将以StreamSql为实例，一步步地搭建出一个 分布式流计算应用，让你能快速的入门 SYLPH。</p>\n<blockquote>\n<p>StreamSql是完全通过类sql来描述整个流计算的过程。主要需要描述: 数据源如何接入、如何计算、如何输出到外部存储;\n例如计算每分钟的pv; 每5秒更新一次最近一分钟的uv。</p>\n</blockquote>\n<h3 id=\"demo1\"><a class=\"markdown-anchor\" href=\"#demo1\">#</a> demo1</h3>\n<p>下面例子演示将kafka topic <code>TP_A_1,TP_A_2</code>的数据实时写入mysql表<code>mysql_table_sink</code>中</p>\n<p><strong>注意: mysql中表<code>mysql_table_sink</code>需要提前自行创建好,并且字段类型要和实际兼容</strong>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 定义数据流接入 </span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    _topic <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _key <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _message <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _partition <span class=\"built_in\">integer</span>,</span><br><span class=\"line\">    _offset <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">    kafka_topic = <span class=\"string\">'TP_A_1,TP_A_2'</span>,</span><br><span class=\"line\">    <span class=\"string\">\"auto.offset.reset\"</span> = latest,</span><br><span class=\"line\">    kafka_broker = <span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">    kafka_group_id = <span class=\"string\">'streamSql_test1'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">-- 定义数据流输出位置</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> mysql_table_sink(</span><br><span class=\"line\">    a1 <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    a2 <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    event_time <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- ideal.sylph.plugins.flink.sink.MysqlSink.java</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">query</span> = <span class=\"string\">'insert into mysql_table_sink values($&#123;0&#125;,$&#123;1&#125;,$&#123;2&#125;)'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">-- 描述数据流计算过程</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> mysql_table_sink</span><br><span class=\"line\"><span class=\"keyword\">select</span> _topic,<span class=\"string\">`_message`</span>,<span class=\"keyword\">cast</span>(_offset <span class=\"keyword\">as</span> <span class=\"built_in\">bigint</span>) <span class=\"keyword\">from</span> topic1 <span class=\"keyword\">where</span> _key <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"demo2\"><a class=\"markdown-anchor\" href=\"#demo2\">#</a> demo2</h3>\n<p>下面的例子 演示如何计算topic <code>TP_A_1</code>每分钟的uv\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    _topic <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _key <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _message <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _partition <span class=\"built_in\">integer</span>,</span><br><span class=\"line\">    _offset <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">    kafka_topic = <span class=\"string\">'TP_A_1'</span>,</span><br><span class=\"line\">    <span class=\"string\">\"auto.offset.reset\"</span> = latest,</span><br><span class=\"line\">    kafka_broker = <span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">    kafka_group_id = <span class=\"string\">'streamSql_test1'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> mysql_uv_table_sink(</span><br><span class=\"line\">    user_id <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    uv <span class=\"built_in\">bigint</span>,</span><br><span class=\"line\">    cnt_time <span class=\"built_in\">date</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- ideal.sylph.plugins.flink.sink.MysqlSink.java</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">query</span> = <span class=\"string\">'insert into mysql_uv_table_sink values($&#123;0&#125;,$&#123;1&#125;,$&#123;2&#125;)'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">with tb13 as (<span class=\"keyword\">SELECT</span> proctime</span><br><span class=\"line\">    ,row_get(rowline,<span class=\"number\">0</span>)<span class=\"keyword\">as</span> user_id</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> topic1, LATERAL <span class=\"keyword\">TABLE</span>(json_parser(_message,<span class=\"string\">'user_id'</span>)) <span class=\"keyword\">as</span> T(rowline) </span><br><span class=\"line\">    <span class=\"keyword\">where</span> <span class=\"keyword\">cast</span>(row_get(rowline,<span class=\"number\">0</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>) <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> mysql_uv_table_sink</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">user_id,</span><br><span class=\"line\"><span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> user_id) <span class=\"keyword\">as</span> uv</span><br><span class=\"line\">,TUMBLE_START(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'60'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">AS</span> window_start </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> tb13 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> user_id,TUMBLE(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'60'</span> <span class=\"keyword\">SECOND</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"strteamsql设计器\"><a class=\"markdown-anchor\" href=\"#strteamsql设计器\">#</a> strteamSql设计器</h3>\n<p><img src=\"../../../images/sylph/strteam_sql.png\" alt=\"strteamSql\"></p>\n","site":{"data":{"languages":{"en":"English","zh-tw":{"name":"正體中文","disqus_lang":"zh_TW"},"zh-cn":{"name":"简体中文","disqus_lang":"zh"},"ru":{"name":"Русский","disqus_lang":"ru"},"ko":{"name":"한국어","disqus_lang":"ko"}},"menu":{"document":"/docs/intro/","release":"https://github.com/harbby/sylph/releases","user":"/page/user.html"},"sidebar":{"docs":{"Intro":{"What is":"/docs/intro/index.html","Get Start":"/docs/intro/quickstart.html","Etl is":"/docs/intro/etl.html","batch join":"/docs/intro/batch-join.html"},"Basics":{"Setup":"/docs/basics/setup.html","Structure":"/docs/basics/structure.html","Deployment":"/docs/basics/deployment.html","GoOnline":"/docs/basics/online.html"},"Advanced":{"Framework":"/docs/advanced/framework.html","PluginManager":"/docs/advanced/plugin_manager.html","PluginApi":"/docs/advanced/plugin_api.html"},"FAQ":{"Deploy":"/docs/faq/deploy.html"},"Other":{"Service":"/docs/basics/service.html"}},"fekey":{"Intro":{"What is Fekey":"/fekey/index.html","Fekey Get Start":"/fekey/quickstart.html"}}}}},"excerpt":"","more":"<p>下面将以StreamSql为实例，一步步地搭建出一个 分布式流计算应用，让你能快速的入门 SYLPH。</p>\n<blockquote>\n<p>StreamSql是完全通过类sql来描述整个流计算的过程。主要需要描述: 数据源如何接入、如何计算、如何输出到外部存储;\n例如计算每分钟的pv; 每5秒更新一次最近一分钟的uv。</p>\n</blockquote>\n<h3 id=\"demo1\"><a class=\"markdown-anchor\" href=\"#demo1\">#</a> demo1</h3>\n<p>下面例子演示将kafka topic <code>TP_A_1,TP_A_2</code>的数据实时写入mysql表<code>mysql_table_sink</code>中</p>\n<p><strong>注意: mysql中表<code>mysql_table_sink</code>需要提前自行创建好,并且字段类型要和实际兼容</strong>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 定义数据流接入 </span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    _topic <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _key <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _message <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _partition <span class=\"built_in\">integer</span>,</span><br><span class=\"line\">    _offset <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">    kafka_topic = <span class=\"string\">'TP_A_1,TP_A_2'</span>,</span><br><span class=\"line\">    <span class=\"string\">\"auto.offset.reset\"</span> = latest,</span><br><span class=\"line\">    kafka_broker = <span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">    kafka_group_id = <span class=\"string\">'streamSql_test1'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">-- 定义数据流输出位置</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> mysql_table_sink(</span><br><span class=\"line\">    a1 <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    a2 <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    event_time <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- ideal.sylph.plugins.flink.sink.MysqlSink.java</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">query</span> = <span class=\"string\">'insert into mysql_table_sink values($&#123;0&#125;,$&#123;1&#125;,$&#123;2&#125;)'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">-- 描述数据流计算过程</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> mysql_table_sink</span><br><span class=\"line\"><span class=\"keyword\">select</span> _topic,<span class=\"string\">`_message`</span>,<span class=\"keyword\">cast</span>(_offset <span class=\"keyword\">as</span> <span class=\"built_in\">bigint</span>) <span class=\"keyword\">from</span> topic1 <span class=\"keyword\">where</span> _key <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"demo2\"><a class=\"markdown-anchor\" href=\"#demo2\">#</a> demo2</h3>\n<p>下面的例子 演示如何计算topic <code>TP_A_1</code>每分钟的uv\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">source</span> <span class=\"keyword\">table</span> topic1(</span><br><span class=\"line\">    _topic <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _key <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _message <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    _partition <span class=\"built_in\">integer</span>,</span><br><span class=\"line\">    _offset <span class=\"built_in\">bigint</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'kafka'</span>,</span><br><span class=\"line\">    kafka_topic = <span class=\"string\">'TP_A_1'</span>,</span><br><span class=\"line\">    <span class=\"string\">\"auto.offset.reset\"</span> = latest,</span><br><span class=\"line\">    kafka_broker = <span class=\"string\">'localhost:9092'</span>,</span><br><span class=\"line\">    kafka_group_id = <span class=\"string\">'streamSql_test1'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> sink <span class=\"keyword\">table</span> mysql_uv_table_sink(</span><br><span class=\"line\">    user_id <span class=\"built_in\">varchar</span>,</span><br><span class=\"line\">    uv <span class=\"built_in\">bigint</span>,</span><br><span class=\"line\">    cnt_time <span class=\"built_in\">date</span></span><br><span class=\"line\">) <span class=\"keyword\">with</span> (</span><br><span class=\"line\">    <span class=\"keyword\">type</span> = <span class=\"string\">'mysql'</span>,   <span class=\"comment\">-- ideal.sylph.plugins.flink.sink.MysqlSink.java</span></span><br><span class=\"line\">    userName = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> = <span class=\"string\">'demo'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">url</span> = <span class=\"string\">'jdbc:mysql://localhost:3306/pop?characterEncoding=utf-8&amp;useSSL=false'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">query</span> = <span class=\"string\">'insert into mysql_uv_table_sink values($&#123;0&#125;,$&#123;1&#125;,$&#123;2&#125;)'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">with tb13 as (<span class=\"keyword\">SELECT</span> proctime</span><br><span class=\"line\">    ,row_get(rowline,<span class=\"number\">0</span>)<span class=\"keyword\">as</span> user_id</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> topic1, LATERAL <span class=\"keyword\">TABLE</span>(json_parser(_message,<span class=\"string\">'user_id'</span>)) <span class=\"keyword\">as</span> T(rowline) </span><br><span class=\"line\">    <span class=\"keyword\">where</span> <span class=\"keyword\">cast</span>(row_get(rowline,<span class=\"number\">0</span>) <span class=\"keyword\">as</span> <span class=\"built_in\">varchar</span>) <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> mysql_uv_table_sink</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">user_id,</span><br><span class=\"line\"><span class=\"keyword\">count</span>(<span class=\"keyword\">distinct</span> user_id) <span class=\"keyword\">as</span> uv</span><br><span class=\"line\">,TUMBLE_START(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'60'</span> <span class=\"keyword\">SECOND</span>) <span class=\"keyword\">AS</span> window_start </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> tb13 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> user_id,TUMBLE(proctime,<span class=\"built_in\">INTERVAL</span> <span class=\"string\">'60'</span> <span class=\"keyword\">SECOND</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"strteamsql设计器\"><a class=\"markdown-anchor\" href=\"#strteamsql设计器\">#</a> strteamSql设计器</h3>\n<p><img src=\"../../../images/sylph/strteam_sql.png\" alt=\"strteamSql\"></p>\n"}],"Post":[],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}